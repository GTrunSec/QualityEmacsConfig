-*- lexical-binding:t -*-
* Docs
** Requirements
*** All
=xorg-server xorg-xrandr xorg-xinit xorg-setxkbmap mlocate atool unzip mono pulseaudio pavucontrol firefox the_silver_searcher imagemagick ttf-inconsolata ttf-opensans ttf-dejavu aspell aspell-en aspell-sv mpd mpc poppler poppler-glib=
*** All optional
=msbuild dotnet-sdk godot-mono guile fsharp ghc ghc-static=

*** Firefox
**** Plugins
https://addons.mozilla.org/en-US/firefox/addon/plasma-integration/

https://addons.mozilla.org/en-US/firefox/addon/yet-another-hints-extension/
OR
https://addons.mozilla.org/en-US/firefox/addon/vim-vixen/

***** Vim vixen config
#+begin_src example
{
  "keymaps": {
    "<C-m>": { "type": "follow.start", "newTab": false },
    "<C-j>": { "type": "follow.start", "newTab": true }
  },
  "search": {
    "default": "google",
    "engines": {
      "google": "https://google.com/search?q={}",
      "yahoo": "https://search.yahoo.com/search?p={}",
      "bing": "https://www.bing.com/search?q={}",
      "duckduckgo": "https://duckduckgo.com/?q={}",
      "twitter": "https://twitter.com/search?q={}",
      "wikipedia": "https://en.wikipedia.org/w/index.php?search={}"
    }
  },
  "properties": {
    "hintchars": "anetoshdirgmlwyfubxcvkp,.q;j/z",
    "smoothscroll": false,
    "complete": "sbh"
  },
  "blacklist": [
  ]
}
#+end_src

**** System packages
plasma-browser-integration

*** UTF-8 support
=ttf-dejavu= fills in the gaps where opensans doesn't have the character

*** Music
=mpd= =mpc=
=pulse audio= if alsa, etc, edit "MPD/Create config".

*** Search
=the silver searcher/ ag=
=grep=

*** Code
**** Documentation
=zeal=

**** C#
=mono=
=M-x omnisharp-install-server=

**** F#
=mono= (3.10.X or higher) =F#= (3.0 or higher)
To create solution file, check github
On windows, you may need to manually point to server path, see github

**** Clojure
=leiningen= =clojure=

*** Screenshots
=imagemagick=

*** Overtone
=jack2= =leiningen= =cider=

To start =leiningen= in emacs do =cider-jack-in=

Input =(use 'overtone.live)= into leiningen to install

**** To use with pulse audio
=cadence= and =pulseaudio-jack=

*** Spelling
=aspell-en= etc

*** Gnus
Set adress in gnus.el

*** Laptop
=xorg-xbacklight=
=wpa_supplicant=

*** Switch Ctrl and Caps
=xmodmap= =xsession=
 functions
*** PDF tools
=poppler= =poppler-glib=
M-x =pdf-tools-install=

*** GPG pinentry
=gpg2= =pinentry=

** Emacs events
*** Key to number
Run:
(read-event)
Then press a key

** Firefox vimium
*** Config
#+begin_src
# Rebind up/down
unbind n
unbind N
map n scrollDown
map N previousTab
unbind p
unbind P
map p scrollUp
map P nextTab

unbind k
unbind K
map k openCopiedUrlInCurrentTab
map K openCopiedUrlInNewTab

# Rebind scroll
unbind <c-u>
unbind <c-d>
map <c-u> scrollPageUp
map <c-d> scrollPageDown

# Rebind tab close
unbind s
map s removeTab
#+end_src

*** Hint characters
#+begin_src
anetoshdirgmlwyfubxcvkp,.q;j/z
#+end_src

** FSharp
*** File is not part of the loaded projects
Try having the =fsproj= file open in a buffer or try moving the project folder directly to the home folder

** Overtone
*** Pulse-jack
**** How to configure jack2 to work with pulse
https://wiki.archlinux.org/index.php/PulseAudio/Examples#PulseAudio_through_JACK
(The KXStudio method)

1. get =cadence= and =pulseaudio-jack=

2. Bridge alsa -> pulse -> jack

3. Autostart maybe???

4. Configure -> Alsa -> Good settings

**** Pauvcontrol measures sound but can't hear anything
Unmute the sound device in pauvcontrol

**** How should jack be started???
Let overtone (actually it's supercollider, since overtone is just a wrapper for using supercollider in clojure) do it (it does it automatically when inputting =(use 'overtone.live)= in leiningen)

*** Jack only
1. add =autospawn = no= in =~/.config/pulse/client.conf=
2. kill pulseaudio with =pulseaudio -k=
3. get =jack2= (NOT jack2-dbus, does't work)
4. start overtone

**** Still doesn't work
Get =qjackctl= and start =jack2= from there

*** Sounds only play in one ear??
https://github.com/overtone/overtone/wiki/Multi-channel-expansion,-stereo-and-panning
You have to specify sound channel in the code when using certain sounds

*** Overtone errors out all the time
Execute script up to down, put =(use 'overtone.live)= on top of file, and in leiningen

*** Shit doesn't work
just fiddle around with cadence (check if bridge type is correct, then force restart until it works)

** Dired
*** Archives in dired
Press c to compress, Z to extract
To stop dired from creating new folder when unpacking, change in section "Dired atool"

** Can't find package error in package.el
run
=package-refresh-contents=
or restart emacs

** Gnus
*** Setup mail with dovecot
1. Use nixos config
2. run my/write-mail-configs
3. Change permissions =chmod 600 ~/.dovecot-pass; chmod 600 ~/.msmtprc; chmod 600 ~/.mbsyncrc;=
4. Enter google app password, etc into ~/.msmtprc, ~/.mbsyncrc Don't modify .dovecot-pass
5.
6. Enable mail in device.el
7. Restart emacs, restart dovecot, etc

*** How to setup name and password without dovecot
Create authinfo.pgp file. It is auto encrypted/decrypted

Format for gmail is currently
#+begin_src
machine imap.gmail.com login <USER> password <APP-PASSWORD> port imaps
machine smtp.gmail.com login <USER> password <APP-PASSWORD> port 587
machine imap-mail.outlook.com login my-username@hotmail.com password my-secret-password port 993
#+end_src

*** gnus mails are not updating
Try doing C-u M-g twice inside that inbox

*** Where are my servers/passwords stored?
=~/.authinfo.gpg=

*** How to download articles using gnus?
use =M-x gnus-agent-add-server=

*** Mail server mails aren't marked as read when marking as read in gnus, and gnus isn't marking them as read either after exit
You have to press =q= in order to save changes

** wpa supplicant
https://wiki.archlinux.org/index.php/WPA_supplicant#Connecting_with_wpa_cli

** MPD
*** "no mpd daemon running"
Disable daemon if using systemctl with =systemctl disable mpd.service mpd.socket=

** Eww
*** Opening local file results in raw page
This is because the file isn't named =FILE.html=, when eww saves pages, it doesn't add =.html= at the end

** Keyboard setup
*** Change keyboard layout
To list keymaps, do =localectl list-keymaps=

=carpalx= is example layout
To load keymaps, in terminal do: =loadkeys carpalx=

To make permanent:
in =/etc/vconsole.conf=
#+begin_src
KEYMAP=carpalx
FONT=lat9w-16
#+end_src

*** Swap Ctrl and Caps_Lock
Load correct keymap
1. Do =sudo dumpkeys | head -1 > ~/Keys.map=
2. Add this under the one line long Keys.map
#+begin_src maps
keycode 58 = Control # Makes Caps Lock act as ctrl
keycode 29 = Caps_Lock # Makes ctrl act as caps
# alt_is_meta # Fix the alt key?
#+end_src
3. Do =sudo loadkeys ~/Keys.map=

** Color picking
Get =gpick=

** C libraries not imported
Add a .ccls file and format it like this
#+begin_src
  g++
  -lstdc++
  -I/usr/include/SDL2
#+end_src
(can also use clang++, etc)

*** Other reason
It could be that LSP doesn't tell CCLS the correct workspace
To fix this do =M-x lsp-workspace-folders-remove= then select what you think is the current workspace then =M-x lsp-workspace-folders-add= and select the actual root (the file with a =.ccls= file in it)

** GDB doesn't work properly
make sure you compiled with the =-g= flag

** Compatibility
*** Mesa 3d software rendering
Makes godot work with old computers
#+begin_src command
LIBGL_ALWAYS_SOFTWARE=1 godot-mono
#+end_src

** Sharing folders via virtualbox
https://wiki.archlinux.org/index.php/VirtualBox#Enable_shared_folders
1.
Devices -> Insert guest additions CD images

2.
On guest if arch install =virtualbox-guest-utils=

3.
Run
#+begin_src bash
sudo mount -t vboxsf -o uid=1000,gid=1000 SHARED_FOLDER_NAME MOUNT_DIR
#+end_src
1000 in the command is fetched from running =id=

** Omnisharp
ALWAYS check *omnisharp-log* for errors
Try building the program atleast once first before trying any of this, it could just fix the problem

*** Errors everywhere
Probably missing system.dll, etc reference
Could be that the references in your csproj are tailored to windows, etc

*** Only basic errors
Check this https://github.com/OmniSharp/omnisharp-emacs/issues/459
Otherwise it's probably because there are errors in *omnisharp-log*

*** Errors everywhere because of missing references
Check your csproj file
Remember that wildstars probably aren't supported in omnisharp! Add every script manually via counsel-locate, macros or whatever
Not like this
<Compile Include="*.cs" />
Like this
<Compile Include="Assets/Script.cs" />

** Magit
*** Rename commit
magit replace (r) in log buffer -> w for reword

** Regexps
Make regexps easier by using (rx)
E.g.
#+begin_src
  (rx bol "*.$" space)
#+end_src
Where =bol= is beginning of line, and =space= is anything that has whitespace syntax
For more symbols read =rx= help docs, it has everything

** WSL
*** When typing citation mark an @ is pasted using X11 passthrough
X11 probably uses UK language layout. Fix it with
#+begin_src shell
  setxkbmap us
#+end_src

** Haskell IDE engine / HIE
*** Error on first line of file
**** Cabal V2 related problem
It could be that HIE still doesn't support cabal V2, just run =cabal configure= to fix this

** Nix
*** Create project with cabal2nix
#+BEGIN_SRC emacs-lisp
cabal init
#+END_SRC

Setup cabal2nix
#+BEGIN_SRC shell
# Not really necessary
cabal2nix . > default.nix

cabal2nix --shell . > shell.nix
# beware that HIE might not work with new-configure, run normal configure instead for V1 project
*nix-shell --command 'cabal new-configure'
#+END_SRC

**** Automatically create default.nix and shell.nix from the cabal file
Add to default.nix
#+BEGIN_SRC
# default.nix
{ pkgs ? import <nixpkgs> {} }:

pkgs.haskellPackages.callCabal2nix "name" ./. {}
#+END_SRC

***** optional
And lastly add to shell.nix
#+BEGIN_SRC
# shell.nix
(import ./. {}).env
#+END_SRC
and just run *nix-shell then cabal build or whatver
Edit dependencies in cabal project file
Nix will always be used

OR
just run
#+BEGIN_SRC
*nix-shell -A env
#+END_SRC
always instead

* Todo
** Packages to try
nix-buffer

** PR evil-mc changes
** Delete around char 'c'
Need to find how to use the "inside" operator, etc
#+begin_src
  (evil-define-motion evil-find-char (char)
    (interactive "<C>")
    (evil-find-char 1 char)
    )
#+end_src

** Firefox
*** Bookmarks
https://www.reddit.com/r/emacs/comments/9bly3d/linkmarksel_use_orgmode_links_for_bookmarks/
https://www.emacswiki.org/emacs/BookMarks

** Annotations
https://github.com/bastibe/annotate.el

** Find out what is taking so long when opening config
Does it happen in vanilla?
Use error on quit, quit when loading is happening then get backtrace.
** Make magit-status faster during huge edits, or create new magit-status-fast command
** Should save-window-excursion be disabled?
Steps to reproduce: open two window split, do M-x, close the window you focused when doing M-x, cancel the M-x with C-g

** GPG doesn't remember last password when saving
** Automate gnus
*** Notmuch gnus integration
*** Dovecot docker process
Add to and configure in nixos config

** Add is wsl/VM in config
This will disable volume controls for example

** Locate
*** Locate should cut out the default directory from the prompt
*** Lisp only locate
Look into changing from locate to using "directory-files-recursively" to cache all files on the pc
Problem seems to be that it needs sudo to do this

** Fix ivy grep/occur
Colors change when you put your cursor over custom faces

** Fix change defalut directory to change save dir
** Customize ivy more

** % should go to closest paren if not on one
** Dedicated auto comment key?
** Make macros faster
Temporarily disable "global-hl-line-mode" while running macro (takes like 70% cpu in worst cases)
Disable symbol-overlay while in macro (takes little cpu, but you can still gain speed)

** Read large files package
There is one for dired too

** Refractor config
Maybe split up because of bad performance?
Should probably create some sort of guideline for where to write down prefix keys, where to write visual headers
I should probably not just have a header named just "visuals"

** Track down more performance problems
Especially when using highlight-indent-guides on large files

** Org-noter
Great for commenting pdfs

** Org-capture
Great for referencing to source code

** Fix swiper in man mode
** Easier way of accesing nix docs
man 5 configuration.nix
??
man configuration.nix

** Bake xdefaults into nix config

** Improve nix config
https://github.com/magnetophon/nixosConfig/blob/master/common.nix

** Fix lsp-ui
eldoc-doesn't work so i have to use  lsp-ui-sideline-show-hover

** Overhaul imenu
imenu-anywhere
imenu-list

** I shouldn't have one function that modifies all faces
Since then i have to load every package i want to modify the faces of before running the function

** Bind recenter screen to singe key in normal mode
** Structured-haskell-mode
** Navigate headers like parens
** Make locate work on all harddrives
Save the database on the main c drive under name of the drive though

** Eshell status in modeline
Checkout
(setq-default eshell-status-in-mode-line nil)

Then you can have a number like how many processes are running

** C-k in dired should go back dir

** Flycheck posframe should be in top right
Atleast not at point

** Add heading face to my/theme function
Make them bold?
Maybe different background color

** Maybe remove bold font from ivy match faces
I think bold fonts are slightly higher than normal fonts, which I think causes the minibuffer to not match ivy fully sometimes

** Make org-indent work with outlines
1. (setq org-outline-regexp "^;;\s\\*+")
2. Modify =org-indent--compute-prefixes= so that =org-indent--heading-line-prefixes= and maybe other variables are correct

** Fix config compile errors

** Compile before loading config for faster start times after modifying config
This gives me an error which seems to be related to straight.el where it can't require basic libraries
It might be related to the lexical bindings?
Right now I put a compilation step at the end of the config

** clone-indirect-buffer shouldn't make the new buffer appear in a different window than the selected one

** Make use of global mode map
evil-universal-define-key overwrites the evil mode map, this should use global-mode-map instead


** Fix keys
Exwm keys are really messy, remove 'my/keys-mode-map'

*** Clean global mode map
It's currently full of unused keys

*** Maybe only use evil-edit instead

** Try to fix performance of yascrollbar

** Fix unicode fonts
Right now unicode fonts are most of the time taller than the normal fonts

** Outlines
Fix the heading font-lock so that it also covers the comment part
*** Highlight to end of window
Maybe the outlines should be highlighted to the end of the window

** Optimize number key symbol placement
** Fix meta keys
*** my/switch-monitor

** Ivy menu for suspend-map
Also rename it to something better

** Heading text-object

** Fix my/gnus-topic-add-gmane-groups
It doesn't work and it's badly written

** Automate email setup
You could easily create prompts when creating the config files that modify the password and user fields

** Fix so that you can use counsel-yank in minibuffer again

** Make evil-commentary also comment multiple empty lines

** Haskell
*** Get ghc-imported-from
Currently broken

*** Get hlive
Currently broken

*** Direnv binds
Maybe add direnv bind for creating a .envrc with content "use nix"

* First
Things to do first
#+begin_src emacs-lisp
(setq mode-line-format nil)
(setq-default mode-line-format nil)
#+end_src

* Security
#+begin_src emacs-lisp
(setq network-security-level 'high)
#+end_src

** Cert settings
#+begin_src emacs-lisp
(setq gnutls-verify-error t)
(setq tls-checktrust t)
#+end_src

** Make authinfo gpg file
#+begin_src emacs-lisp
(setq netrc-file "~/.authinfo.gpg")
(setq auth-sources '("~/.authinfo.gpg"))
#+end_src

* Package management
Bootstrap straight.el
#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
	(url-retrieve-synchronously
	 "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	 'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

* Private config
#+begin_src emacs-lisp
(defun my/load-if-exists (f)
  "load the elisp file only if it exists and is readable"
  (if (file-readable-p f)
      (load-file f)))
#+end_src

** Private config
#+begin_src emacs-lisp
(my/load-if-exists (concat user-emacs-directory "private.el"))
#+end_src

** Device config
If a device config is not made, load the default one
#+begin_src emacs-lisp
(if (not (my/load-if-exists (concat user-emacs-directory "device.el")))
    (load-file (concat user-emacs-directory "device-template.el")))
#+end_src

* Libraries
#+begin_src emacs-lisp
(straight-use-package 's)
(straight-use-package 'dash)
(straight-use-package 'ov)
(require 's)
(require 'dash)
#+end_src

** Elpatch
#+begin_src emacs-lisp
(straight-use-package 'el-patch)
#+end_src

* Persistent keys
#+begin_src emacs-lisp
(defvar my/keys-mode-map (make-sparse-keymap))
#+end_src

Emacs 27 doesn't support :init-value, :keymap, etc
(if (string< emacs-version "27")
(define-minor-mode my/keys-mode
;; init value t to enable it in fundamental mode
;; More info: http://emacs.stackexchange.com/q/16693/115
:init-value t
:keymap my/keys-mode-map)
#+begin_src emacs-lisp
(define-minor-mode my/keys-mode nil t nil my/keys-mode-map)

(add-to-list 'emulation-mode-map-alists `((my/keys-mode . ,my/keys-mode-map)))
#+end_src

* Generic functions and variables
** File management
*** Create directory if directory doesn't exist
#+begin_src emacs-lisp
(defun my/create-dir-if-not-exist (dir)
  (if (not (file-directory-p dir))
      (progn
	(make-directory dir)
	(message (concat "dir: " dir " created!")))))
#+end_src

*** Create file if file doesn't exist
#+begin_src emacs-lisp
(defun my/create-file-if-not-exist (file)
  (if (not (file-exists-p file))
      (progn
	(write-region "" nil file)
	(message (concat "Wrote file: " file " created!")))))
#+end_src

*** Create file with content if file doesn't exist
#+begin_src emacs-lisp
(defun my/create-file-with-content-if-not-exist (file content)
  (if (not (file-exists-p file))
      (progn
	(write-region content nil file)
	(message (concat "Wrote file: " file " with contents")))))
#+end_src
" created with content: " content

*** Add to content to file or create file with content if file doesn't exist
#+begin_src emacs-lisp
(defun my/add-to-or-create-file-with-content (file content)
  (write-region (concat "\n" content) nil file t)
  (message (concat "Wrote file: " file " with contents")))
#+end_src

** Is external package installed
Checks variable =exec-path= for package
#+begin_src emacs-lisp
(defun my/is-system-package-installed (package)
  (if (executable-find (symbol-name package))
      (symbol-name package)
    (message (concat "Package: " (symbol-name package) " not installed"))
    nil))
#+end_src

*** Set exec-path by system
(if (string-match-p "guixsd" (system-name))
(add-to-list 'exec-path "/bin/" ))

** Give buffer unique name
#+begin_src emacs-lisp
(defun my/give-buffer-unique-name (base-name)
  (rename-buffer base-name t))
#+end_src

** Is font installed
#+begin_src emacs-lisp
(defvar my/font-family-list (font-family-list))

(defun my/font-installed (font)
  (if (member font my/font-family-list)
      t
    nil))
#+end_src

** Fake key
*** Normal emacs buffers
Doesn't work on keys that are not english
(defun my/fake-key (key key-symbol)
 (interactive)
 (setq unread-command-events (listify-key-sequence "ö")))

#+begin_src emacs-lisp
(defun my/fake-key (key key-symbol)
  (interactive)
  (let ((command (key-binding key)))
    (setq last-command-event key-symbol)
    (setq this-command command)
    (call-interactively command)))

(defun my/fake-open-keymap (key)
  (setq unread-command-events
	(mapcar (lambda (e) `(t . ,e))
		(listify-key-sequence (kbd key)))))
#+end_src

*** Exwm
#+begin_src emacs-lisp
(defun my/exwm-fake-key (key)
  "Key is a string"
  (interactive)
  (exwm-input--fake-key
   ;; (string-to-char
   key
   ;; )
   ))
#+end_src

** Fold ellipsis
#+begin_src emacs-lisp
(defvar my/fold-ellipsis)
(defvar my/fold-ellipsis-char)

(if window-system
    (progn
      (setq my/fold-ellipsis "↴")
      (setq my/fold-ellipsis-char ?↴))
  ;; The terminal probably doesn't support unicode
  (setq my/fold-ellipsis "↓")
  (setq my/fold-ellipsis-char ?↓))
#+end_src

** File size human readable
Default file-size-human-readable returns decimal values
#+begin_src emacs-lisp
(require 'files)

(defun my/file-size-human-readable (file-size &optional flavor decimal)
  "Produce a string showing FILE-SIZE in human-readable form.

   Optional second argument FLAVOR controls the units and the display format:

    If FLAVOR is nil or omitted, each kilobyte is 1024 bytes and the produced
       suffixes are \"k\", \"M\", \"G\", \"T\", etc.
    If FLAVOR is `si', each kilobyte is 1000 bytes and the produced suffixes
       are \"k\", \"M\", \"G\", \"T\", etc.
    If FLAVOR is `iec', each kilobyte is 1024 bytes and the produced suffixes
       are \"KiB\", \"MiB\", \"GiB\", \"TiB\", etc.
    If DECIMAL is true, a decimal number is returned"
  (setq 1024Decimal (if decimal 1024.0 1024))
  (setq 1000Decimal (if decimal 1000.0 1000))

  (let ((power (if (or (null flavor) (eq flavor 'iec))
		   1024Decimal
		 1000Decimal))
	(post-fixes
	 ;; none, kilo, mega, giga, tera, peta, exa, zetta, yotta
	 (list "" "k" "M" "G" "T" "P" "E" "Z" "Y")))
    (while (and (>= file-size power) (cdr post-fixes))
      (setq file-size (/ file-size power)
	    post-fixes (cdr post-fixes)))
    (format (if (> (mod file-size 1.0) 0.05)
		"%.1f%s%s"
	      "%.0f%s%s")
	    file-size
	    (if (and (eq flavor 'iec) (string= (car post-fixes) "k"))
		"K"
	      (car post-fixes))
	    (if (eq flavor 'iec) "iB" ""))))
#+end_src

** Set font
#+begin_src emacs-lisp
(defun my/set-default-font (font)
  (if window-system
      (set-face-attribute 'default nil
			  ;;:family font
			  :font font
			  ;;:fontset "fontset-default"
			  :height my/default-face-height)))
#+end_src

** Overlay
#+begin_src emacs-lisp
(defun my/inline-overlay-print (string)
  (let ((inline-overlay (make-overlay (point) (line-end-position))))
    ;; Put overlay
    (overlay-put inline-overlay 'after-string
		 (propertize
		  (concat
		   " ;=>"
		   string
		   )
		  'face '(:foreground "light blue")
		  ))
    ;; Just sit for 100 seconds
    (sit-for 100)
    ;; Then delete overlay
    (delete-overlay inline-overlay)))
#+end_src

** Repeat char
#+begin_src emacs-lisp
(defun my/repeat-char (char initial-string n)
  (setq initial-string (concat char initial-string))
  (if (> n 1)
      (my/repeat-char char initial-string (- n 1))
    initial-string))
#+end_src

* Fonts
#+begin_src emacs-lisp
(defun my/get-best-font ()
  (if (my/font-installed "Inconsolata LGC")
      "Inconsolata LGC"
    (if (my/font-installed "Inconsolata")
	"Inconsolata"
      (if (my/font-installed "DejaVu Sans Mono")
	  "DejaVu Sans Mono"
	(if (my/font-installed "Fira Mono")
	    "Fira Mono"
	  (if (my/font-installed "dejavu sans mono")
	      "DejaVuSansMono"
	    (if (my/font-installed "Noto Sans Mono")
		"NotoSansMono"
	      (if (my/font-installed "Perfect DOS VGA 437")
		  "Perfect DOS VGA 437"))))))))

(defun my/get-best-symbol-font ()
  (if (my/font-installed "DejaVu Sans Mono")
      "DejaVu Sans Mono"
    (if (my/font-installed "dejavu sans mono")
	"DejaVuSansMono"
      (if (my/font-installed "Noto Sans Mono")
	  "NotoSansMono"))))

(setq my/font (my/get-best-font))
(setq my/symbol-font (my/get-best-symbol-font))

(when my/font
  ;; Set default font
  (add-to-list 'default-frame-alist (cons 'font my/font))

  ;;(my/set-default-font my/font)

  ;; Set symbol font
  (set-fontset-font t 'symbol my/symbol-font))
#+end_src


* Startup processes
** Prevent async command from opening new window
Buffers that I don't want popping up by default
#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
	     '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+end_src

** Check if OS is fully compatible
#+begin_src emacs-lisp
(defvar fully-compatible-system (or (eq system-type 'gnu/linux)(eq system-type 'gnu)(eq system-type 'gnu/kfreebsd)))
#+end_src

** Garbage collection
#+begin_src emacs-lisp
(setq garbage-collection-messages t)

(setq my/after-gc-mem gc-cons-threshold)
(setq gc-cons-threshold 800000000)
#+end_src

** Disable custom
Stop custom from editing init.el
#+begin_src emacs-lisp
(setq custom-file (concat user-emacs-directory ".emacs-custom.el"))
#+end_src

* Evil
#+begin_src emacs-lisp
(setq evil-search-module 'evil-search)
(setq evil-vsplit-window-right t)
(setq evil-split-window-below t)
(setq evil-shift-round nil)
#+end_src

Makes swiper A LOT faster
#+begin_src emacs-lisp
(setq evil-ex-interactive-search-highlight t)
(setq evil-ex-search-persistent-highlight nil)

(straight-use-package 'evil)
(require 'evil)
#+end_src

(fset 'evil-visual-update-x-selection 'ignore)
#+begin_src emacs-lisp
(evil-mode)
#+end_src

** Evil-goggles support
#+begin_src emacs-lisp
(straight-use-package 'evil-goggles)
(require 'evil-goggles)

(add-hook 'after-init-hook 'evil-goggles-mode)
#+end_src

Disable pulse which both fixes so that you can set foreground color on the pulse font and saves on performance
#+begin_src emacs-lisp
(setq evil-goggles-pulse nil)
(setq evil-goggles-duration 60)

(evil-goggles-use-diff-faces)
#+end_src

** Minibuffer
Enable evil in minibuffer
#+begin_src emacs-lisp
(setq evil-want-minibuffer t)
#+end_src

This fixes evil minibuffer binds
#+begin_src emacs-lisp
(add-hook 'minibuffer-setup-hook 'evil-insert-state)
#+end_src

*** Set max minibuffer height
(setq max-mini-window-height 1)

** Bind evil key functions
#+begin_src emacs-lisp
(defun my/evil-emacs-define-key (key command)
  (interactive)
  (define-key evil-emacs-state-map (kbd key) command))

(defun my/evil-insert-define-key (key command)
  (interactive)
  (define-key evil-insert-state-map (kbd key) command))

(defun my/evil-normal-define-key (key command)
  (interactive)
  (define-key evil-normal-state-map (kbd key) command)
  (define-key evil-motion-state-map (kbd key) command))

(defun my/evil-replace-define-key (key command)
  (interactive)
  (define-key evil-replace-state-map (kbd key) command))

(defun my/evil-visual-define-key (key command)
  (interactive)
  (define-key evil-visual-state-map (kbd key) command))

(defun my/evil-universal-define-key (key command)
  (interactive)
  (my/evil-insert-define-key key command)
  (my/evil-normal-define-key key command)
  (my/evil-visual-define-key key command)
  (my/evil-replace-define-key key command))
#+end_src

** Evil-multiple cursors
#+begin_src emacs-lisp
(straight-use-package 'evil-mc)
#+end_src
(straight-use-package '(evil-mc :type git :host github :repo "walseb/evil-mc"))

#+begin_src emacs-lisp
(setq evil-mc-key-map nil)

(require 'evil-mc)
#+end_src
(setq evil-mc-key-map nil)

#+begin_src emacs-lisp
(global-evil-mc-mode 1)
#+end_src
(setq evil-mc-key-map nil)

#+begin_src emacs-lisp
(add-to-list 'evil-mc-custom-known-commands
	     '(delete-char . ((:default . evil-mc-execute-default-call-with-count))))

(add-to-list 'evil-mc-custom-known-commands
	     '(org-delete-char . ((:default . evil-mc-execute-default-call-with-count))))

(add-to-list 'evil-mc-custom-known-commands
	     '(csharp-maybe-insert-codedoc . ((:default . evil-mc-execute-default-call-with-count))))
#+end_src

*** Clear default keys
#+begin_src emacs-lisp
(setq evil-mc-key-map nil)
#+end_src


*** Disable on keybord-quit (C-g)
#+begin_src emacs-lisp
(setq evil-mc-undo-cursors-on-keyboard-quit t)
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-key evil-visual-state-map "A" 'evil-mc-make-cursor-in-visual-selection-end)
(define-key evil-visual-state-map "I" 'evil-mc-make-cursor-in-visual-selection-beg)
#+end_src

** Settings
*** Disable messages in echo area
Evil spams message area
#+begin_src emacs-lisp
(setq
 evil-emacs-state-message nil
 evil-operator-state-message nil
 evil-insert-state-message nil
 evil-replace-state-message nil
 evil-motion-state-message nil
 evil-normal-state-message nil
 evil-visual-state-message nil)
#+end_src

*** Cursor states
#+begin_src emacs-lisp
(setq evil-emacs-state-cursor '("purple" box))
(setq evil-normal-state-cursor '("white" box))
(setq evil-visual-state-cursor '("yellow" box))
(setq evil-insert-state-cursor '("orange" box))
(setq evil-replace-state-cursor '("green" box))
(setq evil-operator-state-cursor '("white" hollow))
#+end_src

*** Disable emacs mode
#+begin_src emacs-lisp
(setq evil-emacs-state-modes nil)
#+end_src

*** Set which modes use which evil state by default
Example
#+begin_src emacs-lisp
(setq evil-insert-state-modes nil)


(cl-loop for (mode . state) in '(
				 ;; So i C-leader works for exwm windows
				 (exwm-mode . emacs)
				 (eshell-mode . insert)
				 (interactive-haskell-mode . insert)
				 (term-mode . insert)
				 ;;(org-agenda-mode . insert)
				 (magit-popup-mode . insert)
				 (proced-mode . insert)
				 (emms-playlist-mode . insert))
	 do (evil-set-initial-state mode state))
#+end_src

*** Switching to normal state without moving cursor
#+begin_src emacs-lisp
(defun my/evil-normal-state (&optional arg)
  (if (not(eq evil-state 'normal))
      (progn
	(evil-normal-state arg)
	(move-to-column (+ 1 (current-column))))))
#+end_src

*** Make one space enough to end work for use with evil sentence motion
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

*** Make dd and cc act on lines
#+begin_src emacs-lisp
(my/evil-normal-define-key "D" 'evil-delete-whole-line)
(my/evil-normal-define-key "C" 'evil-change-whole-line)
#+end_src

** Text objects
*** Evil-entire-buffer
Modify entire buffer - for example: "d a e"
https://github.com/supermomonga/evil-textobj-entire
#+begin_src emacs-lisp
(evil-define-text-object evil-entire-entire-buffer (count &optional beg end type)
  "Select entire buffer"
  (evil-range (point-min) (point-max)))

(define-key evil-outer-text-objects-map "e" 'evil-entire-entire-buffer)
(define-key evil-inner-text-objects-map "e" 'evil-entire-entire-buffer)
#+end_src

*** Evil-line
https://github.com/syohex/evil-textobj-line
#+begin_src emacs-lisp
(defun my/evil-line-range (count beg end type &optional inclusive)
  (if inclusive
      (evil-range (line-beginning-position) (line-end-position))
    (let ((start (save-excursion
		   (back-to-indentation)
		   (point)))
	  (end (save-excursion
		 (goto-char (line-end-position))
		 (skip-syntax-backward " " (line-beginning-position))
		 (point))))
      (evil-range start end))))

(evil-define-text-object my/evil-a-line (count &optional beg end type)
  "Select range between a character by which the command is followed."
  (my/evil-line-range count beg end type t))

(evil-define-text-object my/evil-inner-line (count &optional beg end type)
  "Select inner range between a character by which the command is followed."
  (my/evil-line-range count beg end type))

(define-key evil-outer-text-objects-map "l" 'my/evil-a-line)
(define-key evil-inner-text-objects-map "l" 'my/evil-inner-line)
#+end_src

*** Evil-indent-plus
Allows for using indention as text objects
#+begin_src emacs-lisp
(straight-use-package 'evil-indent-plus)

(define-key evil-inner-text-objects-map "i" 'evil-indent-plus-i-indent)
(define-key evil-outer-text-objects-map "i" 'evil-indent-plus-a-indent)
(define-key evil-inner-text-objects-map "I" 'evil-indent-plus-i-indent-up)
(define-key evil-outer-text-objects-map "I" 'evil-indent-plus-a-indent-up)
(define-key evil-inner-text-objects-map "C-i" 'evil-indent-plus-i-indent-up-down)
(define-key evil-outer-text-objects-map "C-i" 'evil-indent-plus-a-indent-up-down)
#+end_src

*** Evil textobject block
#+begin_src emacs-lisp
(straight-use-package 'evil-textobj-anyblock)

(define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
(define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block)
#+end_src

(define-key evil-motion-state-map "!" 'evil-textobj-anyblock-forward-open-block-start)

#+begin_src emacs-lisp
(setq evil-textobj-anyblock-blocks
      '(("(" . ")")
	("{" . "}")
	("\\[" . "\\]")
	("<" . ">")
	("\"" . "\"")
	("“" . "”")))
#+end_src

*** Evil commentary
#+begin_src emacs-lisp
(straight-use-package 'evil-commentary)

(evil-define-key 'normal evil-commentary-mode-map ":" 'evil-commentary-line)
(evil-define-key '(normal visual) evil-commentary-mode-map ";" 'evil-commentary)

(evil-define-key 'normal evil-commentary-mode-map "gY" 'evil-commentary-yank-line)
#+end_src

**** Allow commenting empty line
Because of some reason emacs crashes with undo tree error if this isn't run late
#+begin_src emacs-lisp
(add-hook 'after-init-hook
	  '(lambda ()
	     (evil-commentary-mode)

	     (evil-define-operator evil-commentary-line (beg end type)
	       "Comment or uncomment [count] lines."
	       :motion evil-line
	       :move-point nil
	       (interactive "<R>")
	       (when (evil-visual-state-p)
		 (unless (memq type '(line block))
		   (let ((range (evil-expand beg end 'line)))
		     (setq beg (evil-range-beginning range)
			   end (evil-range-end range)
			   type (evil-type range))))
		 (evil-exit-visual-state))
	       ;; If current line is blank
	       (if (save-excursion
		     (beginning-of-line)
		     (looking-at "[[:space:]]*$"))
		   (insert comment-start)
		 (evil-commentary beg end type)))))
#+end_src

*** Evil-eval operator
#+begin_src emacs-lisp
(evil-define-operator evil-eval (beg end type)
  "Run eval on BEG to END."
  (interactive "<R>")
  (message (concat "beg: " (number-to-string beg) " end: " (number-to-string end)))
  (my/auto-eval-region beg end))

(my/evil-normal-define-key "/" 'evil-eval)
(my/evil-normal-define-key "?" 'my/auto-eval)
#+end_src

**** Add evil-goggle command
#+begin_src emacs-lisp
(add-to-list 'evil-goggles--commands '(evil-eval :face evil-goggles-yank-face :switch evil-goggles-enable-yank :advice evil-goggles--generic-async-advice))
#+end_src

*** Evil-surround
#+begin_src emacs-lisp
(straight-use-package 'evil-surround)
(global-evil-surround-mode 1)
#+end_src

*** Evil-args
#+begin_src emacs-lisp
(straight-use-package 'evil-args)
#+end_src

bind evil-args text objects
#+begin_src emacs-lisp
(define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
(define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
#+end_src

** Evil-lion
#+begin_src emacs-lisp
(straight-use-package 'evil-lion)
(evil-lion-mode)
#+end_src

** Match paren
The normal evil-jump-item gives up easily. This tries to get to a paren more
#+begin_src emacs-lisp
(defun my/match-paren ()
  (interactive)
  (when (not (ignore-errors (call-interactively #'evil-jump-item)))
    (backward-up-list)))

(my/evil-normal-define-key "%" 'my/match-paren)
#+end_src

** Goto end of line
By default evil goes to the last line, first char. This goes to the very last char in the buffer
#+begin_src emacs-lisp
(evil-define-motion evil-goto-line (count)
  "Go to the first non-blank character of line COUNT.
   By default the last line."
  :jump t
  :type line
  (if (null count)
      (with-no-warnings (end-of-buffer))
    (goto-char (point-min))
    (forward-line (1- count)))
  (end-of-line))
#+end_src

** Fix evil scroll
https://github.com/emacs-evil/evil/pull/1154/files
#+begin_src emacs-lisp
(evil-define-command evil-scroll-up (count)
  "Scrolls the window and the cursor COUNT lines upwards.
If COUNT is not specified the function scrolls down
`evil-scroll-count', which is the last used count.
If the scroll count is zero the command scrolls half the screen."
  :repeat nil
  :keep-visual t
  (interactive "<c>")
  (evil-save-column
    (setq count (or count (max 0 evil-scroll-count)))
    (setq evil-scroll-count count)
    (when (= (point-min) (line-beginning-position))
      (signal 'beginning-of-buffer nil))
    (when (zerop count)
      (setq count (/ (window-body-height) 2)))
    (let ((xy (evil-posn-x-y (posn-at-point))))
      (condition-case nil
	  (progn
	    (scroll-down count)
	    (goto-char (posn-point (posn-at-x-y (car xy) (cdr xy)))))
	(beginning-of-buffer
	 (condition-case nil
	     (with-no-warnings (previous-line count))
	   (beginning-of-buffer)))))))

(evil-define-command evil-scroll-down (count)
  "Scrolls the window and the cursor COUNT lines downwards.
If COUNT is not specified the function scrolls down
`evil-scroll-count', which is the last used count.
If the scroll count is zero the command scrolls half the screen."
  :repeat nil
  :keep-visual t
  (interactive "<c>")
  (evil-save-column
    (setq count (or count (max 0 evil-scroll-count)))
    (setq evil-scroll-count count)
    (when (eobp) (signal 'end-of-buffer nil))
    (when (zerop count)
      (setq count (/ (window-body-height) 2)))
    ;; BUG #660: First check whether the eob is visible.
    ;; In that case we do not scroll but merely move point.
    (if (<= (point-max) (window-end))
	(with-no-warnings (next-line count nil))
      (let ((xy (evil-posn-x-y (posn-at-point))))
	(condition-case nil
	    (progn
	      (scroll-up count)
	      (let* ((wend (window-end nil t))
		     (p (posn-at-x-y (car xy) (cdr xy)))
		     (margin (max 0 (- scroll-margin
				       (cdr (posn-col-row p))))))
		(goto-char (posn-point p))
		;; ensure point is not within the scroll-margin
		(when (> margin 0)
		  (with-no-warnings (next-line margin))
		  (recenter scroll-margin))
		(when (<= (point-max) wend)
		  (save-excursion
		    (goto-char (point-max))
		    (recenter (- (max 1 scroll-margin)))))))
	  (end-of-buffer
	   (goto-char (point-max))
	   (recenter (- (max 1 scroll-margin)))))))))

(defvar evil-cached-header-line-height nil
  "Cached height of the header line.")

(defun evil-header-line-height ()
  "Return the height of the header line.
If there is no header line, return nil."
  (let ((posn (posn-at-x-y 0 0)))
    (when (eq (posn-area posn) 'header-line)
      (cdr (posn-object-width-height posn)))))

(defun evil-posn-x-y (position)
  "Return the x and y coordinates in POSITION.
This function returns y offset from the top of the buffer area including
the header line.  This definition could be changed in future.
Note: On Emacs 22 and 23, y offset, returned by `posn-at-point' and taken
by `posn-at-x-y', is relative to the top of the buffer area including
the header line.
However, on Emacs 24, y offset returned by `posn-at-point' is relative to
the text area excluding the header line, while y offset taken by
`posn-at-x-y' is relative to the buffer area including the header line.
This asymmetry is by design according to GNU Emacs team.
This function fixes the asymmetry between them on Emacs 24 and later versions.
Borrowed from mozc.el."
  (let ((xy (posn-x-y position)))
    (when (and (> emacs-major-version 24) header-line-format)
      (setcdr xy (+ (cdr xy)
		    (or evil-cached-header-line-height
			(setq evil-cached-header-line-height (evil-header-line-height))
			0))))
    xy))
#+end_src

** Fix evil open line
#+begin_src emacs-lisp
(setq evil-auto-indent nil)
#+end_src

** Keys
Prevent emacs state from being exited with esc, fixes exwm since it uses emacs state and to exit hydra you have to do esc
#+begin_src emacs-lisp
(define-key evil-emacs-state-map (kbd "<escape>") 'keyboard-quit)
#+end_src

Couldn't bother to create custom evil-join
P is normally bound to manual, make this key useful
#+begin_src emacs-lisp
(my/evil-normal-define-key "P" 'delete-indentation)
#+end_src

*** Rebind evil case change
#+begin_src emacs-lisp
(my/evil-normal-define-key "g u" 'evil-downcase)
(my/evil-normal-define-key "g U" 'evil-upcase)
#+end_src

*** RET in normal mode should insert enter
#+begin_src emacs-lisp
(my/evil-normal-define-key "RET" #'newline)
#+end_src

*** Add perspective movement to g
#+begin_src emacs-lisp
(my/evil-normal-define-key "gb" 'evil-scroll-line-to-bottom)
(my/evil-normal-define-key "gf" 'evil-scroll-line-to-top)
(my/evil-normal-define-key "ge" 'evil-scroll-line-to-center)
#+end_src
(my/evil-normal-define-key "/" 'evil-scroll-line-to-center)

*** Don't complete from all buffers
#+begin_src emacs-lisp
(setq evil-complete-all-buffers nil)
#+end_src

*** Don't add pasted over thing to killring
#+begin_src emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+end_src

*** Go down visual line with M-p, M-n
#+begin_src emacs-lisp
(my/evil-universal-define-key "M-n" #'evil-next-visual-line)
(my/evil-universal-define-key "M-p" #'evil-previous-visual-line)
#+end_src

*** Move by paragraph easier, switch with evil-replace
#+begin_src emacs-lisp
(my/evil-normal-define-key "r" 'evil-forward-paragraph)
(my/evil-visual-define-key "r" 'evil-forward-paragraph)
(my/evil-normal-define-key "R" 'evil-backward-paragraph)
(my/evil-visual-define-key "R" 'evil-backward-paragraph)

(my/evil-normal-define-key "j" 'evil-replace)
(my/evil-visual-define-key "j" 'evil-replace)
(my/evil-normal-define-key "J" 'evil-replace-state)
(my/evil-visual-define-key "J" 'evil-replace-state)
#+end_src

*** Don't save chars deleted with x to clipboard
#+begin_src emacs-lisp
(my/evil-normal-define-key "x" 'delete-char)
(my/evil-normal-define-key "X"
			   '(lambda () (interactive)
			      (backward-char)
			      (call-interactively #'delete-char)))
#+end_src

* Leader
When changing leader, change =my/leader-map-key=
#+begin_src emacs-lisp
(define-prefix-command 'my/leader-map)

(defvar my/leader-map-key "SPC")
(defvar my/mod-leader-map-key "C-SPC")

(defvar my/window-leader-key "C-=")
(defvar my/mod-window-leader-key "M-C-=")

(my/evil-normal-define-key "U" 'undo-tree-visualize)

(my/evil-normal-define-key my/leader-map-key my/leader-map)
(my/evil-visual-define-key my/leader-map-key my/leader-map)

(my/evil-universal-define-key my/mod-leader-map-key my/leader-map)
#+end_src

* Alert
#+begin_src emacs-lisp
(defvar my/past-alerts (list))

(defun my/alert (&optional str severity flash-once)
  (let ((color
	 (pcase severity
	   ('low "green")
	   ('med  "yellow")
	   ('high  "red")
	   (_   "blue"))))

    (if flash-once
	(my/alert-blink-fringe-once color)
      (my/alert-blink-fringe color))

    (if str
	(progn
	  (push " " my/past-alerts)
	  (push (propertize (concat "[" str "]") 'face `(:background ,color)) my/past-alerts)
	  (message str)))))

(defvar my/alert-blink-fringe-color "red")

(defun my/alert-blink-fringe-once (color)
  (setq my/alert-blink-fringe-color color)
  (my/alert-fringe-set-color)
  (run-with-timer 0.25 nil 'my/alert-fringe-restore))

(defun my/alert-blink-fringe (color)
  (setq my/alert-blink-fringe-color color)
  (my/alert-fringe-set-color)
  (run-with-timer 0.25 nil 'my/alert-fringe-restore)
  (run-with-timer 0.5 nil 'my/alert-fringe-set-color)
  (run-with-timer 0.75 nil 'my/alert-fringe-restore)
  (run-with-timer 1.0 nil 'my/alert-fringe-set-color)
  (run-with-timer 1.25 nil 'my/alert-fringe-restore))

(defun my/alert-fringe-set-color ()
  (set-face-attribute 'fringe nil :foreground my/alert-blink-fringe-color :background my/alert-blink-fringe-color))

(defun my/alert-fringe-restore ()
  (set-face-attribute 'fringe nil :foreground nil :background nil))

(defun my/alert-reset ()
  (interactive)
  (setq my/past-alerts (list))
  (my/lv-line-update))

(defun my/alert-remove ()
  (interactive)
  (setq my/past-alerts (remove (completing-read "Remove entry" my/past-alerts) my/past-alerts))
  (my/lv-line-update))
#+end_src

* Package management
** Guix
#+begin_src emacs-lisp
(straight-use-package 'guix)
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/guix-map)
(define-key my/leader-map (kbd "G") 'my/guix-map)

(define-key my/guix-map (kbd "v") 'guix)
(define-key my/guix-map (kbd "P") 'guix-profiles)
(define-key my/guix-map (kbd "g") 'guix-generation)
(define-key my/guix-map (kbd "G") 'guix-system-generations)
(define-key my/guix-map (kbd "i") 'guix-installed-user-packages)
(define-key my/guix-map (kbd "I") 'guix-installed-system-packages)

(define-prefix-command 'my/guix-services-map)
(define-key my/guix-map (kbd "s") 'my/guix-services-map)

(define-key my/guix-services-map (kbd "a") 'guix-all-services)
(define-key my/guix-services-map (kbd "n") 'guix-services-by-name)
(define-key my/guix-services-map (kbd "l") 'guix-services-by-location)
(define-key my/guix-services-map (kbd "d") 'guix-find-service-definition)

(define-prefix-command 'my/guix-package-map)
(define-key my/guix-map (kbd "p") 'my/guix-package-map)

(define-key my/guix-package-map (kbd "a") 'guix-all-packages)
(define-key my/guix-package-map (kbd "n") 'guix-packages-by-name)
(define-key my/guix-package-map (kbd "l") 'guix-packages-by-location)
(define-key my/guix-package-map (kbd "c") 'guix-packages-from-system-config-file)
(define-key my/guix-package-map (kbd "d") 'guix-find-package-definition)

(define-prefix-command 'my/guix-store-map)
(define-key my/guix-map (kbd "S") 'my/guix-store-map)

(define-key my/guix-store-map (kbd "l") 'guix-store-live-items)
(define-key my/guix-store-map (kbd "d") 'guix-store-dead-items)
(define-key my/guix-store-map (kbd "D") 'guix-store-item-derivers)
(define-key my/guix-store-map (kbd "f") 'guix-store-failures)
(define-key my/guix-store-map (kbd "r") 'guix-store-item-references)
(define-key my/guix-store-map (kbd "R") 'guix-store-item-referrers)
(define-key my/guix-store-map (kbd "C-r") 'guix-store-item-requisites)
#+end_src

** Local packages
#+begin_src emacs-lisp
(add-to-list 'load-path (expand-file-name (concat user-emacs-directory "local-packages")))
#+end_src

* Write configs
#+begin_src emacs-lisp
(defun my/write-configs ()
  (interactive)
  (pcase (completing-read "Which config to write: "
			  '("xdefaults" "xinit" "xmodmap" "mpd" "gpg-agent" "cabal" "mbsync" "msmtp" "dovecot") nil t)
    ("xdefaults" (my/write-xdefaults))
    ("xinit" (my/write-xinitrc))
    ("xmodmap" (my/write-xmodmap))
    ("mpd" (my/write-mpd-config))
    ("gpg-agent" (my/write-gpg-agent-config))
    ("cabal" (my/write-cabal-config))
    ("mbsync" (my/write-mbsync-config))
    ("msmtp" (my/write-msmtp-config))
    ("dovecot" (my/write-dovecot-config))))

(define-key my/leader-map (kbd "C-c") 'my/write-configs)
#+end_src

** Write .gnus.el
I thinks this is no longer needed
Create =.gnus.el=, which gnus reads from
#+begin_src emacs-lisp
(defconst my/gnus-config-text "
   AddYourEmailHereThenDeleteThis
   (setq mail-host-address \"MyAdress\")
   ")

(defun my/write-gnus ()
  (my/create-file-with-content-if-not-exist
   "~/.gnus.el" my/gnus-config-text))
#+end_src

** Write .Xdefaults
emacs. commands to disable scrollbar, etc before launching emacs, improving startup time
#+begin_src emacs-lisp
(defconst my/xdefaults-config-text "
   emacs.toolBar: 0
   emacs.menuBar: 0
   emacs.verticalScrollBars: off")

(defun my/write-xdefaults ()
  (my/create-file-with-content-if-not-exist "~/.Xdefaults" my/xdefaults-config-text))
#+end_src

** Write .xinitrc
=xset s= disables screen saver
setxkbmap to select keyboard layout

#+begin_src emacs-lisp
(defconst my/xinit-config-text "
   xset s off
   xset s noblank
   xset s off
   xset s off -dpms

   setxkbmap -layout us -variant altgr-intl
   # setxkbmap -layout carpalx -variant qgmlwy

   # xmodmap ~./xmodmap

   # Fix java windows in exwm
   export _JAVA_AWT_WM_NONREPARENTING=1

   exec emacs")

(defun my/write-xinitrc ()
  (my/create-file-with-content-if-not-exist "~/.xinitrc" my/xinit-config-text))
#+end_src

** Write .xmodmap
This swaps capslock and ctrl
#+begin_src emacs-lisp
(defconst my/xmodmap-config-text "
   ! Swap Caps_Lock and Control_L
   remove Lock = Caps_Lock
   remove Control = Control_L
   keysym Control_L = Caps_Lock
   keysym Caps_Lock = Control_L
   add Lock = Caps_Lock
   add Control = Control_L
   ")

(defun my/write-xmodmap ()
  (my/create-file-with-content-if-not-exist "~/.xmodmap" my/xmodmap-config-text))
#+end_src

** Write mpd
#+begin_src emacs-lisp
(defconst my/mpd-config-text "
   music_directory \"~/Music\"
   playlist_directory  \"~/.config/mpd/playlists\"
   db_file \"~/.config/mpd/mpd.db\"
   log_file \"~/.config/mpd/mpd.log\"
   bind_to_address \"127.0.0.1\"
   port \"6600\"

   # For pulse audio
   audio_output {
   type \"pulse\"
   name \"pulse audio\"
   }")

(defun my/write-mpd-config ()
  (let* ((config-dir "~/.config/")
	 (mpd-dir (concat config-dir "mpd/"))
	 (mpd-config (concat mpd-dir "mpd.conf")))
    (my/create-dir-if-not-exist config-dir)

    (my/create-dir-if-not-exist mpd-dir)

    (my/create-file-with-content-if-not-exist mpd-config my/mpd-config-text)

    (my/create-file-if-not-exist (concat mpd-dir "mpd.log"))
    (my/create-file-if-not-exist (concat mpd-dir "mpd.db"))
    (my/create-dir-if-not-exist (concat mpd-dir "playlists/"))))
#+end_src

** Write GPG pinentry
#+begin_src emacs-lisp
(defun my/write-gpg-agent-config ()
  (let* ((gpg-dir "~/.gnupg/")
	 (gpg-file (concat gpg-dir "gpg-agent.conf")))
    (my/create-dir-if-not-exist gpg-dir)
    (my/create-file-with-content-if-not-exist gpg-file "allow-emacs-pinentry")
    (shell-command "gpgconf --reload gpg-agent")))
#+end_src

** Write cabal config
#+begin_src emacs-lisp
(defconst my/nix-config-text "nix: true
   documentation: True")

(defun my/write-cabal-config ()
  (let* ((cabal-dir "~/.cabal/")
	 (cabal-file (concat cabal-dir "config")))
    (my/create-dir-if-not-exist cabal-dir)
    (my/create-file-with-content-if-not-exist cabal-file my/nix-config-text)))
#+end_src

** Write mail configs
#+begin_src emacs-lisp
(defun my/write-mail-configs ()
  (interactive)
  (my/write-mbsync-config)
  (my/write-msmtp-config)
  (my/write-dovecot-config))

(defun my/write-mbsync-config ()
  (let* ((source-dir (concat user-emacs-directory "configs/mail/mbsync/.mbsyncrc"))
	 (target-dir "~/.mbsyncrc"))
    (copy-file source-dir target-dir))
  (make-directory "~/Maildir")
  (make-directory "~/Maildir/main-gmail"))

(defun my/write-msmtp-config ()
  (let* ((source-dir (concat user-emacs-directory "configs/mail/msmtp/.msmtprc"))
	 (target-dir "~/.msmtprc"))
    (copy-file source-dir target-dir)))

(defun my/write-dovecot-config ()
  (let ((config-dir  "~/.dovecot-pass"))
    (my/create-file-with-content-if-not-exist config-dir "admin:{PLAIN}")))
#+end_src

* Minor
** Startup
Disable startup message
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(setq inhibit-startup-echo-area-message t)
#+end_src

** Scratch buffer
*** Disable scratch buffer on startup
We need to do this because the scratch buffer created by emacs is temporary, the one in this config is a file
(kill-buffer "*scratch*")

*** Disable initial scratch buffer message
#+begin_src emacs-lisp
(setq initial-scratch-message nil)
#+end_src

*** Set default mode
#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
#+end_src

** Encoding
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

** Line wrapping
*** Enable truncate lines mode
#+begin_src emacs-lisp
(setq-default truncate-lines nil)
(setq truncate-lines nil)
#+end_src

Always truncate lines
#+begin_src emacs-lisp
(setq truncate-partial-width-windows nil)
(setq-default truncate-partial-width-windows nil)
#+end_src

**** Toggle truncate lines
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "C-v")
  '(lambda () (interactive)
     (setq truncate-lines (not truncate-lines))))
#+end_src

** Visual line mode
#+begin_src emacs-lisp
(global-visual-line-mode 1)
#+end_src

*** Fringe indicators of wrapped line
#+begin_src emacs-lisp
(setq visual-line-fringe-indicators '(right-triangle nil))
#+end_src

** Disable useless functionallity
#+begin_src emacs-lisp
(tooltip-mode -1)
#+end_src

** 1 letter prompts
Convert yes or no prompt to y or n prompt
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Smooth scroll
Scroll 1 line at a time when cursor goes outside screen
#+begin_src emacs-lisp
(setq scroll-conservatively 100)
#+end_src

** Bell
Disable bell
#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

** Subword (camel case movement)
#+begin_src emacs-lisp
(global-subword-mode 1)
#+end_src

** Change max killring size
#+begin_src emacs-lisp
(setq kill-ring-max 500)
#+end_src

** Pixel scroll mode
In org mode when displaying images pixel scroll mode can be useful maybe
(add-hook 'org-mode-hook 'pixel-scroll-mode)

** Increase and decrease brightness
#+begin_src emacs-lisp
(defun my/increase-brightness ()
  (interactive)
  (shell-command "xbacklight +5"))

(defun my/decrease-brightness ()
  (interactive)
  (shell-command "xbacklight -5"))

(global-set-key (kbd "<XF86MonBrightnessUp>") 'my/increase-brightness)
(global-set-key (kbd "<XF86MonBrightnessDown>") 'my/decrease-brightness)
#+end_src

** Update packages
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "C-u") 'list-packages)
#+end_src

** Sudo edit
#+begin_src emacs-lisp
(straight-use-package 'sudo-edit)

(define-key my/leader-map (kbd "C-S-s") 'sudo-edit)
#+end_src

*** Dired fix
#+begin_src emacs-lisp
(defun my/sudo-edit-is-on ()
  (string-equal
   (file-remote-p (or buffer-file-name default-directory) 'user)
   "root"))

(defun my/dired-sudo-edit-setup ()
  ;; If file is edited with sudo (in this case only works on dired due to hook)
  (if (my/sudo-edit-is-on)
      (dired-sort-other "-alh")))

(add-hook 'dired-mode-hook 'my/dired-sudo-edit-setup)
#+end_src

** Enable disabled commands
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'narrow-to-defun 'disabled nil)
#+end_src

** Async
#+begin_src emacs-lisp
(straight-use-package 'async)

(require 'async)
(require 'dired-async)
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode 1)
#+end_src

** Zoom
(defun my/increase-volume ()
(interactive)
(text-scale-set 0))
(define-key my/leader-map (kbd "+") ')
(define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-set 0)))

#+begin_src emacs-lisp
(define-key my/leader-map (kbd "-") '(lambda () (interactive) (text-scale-decrease 4)))
(define-key my/leader-map (kbd "=") '(lambda () (interactive) (text-scale-increase 4)))

(define-key my/leader-map (kbd "C--") '(lambda () (interactive) (text-scale-decrease 1)))
(define-key my/leader-map (kbd "C-=") '(lambda () (interactive) (text-scale-increase 1)))


(define-key my/leader-map (kbd "+") '(lambda () (interactive) (text-scale-mode 0)))
(define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-mode 0)))
#+end_src

** Exit emacs
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "C-z") 'save-buffers-kill-emacs)
#+end_src

** Help mode
#+begin_src emacs-lisp
(setq help-mode-map
      (let ((map (make-sparse-keymap)))
	(define-key map "C-h" 'help-go-back)
	(define-key map "c-l" 'help-go-forward)
	map))

(advice-add 'help-mode :after (lambda () (interactive) (evil-force-normal-state)))
#+end_src

** Compilation mode
#+begin_src emacs-lisp
(setq compilation-mode-map (make-sparse-keymap))
(setq-default compilation-mode-map (make-sparse-keymap))

(setq compilation-minor-mode-map (make-sparse-keymap))
(setq-default compilation-minor-mode-map (make-sparse-keymap))

(setq compilation-shell-minor-mode-map (make-sparse-keymap))
(setq-default compilation-shell-minor-mode-map (make-sparse-keymap))

(setq compilation-mode-tool-bar-map (make-sparse-keymap))
(setq-default compilation-mode-tool-bar-map (make-sparse-keymap))

(advice-add 'compilation-mode :after (lambda () (interactive) (evil-force-normal-state)))
#+end_src

** Prefer loading newest lisp source file
#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

** Revert buffer bind
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "r") 'revert-buffer)
#+end_src

** Hotkey to hide cursor
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "M-h") (lambda () (interactive) (setq cursor-type nil)))
#+end_src

** Tetris
#+begin_src emacs-lisp
(evil-define-key 'insert tetris-mode-map (kbd "p") #'tetris-rotate-next)
(evil-define-key 'insert tetris-mode-map (kbd "P") #'tetris-rotate-prev)
(evil-define-key 'insert tetris-mode-map (kbd "n") #'tetris-move-down)
(evil-define-key 'insert tetris-mode-map (kbd "N") #'tetris-move-bottom)
(evil-define-key 'insert tetris-mode-map (kbd "h") #'tetris-move-left)
(evil-define-key 'insert tetris-mode-map (kbd "l") #'tetris-move-right)

(evil-define-key 'insert tetris-mode-map (kbd "SPC") #'tetris-move-bottom)
#+end_src

** Redefine keyboard-escape-quit
#+begin_src emacs-lisp
(defun keyboard-escape-quit ()
  "Exit the current \"mode\" (in a generalized sense of the word).
   This command can exit an interactive command such as `query-replace',
   can clear out a prefix argument or a region,
   can get out of the minibuffer or other recursive edit,
   cancel the use of the current buffer (for special-purpose buffers),
   or go back to just one window (by deleting all but the selected window)."
  (interactive)
  (cond ((eq last-command 'mode-exited) nil)
	((region-active-p)
	 (deactivate-mark))
	((> (minibuffer-depth) 0)
	 (abort-recursive-edit))
	(current-prefix-arg
	 nil)
	((> (recursion-depth) 0)
	 (exit-recursive-edit))
	(buffer-quit-function
	 (funcall buffer-quit-function))))
#+end_src

** lisp-ls
ls for systems without ls installed (like windows). Gets used automatically on those systems
#+begin_src emacs-lisp
(setq-default ls-lisp-format-time-list  '("%d-%m-%Y %H:%M" "%d-%m-%Y %H:%M")
	      ls-lisp-use-localized-time-format t)
#+end_src

** Fix backward-sexp
#+begin_src emacs-lisp
(defun my/backward-sexp (&optional arg)
  "Fixed backward sexp so you don't have to place cursor 1 char in front of paren you want to go backward on"
  (interactive "^p")
  (or arg (setq arg 1))
  (my/forward-sexp (- arg) 1))

(defun my/forward-sexp (&optional arg extra-move)
  (interactive "^p")
  (or arg (setq arg 1))
  (if forward-sexp-function
      (funcall forward-sexp-function arg)
    (goto-char (or (scan-sexps (+ (point) extra-move) arg) (buffer-end arg)))
    (if (< arg 0) (backward-prefix-chars))))
#+end_src

** Switch to last buffer
#+begin_src emacs-lisp
(defun my/switch-to-last-buffer ()
  (interactive)
  (switch-to-buffer (car (cdr (ivy--buffer-list "")))))
#+end_src

** Echo keypresses instantly
#+begin_src emacs-lisp
(setq echo-keystrokes 0.01)
#+end_src

** Configure mouse
#+begin_src emacs-lisp
(define-key minibuffer-inactive-mode-map [mouse-1] #'ignore)
#+end_src

*** Disable middleclick and right click
#+begin_src emacs-lisp
(define-key global-map [mouse-2] #'ignore)
(my/evil-universal-define-key "<mouse-2>" #'ignore)

(define-key global-map [mouse-3] #'ignore)
#+end_src

*** Disable mouse wheel acceleration
#+begin_src emacs-lisp
(setq mouse-wheel-progressive-speed nil)
#+end_src

** Minibuffer-depth
Enable and show minibuffer recursive depth
#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
(minibuffer-depth-indicate-mode 1)
#+end_src

** Clone indirect buffer name
*** Clone indirect buffer this window
#+begin_src emacs-lisp
(defun my/clone-indirect-buffer ()
  (interactive)
  (when (not (string= major-mode 'exwm-mode))
    (clone-indirect-buffer
     (concat
      "I: "
      (buffer-name)
      )
     t)))
#+end_src

*** Clone indirect buffer other window
#+begin_src emacs-lisp
(defun my/clone-indirect-buffer-other-window ()
  (interactive)
  (when (not (string= major-mode 'exwm-mode))
    (clone-indirect-buffer-other-window
     (concat
      "I: "
      (buffer-name)
      )
     t
     )))
#+end_src

** Build config
#+begin_src emacs-lisp
(defun my/build-config-docs ()
  (interactive)
  (my/config-visit)
  (my/outorg-export-to-org-file "~/.emacs.d/readme.org"))
#+end_src

** Man mode
*** Disable keys
#+begin_src emacs-lisp
(setq Man-mode-map (make-sparse-keymap))
#+end_src

** Timer
Set timer to only run expired repeating hooks once after sleep
#+begin_src emacs-lisp
(setq timer-max-repeats 1)
#+end_src

** Auto kill buffer
#+begin_src emacs-lisp
(defun my/auto-kill-buffer ()
  (interactive)
  (pcase major-mode
    ('gnus-summary-mode (gnus-summary-exit))
    (_ (kill-current-buffer))))
#+end_src

* File options
#+begin_src emacs-lisp
(define-prefix-command 'my/file-options-map)
(define-key my/leader-map (kbd "`") 'my/file-options-map)
#+end_src

** Revert
#+begin_src emacs-lisp
(define-key my/file-options-map (kbd "r") 'revert-buffer)
#+end_src

** Statistics
#+begin_src emacs-lisp
(define-prefix-command 'my/statistics-map)
(define-key my/file-options-map (kbd "s") 'my/statistics-map)

(define-key my/statistics-map (kbd "w") 'count-words)
(define-key my/statistics-map (kbd "r") 'count-words-region)
#+end_src

** Indentation
#+begin_src emacs-lisp
(define-prefix-command 'my/indentation-map)
(define-key my/file-options-map (kbd "i") 'my/indentation-map)

(defun my/change-tab-width ()
  (interactive)
  (setq-default tab-width (string-to-number (completing-read "Enter tab width" nil))))
#+end_src

Applies only to region
#+begin_src emacs-lisp
(define-key my/indentation-map (kbd "t") 'tabify)
(define-key my/indentation-map (kbd "SPC") 'untabify)

(define-key my/indentation-map (kbd "w") 'my/change-tab-width)
#+end_src

* Open
#+begin_src emacs-lisp
(define-prefix-command 'my/open-map)
(define-key my/leader-map (kbd "o") 'my/open-map)

(defvar my/open-map-hook nil
  "Hook called after a buffer is visited through my/open-map")
#+end_src

** Scratch
Kill the initial scratch buffer
#+begin_src emacs-lisp
(kill-buffer "*scratch*")

(defun my/switch-to-scratch()
  (interactive)
  (let ((scratch-buffer (get-buffer "*scratch*")))
    (if scratch-buffer
	(switch-to-buffer scratch-buffer)
      (switch-to-buffer "*scratch*")
      (when (not (file-exists-p (concat user-emacs-directory "scratch")))
	(write-region "" nil (concat user-emacs-directory "scratch")))
      (insert-file-contents (concat user-emacs-directory "scratch"))
      ;; This generates a new mode map and uses it. This makes it possible to modify the current mode map without modifying the org mode map.
      (org-mode)
      (use-local-map (copy-keymap org-mode-map))
      (local-set-key [remap my/save-and-backup-buffer] '(lambda () (interactive)
							  ;; Using write-region instead of write-file here makes it so that the scratch buffer doesn't get assigned to a file, which means it can be used without any problems in a direnv buffer
							  (save-restriction
							    (widen)
							    (write-region (point-min) (point-max) (concat user-emacs-directory "scratch")))))))
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "s") 'my/switch-to-scratch)
#+end_src

** Backup
#+begin_src emacs-lisp
(defun my/backups-visit ()
  (interactive)
  (find-file (expand-file-name (concat user-emacs-directory "backups")))
  (run-hooks 'my/open-map-hook))

(defun my/backups-per-session-visit ()
  (interactive)
  (find-file (expand-file-name (concat user-emacs-directory "backups/per-session")))
  (run-hooks 'my/open-map-hook))


(define-key my/open-map (kbd "b") 'my/backups-per-session-visit)
(define-key my/open-map (kbd "B") 'my/backups-visit)
#+end_src

** Visit nixos config
#+begin_src emacs-lisp
(defun my/nixos-config-visit ()
  (interactive)
  (find-file "/etc/nixos/configuration.nix")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "N") 'my/nixos-config-visit)
#+end_src

** Visit notes
#+begin_src emacs-lisp
(defun my/nixos-notes-visit ()
  (interactive)
  (find-file "~/Notes/")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "n") 'my/nixos-notes-visit)
#+end_src

** Visit config
#+begin_src emacs-lisp
(defun my/config-visit ()
  (interactive)
  (find-file (expand-file-name (concat user-emacs-directory "config.el")))
  ;; Emacs lags if flycheck runs on config
  (flycheck-mode -1)
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "c") 'my/config-visit)
#+end_src

** Reload config
#+begin_src emacs-lisp
(defun my/config-reload ()
  (interactive)
  (org-babel-load-file (expand-file-name (concat user-emacs-directory "config.org")))
  (run-hooks 'my/open-map-hook))
(define-key my/open-map (kbd "C-r") 'my/config-reload)
#+end_src


** Open trash
#+begin_src emacs-lisp
(defun my/trash-visit ()
  (interactive)
  (find-file "~/.local/share/Trash/files/")
  (run-hooks 'my/open-map-hook))
(define-key my/open-map (kbd "t") 'my/trash-visit)
#+end_src


** Open agenda
#+begin_src emacs-lisp
(defun my/org-agenda-show-agenda-and-todo (&optional arg)
  (interactive "P")
  (org-agenda arg "a")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "a") 'my/org-agenda-show-agenda-and-todo)
#+end_src

** Open messages
#+begin_src emacs-lisp
(defun my/open-messages ()
  (interactive)
  (switch-to-buffer "*Messages*")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "m") 'my/open-messages)
#+end_src

** Open downloads
#+begin_src emacs-lisp
(defun my/open-downloads ()
  (interactive)
  (find-file "~/Downloads")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "d") 'my/open-downloads)
#+end_src

** Open home
#+begin_src emacs-lisp
(defun my/open-home ()
  (interactive)
  (find-file "~")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "r") 'my/open-home)
#+end_src

** Open password file
#+begin_src emacs-lisp
(defun my/open-passwords ()
  (interactive)
  (find-file espy-password-file)
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "p") 'my/open-passwords)
#+end_src

** Visit agenda file
#+begin_src emacs-lisp
(defun my/agenda-file-visit ()
  (interactive)
  (find-file "~/Notes/Agenda.org")
  (run-hooks 'my/open-map-hook))

(define-key my/open-map (kbd "A") 'my/agenda-file-visit)
#+end_src

** Open firefox
#+begin_src emacs-lisp
(defvar my/gui-browser
  (if (my/is-system-package-installed 'icecat)
      "icecat"
    (if (my/is-system-package-installed 'firefox-nightly)
	"firefox-nightly"
      (if (my/is-system-package-installed 'iceweasel)
	  "iceweasel"
	"firefox"))))

(defvar my/browser-bookmarks '(
			       "youtube.com"
			       "discordapp.com/channels/@me"
			       "github.com"
			       "steamcommunity.com/chat"
			       ))
(defun my/launch-firefox ()
  (interactive)
  (start-process my/gui-browser nil my/gui-browser "--new-window"))
#+end_src

(defun my/launch-firefox ()
  (interactive)
  (let* (
         (search (completing-read "url " my/browser-bookmarks))
         (adress
          (if (cl-member search my/browser-bookmarks :test #'string=)
              search
            (concat "https://www.google.com/search?q=" search))))
    (start-process (concat my/gui-browser my/temp-firefox-title-name) nil my/gui-browser "--new-window" adress)))

#+begin_src emacs-lisp
(define-key my/leader-map (kbd "C-b") 'my/launch-firefox)
#+end_src

** Open eww
#+begin_src emacs-lisp
(defun my/launch-eww ()
  (interactive)
  (eww-browse-url (my/get-search-url) t))

(when (not my/use-w3m)
  (define-key my/leader-map (kbd "b") 'my/launch-eww))
#+end_src

** Suggest
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "s") 'suggest)
#+end_src

* Org
#+begin_src emacs-lisp
(straight-use-package 'org)
(require 'org)
(require 'org-agenda)
#+end_src

Set org src indent to be 0
#+begin_src emacs-lisp
(setq org-edit-src-content-indentation 0)

(define-prefix-command 'my/org-mode-map)
(evil-define-key 'normal org-mode-map (kbd (concat my/leader-map-key " a")) #'my/org-mode-map)
#+end_src

** Babel
*** Supported runnable languages
  ;; (org-babel-do-load-languages
   ;; 'org-babel-load-languages
   ;; '((R . t)
     ;; (ditaa . t)
     ;; (dot . t)
     ;; (emacs-lisp . t)
     ;; (gnuplot . t)
     ;; (haskell . nil)
     ;; (ocaml . nil)
     ;; (python . t)
     ;; (ruby . t)
     ;; (screen . nil)
     ;; (sh . t)
     ;; (sql . nil)
     ;; (sqlite . t)))

*** Disable warnings in org mode before evaluating source block
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

** Bullets
#+begin_src emacs-lisp
(straight-use-package 'org-bullets)
(require 'org-bullets)

(when window-system
  (if (eq system-type 'windows-nt)
      (setq inhibit-compacting-font-caches t))
  (add-hook 'org-mode-hook (lambda () (interactive) (org-bullets-mode))))
#+end_src

** Visuals
*** Hide emphasis markers
The equal signs =here= to make it bold should not be visible
#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

*** Disable edit-src help header
#+begin_src emacs-lisp
(setq org-edit-src-persistent-message nil)
#+end_src

*** Disable code block indent
Should I change this??
(setq org-edit-src-content-indentation 0)

*** Change face of levels
#+begin_src emacs-lisp
(defvar my/org-level-1-height 1.9)
(defvar my/org-level-2-height 1.6)
(defvar my/org-level-3-height 1.4)
(defvar my/org-level-4-height 1.3)
(defvar my/org-level-5-height 1.25)
(defvar my/org-level-6-height 1.2)
(defvar my/org-level-7-height 1.15)
(defvar my/org-level-8-height 1.10)

(set-face-attribute 'org-level-1 nil :inherit 'outline-1) ;;:height my/org-level-1-height)
(set-face-attribute 'org-level-2 nil :inherit 'outline-2) ;;:height my/org-level-2-height)
(set-face-attribute 'org-level-3 nil :inherit 'outline-3) ;;:height my/org-level-3-height)
(set-face-attribute 'org-level-4 nil :inherit 'outline-4) ;;:height my/org-level-4-height)
(set-face-attribute 'org-level-5 nil :inherit 'outline-5) ;;:height my/org-level-5-height)
(set-face-attribute 'org-level-6 nil :inherit 'outline-6) ;;:height my/org-level-6-height)
(set-face-attribute 'org-level-7 nil :inherit 'outline-7) ;;:height my/org-level-7-height)
(set-face-attribute 'org-level-8 nil :inherit 'outline-8) ;;:height my/org-level-8-height)
#+end_src

:weight 'semi-bold

*** Ellipsis face
#+begin_src emacs-lisp
(setq org-ellipsis my/fold-ellipsis)
#+end_src

*** Always truncate lines
#+begin_src emacs-lisp
(setq org-startup-truncated nil)
#+end_src

** Indent mode
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

** Org SRC
*** Make c-' open in current window
#+begin_src emacs-lisp
(setq org-src-window-setup 'current-window)
#+end_src

*** Don't save window layout
#+begin_src emacs-lisp
(add-hook 'org-src-mode-hook '(lambda () (interactive) (setq org-src--saved-temp-window-config nil)))
#+end_src

*** Rebind key
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "'") 'my/toggle-org-src)

(defun my/toggle-org-src ()
  (interactive)
  (if (string= major-mode 'org-mode)
      (org-edit-special)
    (org-edit-src-exit)))
#+end_src

** Agenda
Give agenda file to use
#+begin_src emacs-lisp
(if (file-exists-p "~/Notes/Agenda.org")
    (setq org-agenda-files (quote ("~/Notes/Agenda.org"))))

(setq org-agenda-window-setup 'current-window)
#+end_src

*** Display at startup
Spawn agenda buffer
(org-agenda-list)

**** Declare switch function
Because just giving "*Org Agenda*" to "initial-buffer-choice" doesn't work
#+begin_src emacs-lisp
(defun my/switch-to-agenda()
  (interactive)
  (switch-to-buffer "*Org Agenda*"))
#+end_src

**** Run switch function as initial buffer choice
#+begin_src emacs-lisp
(setq initial-buffer-choice 'my/switch-to-agenda)
#+end_src

**** Close all other open windows at start
#+begin_src emacs-lisp
(delete-other-windows)
#+end_src

** Clock
(setq org-clock-mode-line-total today)

*** Keys
(define-prefix-command 'my/clock-map)
(define-key my/leader-map (kbd "c") 'my/clock-map)

(define-key my/clock-map (kbd "s") 'org-clock-in)
(define-key my/clock-map (kbd "S") 'org-clock-out)
(define-key my/clock-map (kbd "C-s") 'org-clock-in-last)

(define-key my/clock-map (kbd "e") 'org-clock-modify-effort-estimate)

** Export
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-map)
(define-key my/org-mode-map (kbd "E") 'my/org-export-map)
#+end_src

*** Syntax highlighting for HTML export
#+begin_src emacs-lisp
(straight-use-package 'htmlize)
#+end_src

*** Twitter bootstrap
#+begin_src emacs-lisp
(straight-use-package 'ox-twbs)
#+end_src

*** ASCII
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-ascii-map)
(define-key my/org-export-map (kbd "a") 'my/org-export-ascii-map)

(define-key my/org-export-ascii-map (kbd "a") 'org-ascii-export-to-ascii)
#+end_src

*** HTML
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-html-map)
(define-key my/org-export-map (kbd "h") 'my/org-export-html-map)

(define-key my/org-export-html-map (kbd "h") 'org-html-export-to-html)
(define-key my/org-export-html-map (kbd "t") 'org-twbs-export-to-html)
#+end_src

*** PDF
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-pdf-map)
(define-key my/org-export-map (kbd "p") 'my/org-export-pdf-map)

(define-key my/org-export-pdf-map (kbd "p") 'org-latex-export-to-pdf)
#+end_src

*** Beamer presentation
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-slides-map)
(define-key my/org-export-map (kbd "s") 'my/org-export-slides-map)

(define-key my/org-export-slides-map (kbd "b") 'org-beamer-export-to-pdf)
#+end_src

*** Markdown
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-markdown-map)
(define-key my/org-export-map (kbd "m") 'my/org-export-markdown-map)

(define-key my/org-export-markdown-map (kbd "m") 'org-md-export-to-markdown)
#+end_src

*** ODT
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-odt-map)
(define-key my/org-export-map (kbd "o") 'my/org-export-odt-map)

(define-key my/org-export-odt-map (kbd "o") 'org-odt-export-to-odt)
#+end_src

*** Latex
#+begin_src emacs-lisp
(define-prefix-command 'my/org-export-latex-map)
(define-key my/org-export-map (kbd "l") 'my/org-export-latex-map)

(define-key my/org-export-latex-map (kbd "l") 'org-latex-export-to-latex)
#+end_src

** Present
#+begin_src emacs-lisp
(defun my/org-present-next ()
  (interactive)
  (widen)
  (if (string= (string (char-after)) "*")
      (forward-line))
  (narrow-to-region
   (- (re-search-forward "^*") 1)
   (- (re-search-forward "^*") 1))
  (evil-open-fold)
  (goto-char (point-min)))

(defun my/org-present-prev ()
  (interactive)
  (widen)
  (if (string= (string (char-after)) "*")
      (forward-line))
  (narrow-to-region
   (re-search-backward "^*")
   (+ (re-search-backward "^*") 1))
  (evil-open-fold)
  (goto-char (point-min)))
#+end_src

** Eldoc
 (straight-use-package 'org-plus-contrib)
 (require 'org-eldoc)
 (require 'org-src)
 (add-hook 'org-mode-hook #'org-eldoc-load)

*** Fix error
The function =org-src-get-lang-mode= doesn't exist, but the function =org-src--get-lang-mode= does
 (defun org-src-get-lang-mode (LANG)
   (org-src--get-lang-mode LANG))

** Key
#+begin_src emacs-lisp
(define-key my/org-mode-map (kbd "i") 'org-toggle-inline-images)
(define-key my/org-mode-map (kbd "e") 'org-insert-link)

(define-key my/org-mode-map (kbd "p") 'org-shiftup)
(define-key my/org-mode-map (kbd "n") 'org-shiftdown)
(define-key my/org-mode-map (kbd "l") 'org-shiftright)
(define-key my/org-mode-map (kbd "h") 'org-shiftleft)

(define-key my/org-mode-map (kbd "P") 'org-shiftmetaup)
(define-key my/org-mode-map (kbd "N") 'org-shiftmetadown)
(define-key my/org-mode-map (kbd "L") 'org-shiftmetaright)
(define-key my/org-mode-map (kbd "H") 'org-shiftmetaleft)

(define-key my/org-mode-map (kbd "|") 'org-table-create-or-convert-from-region)

(define-key my/org-mode-map (kbd "z") 'org-shifttab)

(define-key my/org-mode-map (kbd "f") 'my/org-present-next)
(define-key my/org-mode-map (kbd "b") 'my/org-present-prev)

(define-key my/org-mode-map (kbd "i") 'org-toggle-inline-images)

(define-key my/org-mode-map (kbd "d") 'org-deadline)
#+end_src

(define-key org-mode-map "\t" 'nil)

*** Show map
#+begin_src emacs-lisp
(define-prefix-command 'my/org-show-mode-map)
#+end_src
(define-key my/org-mode-map (kbd "s") 'my/org-show-mode-map)

#+begin_src emacs-lisp
(define-key my/org-mode-map (kbd "s") 'org-toggle-link-display)
#+end_src

*** Disable syntax highlighting in source code blocks
#+begin_src emacs-lisp
(setq org-src-fontify-natively nil)
#+end_src

* Outline
Must be set before outline is loaded
Required by outorg
#+begin_src emacs-lisp
(defvar outline-minor-mode-prefix "\M-#")

(straight-use-package 'outline)
#+end_src
(require 'outorg)

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'outline-minor-mode)
#+end_src

** Outline evil text object
#+begin_src emacs-lisp
(evil-define-text-object evil-around-heading (count &optional beg end type)
  "Select heading"
  (let ((top nil)
	(bot nil))
    (save-restriction
      (save-excursion
	(my/auto-narrow-to-subtree)
	(setq top (point-min))
	(setq bot (point-max))))
    (evil-range top bot)))

(evil-define-text-object evil-inside-heading (count &optional beg end type)
  "Select heading"
  (let ((top nil)
	(bot nil))
    (save-restriction
      (save-excursion
	(my/auto-narrow-to-subtree)
	(beginning-of-buffer)
	(ignore-errors
	  (next-line)
	  (beginning-of-line))
	(setq top (point))
	(setq bot (point-max))))
    (evil-range top bot)))

(define-key evil-outer-text-objects-map "h" 'evil-around-heading)
(define-key evil-inner-text-objects-map "h" 'evil-inside-heading)
#+end_src

** Imenu
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "I") 'counsel-imenu)
#+end_src

** Counsel-outline
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "TAB") 'counsel-outline)
#+end_src

***  Fix so that counsel-outline can unfold to the line it needs to go to
#+begin_src emacs-lisp
(defun counsel-outline-action (x)
  "Go to outline X."
  (goto-char (cdr x))
  (outline-show-entry))
#+end_src

*** Fix counsel-outline in elisp mode
Elisp mode uses the classic lisp outline syntax
#+begin_src emacs-lisp
(setq counsel-outline-settings
      '((emacs-lisp-mode
	 :outline-regexp ";; [*]\\{1,8\\} "
	 :outline-level counsel-outline-level-emacs-lisp)
	(org-mode
	 :outline-title counsel-outline-title-org
	 :action counsel-org-goto-action
	 :history counsel-org-goto-history
	 :caller counsel-org-goto)
	;; markdown-mode package
	(markdown-mode
	 :outline-title counsel-outline-title-markdown)
	;; Built-in mode or AUCTeX package
	(latex-mode
	 :outline-title counsel-outline-title-latex)))
#+end_src

** Outshine
#+begin_src emacs-lisp
(straight-use-package 'outshine)
#+end_src
(straight-use-package '(outshine :type git :host github :repo "alphapapa/outshine"))
#+begin_src emacs-lisp
(require 'outshine)
#+end_src

Clean outshine-mode-map
#+begin_src emacs-lisp
(setq outshine-mode-map (make-sparse-keymap))

(add-hook 'outline-minor-mode-hook 'outshine-mode)

(setq outshine-startup-folded-p nil)
#+end_src

** Outorg
#+begin_src emacs-lisp
(require 'outorg)
(setq outorg-edit-buffer-persistent-message nil)
(setq outorg-unindent-active-source-blocks-p nil)
#+end_src

*** Toggle current heading
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "f") 'my/outorg-toggle-heading)

(defun my/outorg-toggle-heading ()
  (interactive)
  (if (string= major-mode 'org-mode)
      (outorg-copy-edits-and-exit)
    (outorg-edit-as-org)))
#+end_src

*** Toggle entire buffer
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "F") 'my/outorg-toggle)

(defun my/outorg-toggle ()
  (interactive)
  (if (string= major-mode 'org-mode)
      (outorg-copy-edits-and-exit)
    (outorg-edit-as-org '(4))))
#+end_src

*** Export
#+begin_src emacs-lisp
(defun my/outorg-export-to-org-file (&optional name)
  (interactive)
  (let ((buffer (generate-new-buffer "outorg-org-output"))
	(mode major-mode))
    (copy-to-buffer buffer (point-min) (point-max))
    (switch-to-buffer buffer)
    (funcall mode)
    (outorg-convert-to-org)
    (if name
	(write-file name)
      (save-buffer))
    (kill-buffer)))
#+end_src

** Visuals
#+begin_src emacs-lisp
(setq counsel-outline-face-style nil)

(set-face-attribute 'outshine-level-1 nil :inherit 'outline-1) ;;:height my/org-level-1-height)
(set-face-attribute 'outshine-level-2 nil :inherit 'outline-2) ;;:height my/org-level-2-height)
(set-face-attribute 'outshine-level-3 nil :inherit 'outline-3) ;;:height my/org-level-3-height)
(set-face-attribute 'outshine-level-4 nil :inherit 'outline-4) ;;:height my/org-level-4-height)
(set-face-attribute 'outshine-level-5 nil :inherit 'outline-5) ;;:height my/org-level-5-height)
(set-face-attribute 'outshine-level-6 nil :inherit 'outline-6) ;;:height my/org-level-6-height)
(set-face-attribute 'outshine-level-7 nil :inherit 'outline-7) ;;:height my/org-level-7-height)
(set-face-attribute 'outshine-level-8 nil :inherit 'outline-8) ;;:height my/org-level-8-height)
#+end_src

** Narrowing
(define-prefix-command 'my/narrow-map)
(define-key my/leader-map (kbd "n") 'my/narrow-map)

*** Narrow indirect
#+begin_src emacs-lisp
(defun my/narrow-indirect (beg end)
  (my/clone-indirect-buffer)
  (narrow-to-region beg end))
#+end_src

**** Evil operator
#+begin_src emacs-lisp
(evil-define-operator my/evil-narrow-indirect (beg end type)
  "Indirectly narrow the region from BEG to END."
  (interactive "<R>")
  (evil-normal-state)
  (my/narrow-indirect beg end))

(define-key evil-normal-state-map "m" 'my/evil-narrow-indirect)
(define-key evil-visual-state-map "m" 'my/evil-narrow-indirect)
#+end_src

**** Evil-goggle support
#+begin_src emacs-lisp
(add-to-list 'evil-goggles--commands '(my/evil-narrow-indirect :face evil-goggles-yank-face :switch evil-goggles-enable-yank :advice evil-goggles--generic-async-advice))
#+end_src

*** Narrow
**** Evil operator
#+begin_src emacs-lisp
(evil-define-operator my/evil-narrow (beg end type)
  "Indirectly narrow the region from BEG to END."
  (interactive "<R>")
  (evil-normal-state)
  (narrow-to-region beg end))

(define-key evil-normal-state-map "M" 'my/evil-narrow)
(define-key evil-visual-state-map "M" 'my/evil-narrow)
#+end_src

*** Universal narrow function
#+begin_src emacs-lisp
(defun my/narrow-widen ()
  (interactive)
  (if loccur-mode
      (loccur-mode -1)
    (widen)))
#+end_src

(define-key my/narrow-map (kbd "w") 'my/narrow-widen)
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "n") 'my/narrow-widen)
#+end_src

*** Narrow to subtree
#+begin_src emacs-lisp
(defun my/auto-narrow-to-subtree ()
  (interactive)
  (pcase major-mode
    ('org-mode (org-narrow-to-subtree))
    (_
     ;; Fixes a bug where if cursor is at heading, the one above gets narrowed
     (next-line)

     (outline-previous-visible-heading 1)
     (outshine-narrow-to-subtree))))
#+end_src

(define-key my/narrow-map (kbd "i") 'my/auto-narrow-to-subtree)

** Outline ellipsis
#+begin_src emacs-lisp
(defvar outline-display-table (make-display-table))
(set-display-table-slot outline-display-table 'selective-display
			(vector (make-glyph-code my/fold-ellipsis-char 'escape-glyph)))
(defun set-outline-display-table ()
  (setf buffer-display-table outline-display-table))

(add-hook 'outline-mode-hook 'set-outline-display-table)
(add-hook 'outline-minor-mode-hook 'set-outline-display-table)
#+end_src

** Keys
*** Outline fold
#+begin_src emacs-lisp
(my/evil-normal-define-key "g i" 'outline-previous-visible-heading)

(my/evil-normal-define-key "g o" 'outline-toggle-children)
(my/evil-normal-define-key "g O" 'outline-show-subtree)
(my/evil-normal-define-key "g h" 'my/outline-hide-all-headings)
(my/evil-normal-define-key "g H" 'my/outline-hide-all)

(my/evil-normal-define-key "g a" 'outline-show-all)

(defun my/outline-hide-all ()
  (interactive)
  (outline-hide-sublevels 1))

(defun my/outline-hide-all-headings ()
  (interactive)
  (outline-show-all)
  (outline-hide-body))
#+end_src

*** Code fold
#+begin_src emacs-lisp
(my/evil-normal-define-key "g C-o" 'my/code-fold-show)
(my/evil-normal-define-key "g RET" 'my/code-fold-show-all)
(my/evil-normal-define-key "g C-h" 'my/code-fold-hide-level)

(defun my/code-fold-show ()
  (interactive)
  (if hs-minor-mode
      (hs-toggle-hiding)
    (yafolding-toggle-element)))

(defun my/code-fold-show-all ()
  (interactive)
  (if hs-minor-mode
      (hs-show-all)
    (yafolding-show-all)))

(defun my/code-fold-hide-level ()
  (interactive)
  (if hs-minor-mode
      (call-interactively 'hs-hide-level)
    (yafolding-hide-all)))
#+end_src

** Folding
*** Hideshow
#+begin_src emacs-lisp
(require 'hideshow)

(defvar my/hs-ignore-modes '(fsharp-mode))

(add-hook 'prog-mode-hook '(lambda () (interactive)
			     (if (not (member major-mode my/hs-ignore-modes))
				 (hs-minor-mode 1))))
#+end_src

*** Yafolding
Used for universal folding
#+begin_src emacs-lisp
(straight-use-package 'yafolding)

(define-globalized-minor-mode global-yafolding-mode
  yafolding-mode yafolding-mode)
(yafolding-mode)
(global-yafolding-mode 1)

(setq yafolding-ellipsis-content my/fold-ellipsis)
(setq yafolding-show-fringe-marks nil)
#+end_src

* Completion
** Ivy
#+begin_src emacs-lisp
(straight-use-package 'ivy)
(ivy-mode 1)

(setq ivy-use-virtual-buffers nil)
#+end_src

Make user intput selectable
#+begin_src emacs-lisp
(setq ivy-use-selectable-prompt t)
#+end_src

*** Visuals
Ivy height
#+begin_src emacs-lisp
(setq ivy-height 20)
#+end_src

Make counsel-yank-pop use default height
(delete `(counsel-yank-pop . 5) ivy-height-alist)
Disable set height depending on command
#+begin_src emacs-lisp
(add-hook 'after-init-hook '(lambda ()
			      (setq ivy-height-alist nil)
			      (setq-default ivy-height-alist nil)
			      (add-to-list 'ivy-height-alist '(swiper . 10))
			      (add-to-list 'ivy-height-alist '(swiper-isearch . 10))))
#+end_src

**** Highlight whole row in minibuffer
Change the default emacs formatter to highlight whole row in minibuffer
#+begin_src emacs-lisp
(delete '(t . ivy-format-function-default) ivy-format-functions-alist)
(add-to-list 'ivy-format-functions-alist '(t . ivy-format-function-line))
#+end_src

*** Wgrep
Needed by ivy-occur to edit buffers
#+begin_src emacs-lisp
(straight-use-package 'wgrep)
(require 'wgrep)
#+end_src

*** Keys
#+begin_src emacs-lisp
(defun my/ivy-top ()
  (interactive)
  (ivy-previous-line ivy--length))

(defun my/ivy-bot ()
  (interactive)
  (ivy-next-line ivy--length))

(setq ivy-minibuffer-map (make-sparse-keymap))
#+end_src

Enable avy movements in ivy buffer
#+begin_src emacs-lisp
(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "M-n") 'ivy-avy)
(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "M-p") 'ivy-avy)

(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "G") 'my/ivy-bot)
(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "g g") 'my/ivy-top)

(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "n") 'ivy-next-line)
(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "p") 'ivy-previous-line)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-n") 'ivy-next-line)
(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-p") 'ivy-previous-line)

(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "C-y") 'ivy-call)

(define-key ivy-minibuffer-map [remap evil-ret] 'ivy-done)
(define-key ivy-minibuffer-map [remap newline] 'ivy-done)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-g") 'minibuffer-keyboard-quit)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-u") 'ivy-scroll-down-command)
(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-w") 'ivy-scroll-up-command)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-o") 'ivy-occur)
#+end_src

Doesn't work with dedicated minibuffer window?
evil-define-key '(motion normal) ivy-minibuffer-map  (kbd "C-y") 'ivy-dispatching-done)
define-key 'insert ivy-minibuffer-map  (kbd "C-y") 'ivy-dispatching-done)

#+begin_src emacs-lisp
(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-s") 'ivy-next-line-or-history)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "TAB") 'ivy-partial-or-done)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "RET") 'ivy-done)

(evil-define-key '(motion normal insert) ivy-minibuffer-map (kbd "C-d") 'ivy-insert-current)
#+end_src

Clear ivy input
#+begin_src emacs-lisp
(evil-define-key '(motion normal) ivy-minibuffer-map (kbd "D") '(lambda () (interactive) (beginning-of-line-text)
								  (evil-delete-char (+ 1 (point)) (point-max))
								  (delete-char 1)))
#+end_src

**** Ivy occur
Also ivy-occur-grep
#+begin_src emacs-lisp
(define-prefix-command 'my/ivy-occur-map)
(evil-define-key 'normal ivy-occur-mode-map (kbd (concat my/leader-map-key " a")) 'my/ivy-occur-map)
(evil-define-key 'normal ivy-occur-grep-mode-map (kbd (concat my/leader-map-key " a")) 'my/ivy-occur-map)

(define-key my/ivy-occur-map (kbd "w") 'ivy-wgrep-change-to-wgrep-mode)
(define-key my/ivy-occur-map (kbd "r") 'ivy-occur-revert-buffer)

(evil-define-key '(normal visual insert) ivy-occur-mode-map (kbd "RET") 'ivy-occur-press)
(evil-define-key '(normal visual) ivy-occur-mode-map (kbd "p") 'evil-previous-line)
(evil-define-key '(normal visual) ivy-occur-mode-map (kbd "n") 'evil-next-line)
(evil-define-key '(normal visual) ivy-occur-mode-map (kbd "C-y") 'ivy-occur-read-action)

(evil-define-key '(normal visual insert) ivy-occur-grep-mode-map (kbd "RET") 'ivy-occur-press)
(evil-define-key '(normal visual) ivy-occur-grep-mode-map (kbd "p") 'evil-previous-line)
(evil-define-key '(normal visual) ivy-occur-grep-mode-map (kbd "n") 'evil-next-line)
(evil-define-key '(normal visual) ivy-occur-grep-mode-map (kbd "C-y") 'ivy-occur-read-action)
#+end_src

(define-key map (kbd "a") 'ivy-occur-read-action)
(define-key map (kbd "o") 'ivy-occur-dispatch)
(define-key map (kbd "c") 'ivy-occur-toggle-calling)

**** wgrep
Used in ivy occur
#+begin_src emacs-lisp
(setq wgrep-mode-map (make-sparse-keymap))

(define-prefix-command 'my/wgrep-map)
(evil-define-key 'normal wgrep-mode-map (kbd (concat my/leader-map-key " a")) 'my/wgrep-map)

(define-key my/wgrep-map (kbd "s") 'wgrep-finish-edit)
(define-key my/wgrep-map (kbd "k") 'wgrep-abort-changes)
#+end_src

** Counsel
#+begin_src emacs-lisp
(straight-use-package 'counsel)

(counsel-mode 1)
#+end_src

(setq-default counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
#+begin_src emacs-lisp
(setq counsel-grep-base-command "grep -i -E -n -e %s %s")
#+end_src

*** Counsel-yank-pop
Delete text under selection when pasing just like with normal evil paste
#+begin_src emacs-lisp
(advice-add #'counsel-yank-pop :before (lambda (&optional arg) (if (string= evil-state 'visual)
								   (delete-region (point) (mark)))))
#+end_src

*** Always run counsel ag in defalut directory
#+begin_src emacs-lisp
(defun my/counsel-ag ()
  (interactive)
  (counsel-ag nil default-directory))
#+end_src

*** Remove dups
**** Remove duplicate entries in kill ring
#+begin_src emacs-lisp
(advice-add #'counsel-yank-pop :before (lambda (&optional arg) (delete-dups kill-ring)))
#+end_src

**** Remove duplicate entries in yank ring
#+begin_src emacs-lisp
(advice-add #'counsel-mark-ring :before (lambda (&optional arg) (delete-dups mark-ring)))
#+end_src

*** Keys
(define-key my/leader-map (kbd "g") 'counsel-M-x)
#+begin_src emacs-lisp
(global-set-key (kbd "M-c") 'counsel-M-x)

(global-set-key (kbd "M-k") 'counsel-yank-pop)

(define-key ivy-minibuffer-map (kbd "DEL") 'ivy-backward-delete-char)
#+end_src

** Counsel flycheck
  https://github.com/nathankot/dotemacs/blob/master/init.el

#+begin_src emacs-lisp
(defvar my/counsel-flycheck-history nil
  "History for `counsel-flycheck'")

(defun my/counsel-flycheck ()
  (interactive)
  (if (not (bound-and-true-p flycheck-mode))
      (message "Flycheck mode is not available or enabled")
    (ivy-read "Error: "
	      (let ((source-buffer (current-buffer)))
		(with-current-buffer (or (get-buffer flycheck-error-list-buffer)
					 (progn
					   (with-current-buffer
					       (get-buffer-create flycheck-error-list-buffer)
					     (flycheck-error-list-mode)
					     (current-buffer))))
		  (flycheck-error-list-set-source source-buffer)
		  (flycheck-error-list-reset-filter)

		  ;; Finally, refresh the error list to show the most recent errors
		  (flycheck-error-list-refresh)

		  (revert-buffer t t t)
		  (split-string (buffer-string) "\n" t)))
	      :action (lambda (s &rest _)
			(-when-let* ( (error (get-text-property 0 'tabulated-list-id s))
				      (pos (flycheck-error-pos error)) )
			  (goto-char (flycheck-error-pos error))))
	      :history 'my/counsel-flycheck-history)))

(define-key my/leader-map (kbd "J") 'my/counsel-flycheck)
#+end_src

** Swiper
#+begin_src emacs-lisp
(straight-use-package 'swiper)

(defun my/use-swiper-or-grep(&optional input case-sensative)
  (interactive)
  (swiper input))
#+end_src
(if (and buffer-file-name (not (bound-and-true-p org-src-mode)) (not (string= "gz" (file-name-extension buffer-file-name))))
(counsel-grep input)
(swiper input)))

Checks for if case sensative search
(if case-sensative
(setq counsel-grep-base-command "grep -E -n -e %s %s")
(setq-default counsel-grep-base-command "grep -i -E -n -e %s %s"))

#+begin_src emacs-lisp
(global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
(global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
#+end_src
(global-set-key (kbd "M-s") (lambda () (interactive) (my/use-swiper-or-grep nil t)))
#+begin_src emacs-lisp
(define-key swiper-map (kbd "M-j") 'swiper-query-replace)
#+end_src


 (setq swiper-use-visual-line t)

*** Disable visual line search
When using visual line mode swiper also searches every visual line, not just every line. This is really slow
#+begin_src emacs-lisp
(setq swiper-use-visual-line nil)
(setq swiper-use-visual-line-p (lambda (a) nil))
#+end_src

*** Search for thing-at-point
#+begin_src emacs-lisp
(defun my/swiper-thing-at-point ()
  "jump to word under cursor"
  (interactive)
  (my/use-swiper-or-grep (thing-at-point 'symbol)))

(my/evil-normal-define-key "#" 'my/swiper-thing-at-point)
(my/evil-normal-define-key "*" 'my/swiper-thing-at-point)
#+end_src

** Ivy rich
#+begin_src emacs-lisp
(straight-use-package 'ivy-rich)
(require 'ivy-rich)

(defvar my/ivy-rich-docstring-spacing 40)
#+end_src

*** Faces
#+begin_src emacs-lisp
(defface my/ivy-rich-doc-face
  '((t :inherit font-lock-doc-face))
  "Face used for the doc face in ivy rich buffers")

(defface my/ivy-rich-switch-buffer-size-face
  '((t :inherit default))
  "Face used by ivy rich")

(defface my/ivy-rich-switch-buffer-path-face
  '((t :inherit default))
  "Face used by ivy rich")

(defface my/ivy-rich-switch-buffer-project-face
  '((t :inherit default))
  "Face used by ivy rich")

(defface my/ivy-rich-switch-buffer-indicator-face
  '((t :inherit default))
  "Face used by ivy rich")

(defface my/ivy-rich-switch-buffer-major-mode-face
  '((t :inherit default))
  "Face used by ivy rich")

(defface my/ivy-rich-find-file-symlink-face
  '((t :inherit default))
  "Face used by ivy rich")
#+end_src

*** Set transformers list
(ivy-set-display-transformer 'ivy-switch-buffer 'ivy-switch-buffer)
(setq ivy-rich-path-style 'abbrev)

#+begin_src emacs-lisp
(setq ivy-rich-display-transformers-list
      `(ivy-switch-buffer
	(:columns
	 ((ivy-rich-candidate (:width 30))
	  ;;(ivy-rich-switch-buffer-size (:width 7 :face my/ivy-rich-switch-buffer-size-face))
	  (ivy-rich-switch-buffer-indicators (:width 4 :face my/ivy-rich-switch-buffer-indicator-face :align right))
	  (ivy-rich-switch-buffer-major-mode (:width 12 :face my/ivy-rich-switch-buffer-major-mode-face))

	  ;; These two takes a lot of memory and cpu
	  ;;(ivy-rich-switch-buffer-project (:width 15 :face my/ivy-rich-switch-buffer-project-face))
	  ;;(ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))) :face my/ivy-rich-switch-buffer-path-face))
	  )
	 :predicate
	 (lambda (cand) (get-buffer cand)))
	counsel-find-file
	(:columns
	 ((ivy-read-file-transformer)
	  (ivy-rich-counsel-find-file-truename (:face my/ivy-rich-find-file-symlink-face))))
	counsel-M-x
	(:columns
	 ((counsel-M-x-transformer (:width ,my/ivy-rich-docstring-spacing))
	  (ivy-rich-counsel-function-docstring (:face my/ivy-rich-doc-face))))
	counsel-describe-function
	(:columns
	 ((counsel-describe-function-transformer (:width ,my/ivy-rich-docstring-spacing))
	  (ivy-rich-counsel-function-docstring (:face my/ivy-rich-doc-face))))
	counsel-describe-variable
	(:columns
	 ((counsel-describe-variable-transformer (:width ,my/ivy-rich-docstring-spacing))
	  (ivy-rich-counsel-variable-docstring (:face my/ivy-rich-doc-face))))
	counsel-recentf
	(:columns
	 ((ivy-rich-candidate (:width 0.8))
	  (ivy-rich-file-last-modified-time (:face font-lock-comment-face))))))

(ivy-rich-mode 1)
#+end_src

** Company
#+begin_src emacs-lisp
(straight-use-package 'company)
(require 'company)

(setq company-idle-delay 0)
#+end_src
Sets how long before company echoes tooltips in the minibuffer. Normally company and eldocs fights eachother if this is 0. This is fixed using hooks in "Fix company and eldoc"
#+begin_src emacs-lisp
(setq company-echo-delay 0)
#+end_src

Don't downcase result
#+begin_src emacs-lisp
(setq company-dabbbrev-downcase nil)
#+end_src

Make tooltim margin minimal
#+begin_src emacs-lisp
(setq company-tooltip-margin 2)
#+end_src

Start searching for candidates when 2 letters has been written
#+begin_src emacs-lisp
(setq company-minimum-prefix-length 2)

(add-to-list 'company-transformers 'company-sort-prefer-same-case-prefix)

(setq company-show-numbers t)
#+end_src

Only show 10 candidates at a time
#+begin_src emacs-lisp
(setq company-tooltip-limit 10)
#+end_src

Align annotations to right side
#+begin_src emacs-lisp
(setq company-tooltip-align-annotations t)
#+end_src

Makes it possible to exit company without a candidate selected
#+begin_src emacs-lisp
(setq company-require-match nil)
#+end_src

Enable scrollbar
#+begin_src emacs-lisp
(setq company-tooltip-offset-display 'scrollbar) ;;'line

(global-company-mode t)
#+end_src

Remove dabbrev because it's slow in long files
#+begin_src emacs-lisp
(setq company-backends (delete 'company-dabbrev company-backends))
#+end_src

*** Fix company and eldoc
Where the company menu is up, eldoc shouldn't write to the minibuffer because company is already writing documentation there
#+begin_src emacs-lisp
(add-hook 'company-completion-started-hook '(lambda (a) (setq-local eldoc-idle-delay 100)))
(add-hook 'company-after-completion-hook '(lambda (a) (setq-local eldoc-idle-delay my/eldoc-idle-delay)))
#+end_src

*** Company posframe
(straight-use-package 'company-posframe)
(company-posframe-mode)

*** Company doc buffer
Company doc mode disables visual line mode for whatever reason, enable it inside this redefinition of company-show-doc-buffer
#+begin_src emacs-lisp
(defun my/company-show-doc-buffer ()
  "Temporarily show the documentation buffer for the selection."
  (interactive)
  (let (other-window-scroll-buffer)
    (company--electric-do
      (let* ((selected (nth company-selection company-candidates))
	     (doc-buffer (or (company-call-backend 'doc-buffer selected)
			     (user-error "No documentation available")))
	     start)
	(setq-local truncate-lines nil)
	(visual-line-mode 1)
	(when (consp doc-buffer)
	  (setq start (cdr doc-buffer)
		doc-buffer (car doc-buffer)))
	(setq other-window-scroll-buffer (get-buffer doc-buffer))
	(let ((win (display-buffer doc-buffer t)))
	  (set-window-start win (if start start (point-min))))))))

(define-key company-active-map (kbd "C-o") 'my/company-show-doc-buffer)

(defun my/company-show-doc-buffer-keep-open ()
  "Temporarily show the documentation buffer for the selection."
  (interactive)
  (let (other-window-scroll-buffer)
    (let* ((selected (nth company-selection company-candidates))
	   (doc-buffer (or (company-call-backend 'doc-buffer selected)
			   (user-error "No documentation available")))
	   start)
      (setq-local truncate-lines nil)
      (visual-line-mode 1)
      (when (consp doc-buffer)
	(setq start (cdr doc-buffer)
	      doc-buffer (car doc-buffer)))
      (setq other-window-scroll-buffer (get-buffer doc-buffer))
      (let ((win (display-buffer doc-buffer t)))
	(set-window-start win (if start start (point-min)))))))

(define-key company-active-map (kbd "C-S-h") 'my/company-show-doc-buffer-keep-open)
#+end_src

*** Company-show-numbers but with letters
Need to implement
Letters, etc for autocomplete
line 2769, might also need to change more lines due to "company show numbers" being at a few more places
 (setq right (concat (format " %s" (nth numbered '(a s d f g h j k l i r))) right)))


**** Find function that gets hotkey
name "company-complete-number"

*** Disable quickhelp for good
fsharp mode auto-enables quickhelp by default, disable it
#+begin_src emacs-lisp
(setq company-quickhelp-delay nil)
#+end_src

*** Visuals
**** Lighter
#+begin_src emacs-lisp
(defun my/company--group-lighter (candidate base)
  (let ((backend (or (get-text-property 0 'company-backend candidate)
		     (cl-some (lambda (x) (and (not (keywordp x)) x))
			      company-backend))))
    (when (and backend (symbolp backend))
      (let ((name (replace-regexp-in-string "company-\\|-company" ""
					    (symbol-name backend))))
	(format "%s-%s | " base name)))))
#+end_src

***** Set base
#+begin_src emacs-lisp
(setq company-lighter-base "company")
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-key company-active-map (kbd "M-n") nil)
(define-key company-active-map (kbd "M-p") nil)
(define-key company-active-map (kbd "C-n") 'company-select-next)
(define-key company-active-map (kbd "C-p") 'company-select-previous)

(define-key company-active-map (kbd "C-u") 'company-previous-page)
(define-key company-active-map (kbd "C-w") 'company-next-page)
#+end_src

Complete on tab
#+begin_src emacs-lisp
(define-key company-active-map (kbd "TAB") 'company-complete-selection)
#+end_src

using C-h is better in every way
#+begin_src emacs-lisp
(define-key company-active-map (kbd "<f1>") 'nil)
#+end_src

Force autocomplete
#+begin_src emacs-lisp
(my/evil-universal-define-key "C-." 'company-complete)
#+end_src

** Company-box
Company with icons
Doesn't work with my setup right now
(when window-system
 (straight-use-package 'company-box)

 (add-hook 'company-mode-hook 'company-box-mode)

 ;;(setq company-box-minimum-width 100)
 ;;(setq company-box--height 500)
 ;;(setq company-tooltip-minimum 10)

 (remove-hook 'company-box-selection-hook 'company-box-doc)
 (remove-hook 'company-box-hide-hook 'company-box-doc--hide))

** Flycheck
#+begin_src emacs-lisp
(setq flycheck-mode-map (make-sparse-keymap))
(straight-use-package 'flycheck)
#+end_src

Decrease delay
#+begin_src emacs-lisp
(setq flycheck-display-errors-delay 0.1)

(global-flycheck-mode)
#+end_src

*** Disable flycheck fringe
#+begin_src emacs-lisp
(setq flycheck-indication-mode nil)
#+end_src

*** Flycheck at cursor
**** Flycheck-posframe
#+begin_src emacs-lisp
(straight-use-package 'flycheck-posframe)
(require 'flycheck-posframe)

(with-eval-after-load 'flycheck
  (add-hook 'flycheck-mode-hook #'flycheck-posframe-mode))

(setq my/flycheck-posframe-symbol "→ ")

(setq flycheck-posframe-error-prefix my/flycheck-posframe-symbol)
(setq flycheck-posframe-info-prefix my/flycheck-posframe-symbol)
(setq flycheck-posframe-prefix my/flycheck-posframe-symbol)
(setq flycheck-posframe-warning-prefix my/flycheck-posframe-symbol)
#+end_src

**** Flycheck inline
(straight-use-package 'flycheck-inline)

(require 'flycheck-inline)

(with-eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))

*** Flycheck-package
Flycheck with extra correction for elisp packages
#+begin_src emacs-lisp
(straight-use-package 'flycheck-package)

(with-eval-after-load 'flycheck
  (flycheck-package-setup))
#+end_src

** Which-key
#+begin_src emacs-lisp
(straight-use-package 'which-key)

(which-key-mode)

(setq which-key-idle-delay 1)
#+end_src

** Yasnippet
#+begin_src emacs-lisp
(setq yas-minor-mode-map (make-sparse-keymap))

(straight-use-package 'yasnippet)
(require 'yasnippet)

(straight-use-package 'yasnippet-snippets)

(yas-global-mode 1)
#+end_src

*** Company integration
https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names

#+begin_src emacs-lisp
(defvar company-mode/enable-yas t
  "Enable yasnippet for all backends.")

(defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
      backend
    (append (if (consp backend) backend (list backend))
	    '(:with company-yasnippet))))

(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+end_src

*** Ivy integration
#+begin_src emacs-lisp
(straight-use-package 'ivy-yasnippet)
#+end_src
Needed because its font isn't loaded on install, but is needed in theme
#+begin_src emacs-lisp
(require 'ivy-yasnippet)
(define-key my/leader-map (kbd "i") 'ivy-yasnippet)
#+end_src

*** Keys
#+begin_src emacs-lisp
(defvar my/yas-init nil)
#+end_src

Maybe unbind yas-expand in normal mode, since you only really do it in insert mode
#+begin_src emacs-lisp
(my/evil-normal-define-key "TAB" #'yas-expand)
(my/evil-insert-define-key "TAB" #'yas-expand)
#+end_src

* Movement
** Loccur
#+begin_src emacs-lisp
(straight-use-package 'loccur)
(require 'loccur)

(defvar-local my/loccur-search-running nil)

(defun my/loccur-isearch ()
  (interactive)
  (setq-local my/loccur-search-running t)
  (my/isearch-forward-regexp)
  (setq-local my/loccur-search-running nil))

(add-hook 'isearch-update-post-hook 'my/loccur-isearch-update)

(defun my/loccur-isearch-update ()
  (when my/loccur-search-running
    (loccur-mode -1)
    (if (not (string= isearch-string ""))
	(loccur (ivy--regex-plus isearch-string)))))

(add-hook 'isearch-mode-end-hook 'my/loccur-isearch-quit)

(defun my/loccur-isearch-quit ()
  (if (and my/loccur-search-running isearch-mode-end-hook-quit)
      (loccur-mode -1)))
#+end_src

*** Keys
#+begin_src emacs-lisp
(my/evil-normal-define-key "C-S-s" 'my/loccur-isearch)
#+end_src

** Isearch
#+begin_src emacs-lisp
(require 'isearch)
(define-key isearch-mode-map (kbd "C-n") 'my/isearch-repeat-forward)
(define-key isearch-mode-map (kbd "C-p") 'my/isearch-repeat-backward)

(define-key isearch-mode-map (kbd "C-w") '(lambda () (interactive) () (my/isearch-repeat-times t 5)))
(define-key isearch-mode-map (kbd "C-u") '(lambda () (interactive) () (my/isearch-repeat-times nil 5)))

(setq isearch-lazy-highlight t)
(setq lazy-highlight-initial-delay 0)
#+end_src

*** Stop from having to press C-n two times after pressing C-p
#+begin_src emacs-lisp
(defvar my/last-isearch-dir nil)

(defun my/isearch-repeat-times (forward &optional count)
  (dotimes (i count)
    (my/isearch-repeat forward)))

(defun my/isearch-repeat (forward)
  (interactive)
  (if forward
      (my/isearch-repeat-forward)
    (my/isearch-repeat-backward)))

(defun my/isearch-repeat-forward ()
  (interactive)
  (call-interactively 'isearch-repeat-forward)

  (when (string= my/last-isearch-dir 'backward)
    (call-interactively 'isearch-repeat-forward))
  (setq my/last-isearch-dir 'forward))

(defun my/isearch-repeat-backward ()
  (interactive)
  (call-interactively 'isearch-repeat-backward)

  (when (string= my/last-isearch-dir 'forward)
    (call-interactively 'isearch-repeat-backward))
  (setq my/last-isearch-dir 'backward))

(add-hook 'isearch-mode-end-hook (lambda () (setq my/last-isearch-dir nil)))
#+end_src

*** Make isearch end when only one match
(defun my/ret-if-one-isearch-match ()
  (interactive)
  (set-buffer my/isearch-current-buffer)
  (save-excursion
    (goto-char (point-min))
    (if (= (count-matches isearch-string) 1)
        (setq unread-command-events (listify-key-sequence "\C-m")))))

(add-hook 'isearch-update-post-hook 'my/ret-if-one-isearch-match)


*** Replace isearch regexp search with ivy-regex-plus
#+begin_src emacs-lisp
(defun my/isearch-forward-regexp (&optional not-regexp no-recursive-edit)
  (interactive "P\np")
  (isearch-mode t (null not-regexp) nil (not no-recursive-edit) 'my/ivy--regex-plus))

(defun my/isearch-backward-regexp (&optional not-regexp no-recursive-edit)
  (interactive "P\np")
  (isearch-mode nil (null not-regexp) nil (not no-recursive-edit) 'my/ivy--regex-plus))

(defun my/ivy--regex-plus (string &optional lax)
  (ivy--regex-plus string))
#+end_src

** Goto middle of line
#+begin_src emacs-lisp
(defun my/go-to-middle-of-line ()
  (interactive)
  (goto-char (/  (+ (line-end-position) (line-beginning-position)) 2)))

(my/evil-normal-define-key "^" 'my/go-to-middle-of-line)
#+end_src

** Navigate indent
https://emacs.stackexchange.com/questions/20900/navigate-by-indentation
#+begin_src emacs-lisp
(defun indentation-get-next-good-line (direction skip good)
  "Moving in direction `direction', and skipping over blank lines and lines that
    satisfy relation `skip' between their indentation and the original indentation,
    finds the first line whose indentation satisfies predicate `good'."
  (let ((starting-indentation (current-indentation))
	(lines-moved direction))
    (save-excursion
      (while (and (zerop (forward-line direction))
		  (or (eolp)  ; Skip past blank lines and other skip lines
		      (funcall skip (current-indentation) starting-indentation)))
	(setq lines-moved (+ lines-moved direction)))
      ;; Now we can't go further. Which case is it?
      (if (and
	   (not (eobp))
	   (not (bobp))
	   (funcall good (current-indentation) starting-indentation))
	  lines-moved
	nil))))

(defun indentation-get-next-sibling-line ()
  "The line number of the next sibling, if any."
  (indentation-get-next-good-line 1 '> '=))

(defun indentation-get-previous-sibling-line ()
  "The line number of the previous sibling, if any"
  (indentation-get-next-good-line -1 '> '=))

(defun indentation-get-parent-line ()
  "The line number of the parent, if any."
  (indentation-get-next-good-line -1 '>= '<))

(defun indentation-get-child-line ()
  "The line number of the first child, if any."
  (indentation-get-next-good-line +1 'ignore '>))

(defun indentation-move-to-line (func preserve-column name)
  "Move the number of lines given by func. If not possible, use `name' to say so."
  (let ((saved-column (current-column))
	(lines-to-move-by (funcall func)))
    (if lines-to-move-by
	(progn
	  (forward-line lines-to-move-by)
	  (move-to-column (if preserve-column
			      saved-column
			    (current-indentation))))
      (message "No %s to move to." name))))

(defun indentation-forward-to-next-sibling ()
  "Move to the next sibling if any, retaining column position."
  (interactive "@")
  (indentation-move-to-line 'indentation-get-next-sibling-line t "next sibling"))

(defun indentation-backward-to-previous-sibling ()
  "Move to the previous sibling if any, retaining column position."
  (interactive "@")
  (indentation-move-to-line 'indentation-get-previous-sibling-line t "previous sibling"))

(defun indentation-up-to-parent ()
  "Move to the parent line if any."
  (interactive "@")
  (indentation-move-to-line 'indentation-get-parent-line nil "parent"))

(defun indentation-down-to-child ()
  "Move to the first child line if any."
  (interactive "@")
  (indentation-move-to-line 'indentation-get-child-line nil "child"))
#+end_src

*** Keys
#+begin_src emacs-lisp
(my/evil-normal-define-key "C-n" 'indentation-forward-to-next-sibling)
(my/evil-visual-define-key "C-n" 'indentation-forward-to-next-sibling)

(my/evil-normal-define-key "C-p" 'indentation-backward-to-previous-sibling)
(my/evil-visual-define-key "C-p" 'indentation-backward-to-previous-sibling)

(my/evil-normal-define-key "C-h" 'indentation-up-to-parent)
(my/evil-visual-define-key "C-h" 'indentation-up-to-parent)

(my/evil-normal-define-key "<deletechar>" 'indentation-down-to-child)
(my/evil-visual-define-key "<deletechar>" 'indentation-down-to-child)
#+end_src

** Marks
#+begin_src emacs-lisp
(setq mark-ring-max 100)
#+end_src

*** Bind counsel-mark-ring
#+begin_src emacs-lisp
(my/evil-universal-define-key "C-o" 'counsel-mark-ring)
(my/evil-universal-define-key "C-b" 'evil-jump-backward)
(my/evil-universal-define-key "M-b" 'evil-jump-forward)
#+end_src

** Avy
#+begin_src emacs-lisp
(straight-use-package 'avy)
(require 'avy)

(setq avy-all-windows nil)

(setq avy-keys '(
		 ;; Easy
		 ?a ?n ?e ?t ?o ?s ?h ?d ?i ?r
		 ;; Med
		 ?g ?m ?l ?w ?y ?f ?u ?b ?x ?c ?v ?k ?p ?, ?.
		 ;; Hard
		 ?q ?\; ?j ?\/ ?z

		 ;; Shifted

		 ;; Easy
		 ?A ?N ?E ?T ?O ?S ?H ?D
		 ;; Med
		 ?R ?I ?G ?M ?L ?W ?Y ?F ?U ?B ?X ?C ?V ?K ?P
		 ;; Hard
		 ?Q ?\: ?J ?\? ?Z

		 ;; Digits
		 ?7 ?4 ?8 ?3 ?9 ?2 ?0 ?1
		 ))
#+end_src

Disable highlighting when avy is used. Doesn't work on 16 color terminals
#+begin_src emacs-lisp
(if window-system (setq avy-background t))
#+end_src

*** Avy-goto-line
**** Above
#+begin_src emacs-lisp
(defun my/avy-goto-line-above-keep-horizontal-position (&optional arg)
  (interactive "p")
  (setq cursor-horizontal-pos (current-column))

  ;; Fixes problem with goto-line and visual line mode
  (if (eq evil-state 'visual)
      (if (eq (evil-visual-type) 'line)
	  (progn
	    (setq was-visual-line t)
	    (evil-visual-char)))
    (progn
      (setq was-visual-line nil)
      (my/evil-normal-state arg)))

  (avy-goto-line-above 2 t)

  (if (eq was-visual-line t)
      (evil-visual-line))

  (move-to-column cursor-horizontal-pos))
#+end_src

**** Below
#+begin_src emacs-lisp
(defun my/avy-goto-line-below-keep-horizontal-position (&optional arg)
  (interactive "p")
  (setq cursor-horizontal-pos (current-column))

  ;; Fixes problem with goto-line and visual line mode
  (if (eq evil-state 'visual)
      (if (eq (evil-visual-type) 'line)
	  (progn
	    (setq was-visual-line t)
	    (evil-visual-char)))
    (progn
      (setq was-visual-line nil)
      (my/evil-normal-state arg)))

  (avy-goto-line-below 2)

  (if (eq was-visual-line t)
      (evil-visual-line))

  (move-to-column cursor-horizontal-pos))
#+end_src

*** Avy-goto-word
#+begin_src emacs-lisp
(defun my/avy-goto-word-0-in-line(&optional arg)
  (interactive "p")
  (if (not (eq evil-state 'visual))
      (my/evil-normal-state arg))

  (avy-goto-subword-0 t nil (line-beginning-position) (line-end-position)))
#+end_src

*** Avy-goto-subword-0
**** Below
#+begin_src emacs-lisp
(defun my/avy-goto-subword-0-below()
  (interactive)
  (avy-goto-subword-0 t nil (point) (window-end (selected-window) t)))
#+end_src

**** Above
#+begin_src emacs-lisp
(defun my/avy-goto-subword-0-above()
  (interactive)
  (avy-goto-subword-0 t nil (window-start (selected-window)) (point)))
#+end_src

** Avy flycheck
#+begin_src emacs-lisp
(straight-use-package 'avy-flycheck)

(define-key my/leader-map (kbd "j") 'avy-flycheck-goto-error)
#+end_src

** Link-hint
#+begin_src emacs-lisp
(straight-use-package 'link-hint)
#+end_src

** Scroll
#+begin_src emacs-lisp
(my/evil-universal-define-key "C-u" 'evil-scroll-up)
(my/evil-universal-define-key "C-w" 'evil-scroll-down)
#+end_src

*** On-screen
(straight-use-package 'on-screen)
(on-screen-global-mode)
(setq on-screen-highlight-method 'fringe)

** Jammer
#+begin_src emacs-lisp
(straight-use-package 'jammer)
(setq jammer-repeat-delay 0.5)
(setq jammer-repeat-window 1)
(setq jammer-type 'repeat)
(setq jammer-block-type 'blacklist)
(setq jammer-block-list '(
			  backward-delete-char
			  delete-char
			  ;;ivy-backward-delete-char
			  ;;			  ;; Backward/forward
			  ;;			  evil-backward-char evil-forward-char evil-previous-line evil-next-line previous-line next-line
			  ;;			  ;; Dired
			  ;;			  dired-next-line dired-previous-line
			  ;;			  word movements
			  ;;			  evil-forward-word evil-forward-word-begin evil-forward-word-end evil-backward-word-begin
			  ;;			  ;; WORD movements
			  ;;			  evil-forward-WORD evil-forward-WORD-begin evil-forward-WORD-end evil-backward-WORD-begin
			  ;;			  evil-backward-word-begin evil-backward-word-end
			  ))
(jammer-mode)
#+end_src

** goto change
g-; and g-,
#+begin_src emacs-lisp
(straight-use-package 'goto-chg)
#+end_src

** My find file
(defun my/find-file ()
 (interactive)
 (find-file (let ((dir (ignore-errors (dired-current-directory))))
	       (if dir
		   (read-file-name "Find file: " dir)
		 (read-file-name "Find file: " default-directory)))))

** Change default directory
#+begin_src emacs-lisp
(defun my/change-default-directory ()
  (interactive)
  (let ((dir (read-file-name "Change default dir: ")))
    (if (f-dir-p dir)
	(setq default-directory dir))))
#+end_src

** Keys
(my/evil-normal-define-key "M-f" 'avy-goto-char-in-line)
(define-key my/leader-map (kbd "f") 'avy-goto-char-in-line)

(my/evil-normal-define-key "M-w" 'my/avy-goto-word-0-in-line)
(define-key my/leader-map (kbd "w") 'my/avy-goto-word-0-in-line)

(my/evil-normal-define-key "M-g" 'avy-goto-char-2)
(define-key my/leader-map (kbd "g") 'avy-goto-char-2)

(my/evil-normal-define-key "M-g" 'avy-goto-char-2)
(define-key my/leader-map (kbd "g") 'avy-goto-char-2)

(my/evil-normal-define-key "M-n" 'avy-goto-word-0-below)
  (define-key evil-normal-state-map (kbd "M-p") 'avy-goto-word-0-above)

(define-key my/leader-map (kbd "n") 'my/avy-goto-line-below-keep-horizontal-position)
(define-key my/leader-map (kbd "p") 'my/avy-goto-line-above-keep-horizontal-position)

(define-key my/keys-mode-map (kbd "M-l") 'link-hint-open-link)
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "l") 'link-hint-open-link)
#+end_src
(define-key my/keys-mode-map (kbd "M-???") 'link-hint-copy-link)

* Bookmark management
#+begin_src emacs-lisp
(defun my/select-bookmark (message)
  (ivy-read message (bookmark-all-names)))

(defun my/add-bookmark ()
  (interactive)
  (bookmark-set (my/select-bookmark "Add bookmark ")))

(defun my/delete-bookmark ()
  (interactive)
  (bookmark-delete (my/select-bookmark "Delete bookmark ")))
#+end_src

doesn't work
(defun my/load-bookmark-file ()
(interactive)
(bookmark-load (ivy-read "load bookmark file " nil)))

* Window management
** Window split functions
#+begin_src emacs-lisp
(defun my/window-split-up ()
  (interactive)
  (split-window nil nil 'above))

(defun my/window-split-down ()
  (interactive)
  (split-window nil nil 'below))

(defun my/window-split-left ()
  (interactive)
  (split-window nil nil 'left))

(defun my/window-split-right ()
  (interactive)
  (split-window nil nil 'right))
#+end_src

** Window config manager
#+begin_src emacs-lisp
(defvar my/window-config-name-changed-hook nil
  "Hook called after user has loaded a window configuration")

(defvar my/window-configurations nil)
(defvar my/current-window-configuration "None")

(defun my/get-window-config-names ()
  (mapcar #'car my/window-configurations))

(defun my/select-window-config (message)
  (ivy-read message (my/get-window-config-names)))

(defun my/get-selected-window-config-position (selected-config)
  (cl-position selected-config (my/get-window-config-names) :test 'string=))

(defun my/update-current-window-config ()
  (setq my/current-window-configuration my/selected-window-config)
  (run-hooks 'my/window-config-name-changed-hook))

(defun my/add-window-config ()
  (interactive)
  (setq my/selected-window-config (my/select-window-config "Add window config: "))

  (setq my/selected-window-config-position (my/get-selected-window-config-position my/selected-window-config))

  (if (eq my/selected-window-config-position nil)
      (push (list my/selected-window-config (current-window-configuration)) my/window-configurations)
    (setf (nth my/selected-window-config-position my/window-configurations) (list my/selected-window-config (current-window-configuration))))

  (my/update-current-window-config))

(defun my/load-window-config ()
  (interactive)
  (setq my/selected-window-config (my/select-window-config "Load window config "))
  (set-window-configuration (nth 1 (nth (my/get-selected-window-config-position my/selected-window-config) my/window-configurations)))

  (my/update-current-window-config))

(defun my/delete-window-config ()
  (interactive)
  (setq my/window-configurations (delete (nth (my/get-selected-window-config-position (my/select-window-config "Delete window config ")) my/window-configurations) my/window-configurations)))
#+end_src

** Winner-mode
Remove default keys
#+begin_src emacs-lisp
(setq winner-mode-map (make-sparse-keymap))

(require 'winner)

(winner-mode)
#+end_src

** No more window resetting
(defmacro save-window-excursion (&rest body)
 )

** Switch to minibuffer
#+begin_src emacs-lisp
(defun my/toggle-switch-to-minibuffer ()
  "Switch to minibuffer window."
  (interactive)
  (if (active-minibuffer-window)
      (progn
	(if (string= major-mode "minibuffer-inactive-mode")
	    (select-window (previous-window))
	  (select-window (active-minibuffer-window))))
    (error "Minibuffer is not active")))

(define-key my/keys-mode-map (kbd "C-j") 'my/toggle-switch-to-minibuffer)
(my/evil-universal-define-key "C-j" 'my/toggle-switch-to-minibuffer)
#+end_src

* Window and buffer settings
** Delete other windows
#+begin_src emacs-lisp
(defun my/delete-other-windows()
  (interactive)
  (delete-other-windows)
  (my/lv-line-create)
  (run-hooks 'my/switch-buffer-hook))
#+end_src

** Switch window hook

** Switch buffer hook
#+begin_src emacs-lisp
(defvar my/switch-buffer-hook nil
  "Hook called after user has switched buffer")
(add-hook 'window-configuration-change-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))
(add-hook 'minibuffer-exit-hook (lambda () (interactive) (run-with-timer 0.1 nil (lambda () (interactive) (run-hooks 'my/switch-buffer-hook)))))
(add-hook 'my/switch-window-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))

(defadvice evil-window-up (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
(defadvice evil-window-down (after evil-window-down activate) (run-hooks 'my/switch-buffer-hook))
(defadvice evil-window-left (after evil-window-left activate) (run-hooks 'my/switch-buffer-hook))
(defadvice evil-window-right (after evil-window-right activate) (run-hooks 'my/switch-buffer-hook))
#+end_src

** Window settings
*** Make cursor auto move to new split window
#+begin_src emacs-lisp
(defun my/split-and-follow-horozontally ()
  (interactive)
  (split-window-below)
  ;;(balance-windows)
  (other-window 1))

(defun my/split-and-follow-vertically()
  (interactive)
  (split-window-right)
  ;;(balance-windows)
  (other-window 1))
#+end_src

*** Don't ask for confirmation when killing window
#+begin_src emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+end_src


*** Kill all buffers
#+begin_src emacs-lisp
(defun my/kill-all-buffers ()
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+end_src

*** Unique names for identical buffer names
#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)

* Dired
#+begin_src emacs-lisp
(require 'dired)

(require 'wdired)
#+end_src

** Disable cluttered major mode
Dired normally puts the sorting string in the major mode name, this disables that
#+begin_src emacs-lisp
(defun dired-sort-set-mode-line ())
#+end_src

** Open current dir
#+begin_src emacs-lisp
(defun my/dired-curr-dir ()
  (interactive)
  (dired default-directory))
#+end_src

** Narrow
(straight-use-package 'dired-narrow)

** Move file between windows
#+begin_src emacs-lisp
(setq dired-dwim-target t)
#+end_src

** Change permissions in wdired
#+begin_src emacs-lisp
(setq wdired-allow-to-change-permissions 'advanced)
#+end_src

** Put deleted files into trash folder
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
#+end_src

** Dired async
*** Better async confirmation messages
#+begin_src emacs-lisp
(setq dired-async-message-function
      (lambda (text face &rest args)
	(shell-command (format "echo '%s'" (apply #'format text args)))))
#+end_src

** Dired atool
#+begin_src emacs-lisp
(straight-use-package 'dired-atool)

(dired-atool-setup)
#+end_src

** Wdired
#+begin_src emacs-lisp
(define-prefix-command 'my/wdired-mode-map)
(evil-define-key 'normal wdired-mode-map (kbd (concat my/leader-map-key " a")) 'my/wdired-mode-map)

(define-key my/wdired-mode-map (kbd "s") 'wdired-finish-edit)
(define-key my/wdired-mode-map (kbd "k") 'wdired-abort-changes)
#+end_src

** Dired collapse
(straight-use-package 'dired-collapse)

(add-hook 'dired-mode-hook 'dired-collapse-mode)

** Subtree
(straight-use-package 'dired-subtree)

** Date format
#+begin_src emacs-lisp
(setq my/dired-base-ls-command "-alh --time-style \"+%d-%m-%Y %H:%M\"")
(setq dired-listing-switches my/dired-base-ls-command)
#+end_src

** Sorting
#+begin_src emacs-lisp
(defun my/dired-sort-menu ()
  (interactive)
  (dired-sort-other
   (pcase (completing-read "Sort by: " '( "date" "size" "name" "dir" "du" "~compatibility"))
     ("name" (progn (my/dired-du-disable-quietly) my/dired-base-ls-command))
     ("date" (progn (my/dired-du-disable-quietly) (concat my/dired-base-ls-command "-t")))
     ("size" (progn (my/dired-du-disable-quietly) (concat my/dired-base-ls-command "--sort=size")))
     ("dir" (progn (my/dired-du-disable-quietly) (concat my/dired-base-ls-command "--group-directories-first")))
     ("~compatibility" (progn (my/dired-du-disable-quietly) "-alh"))
     ("du" (progn (dired-sort-other "-alh") (dired-du-mode 1) "-alh")))))

(defun my/dired-du-disable-quietly ()
  (if dired-du-mode
      (dired-du-mode -1)))

(define-key dired-mode-map (kbd "s") 'my/dired-sort-menu)
#+end_src

** Recursive folder size
#+begin_src emacs-lisp
(straight-use-package 'dired-du)
(require 'dired-du)

(setq dired-du-size-format t)
#+end_src

*** Disable on new buffer
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'my/dired-du-disable-quietly)
#+end_src

** Dired-single
(straight-use-package 'dired-single)

** Keys
Reset dired mode map
#+begin_src emacs-lisp
(setq dired-mode-map (make-sparse-keymap))

(defun my/toggle-delete-to-trash ()
  (interactive)
  (if (eq delete-by-moving-to-trash nil)
      (progn
	(setq delete-by-moving-to-trash t)
	(message "Delete to trash enabled"))
    (progn
      (setq delete-by-moving-to-trash nil)
      (message "Delete to trash disabled"))))

(define-prefix-command 'my/dired-mode-map)
(evil-define-key 'normal dired-mode-map (kbd (concat my/leader-map-key " a")) 'my/dired-mode-map)

(define-key my/dired-mode-map (kbd "t") 'my/toggle-delete-to-trash)
(define-key my/dired-mode-map (kbd "w") 'dired-toggle-read-only)
(defun my/image-dired ()
  (interactive)
  (image-dired default-directory))
(define-key my/dired-mode-map (kbd "i") 'my/image-dired)
(define-key my/dired-mode-map (kbd "h") 'dired-hide-details-mode)
#+end_src

*** Dired close buffer and go down level
#+begin_src emacs-lisp
(defun my/dired-kill-and-go-down ()
  (interactive)
  (let ((dired-buffer (buffer-name)))
    (dired-up-directory)
    (kill-buffer dired-buffer)))
#+end_src

*** Dired keys
Bind =Backspace= to go up one directory
(define-key dired-mode-map [?\d] 'dired-up-directory)
#+begin_src emacs-lisp
(evil-define-key '(normal insert) dired-mode-map (kbd "k") 'dired-up-directory)

(evil-define-key 'insert dired-mode-map (kbd "A") 'dired-do-find-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "B") 'dired-do-byte-compile)

(evil-define-key '(normal insert) dired-mode-map (kbd "K") 'my/dired-kill-and-go-down)
(evil-define-key '(normal insert) dired-mode-map (kbd "RET") 'dired-find-file)
(evil-define-key '(normal insert) dired-mode-map(kbd "C") 'dired-do-copy)
(evil-define-key '(normal insert) dired-mode-map (kbd "D") 'dired-do-delete)
(evil-define-key '(normal insert) dired-mode-map  (kbd "j") 'dired-do-rename)
(evil-define-key '(normal insert) dired-mode-map  (kbd "J") 'dired-do-rename)
(evil-define-key '(normal insert) dired-mode-map  (kbd "!") 'dired-do-shell-command)
(evil-define-key '(normal insert) dired-mode-map  (kbd "&") 'dired-do-async-shell-command)
(evil-define-key '(normal insert) dired-mode-map  (kbd "Z") 'dired-atool-do-unpack-with-subdirectory)
(evil-define-key '(normal insert) dired-mode-map  (kbd "c") 'dired-atool-do-pack)

(evil-define-key 'insert dired-mode-map  (kbd "G") 'dired-do-chgrp)
(evil-define-key 'insert dired-mode-map  (kbd "H") 'dired-do-hardlink)
(evil-define-key 'insert dired-mode-map  (kbd "L") 'dired-do-load)
(evil-define-key 'insert dired-mode-map  (kbd "P") 'dired-do-print)
(evil-define-key 'insert dired-mode-map  (kbd "Q") 'dired-do-find-regexp-and-replace)
(evil-define-key 'insert dired-mode-map  (kbd "S") 'dired-do-symlink)
(evil-define-key 'insert dired-mode-map  (kbd "T") 'dired-do-touch)
#+end_src
Comparison commands
#+begin_src emacs-lisp
(evil-define-key '(normal insert) dired-mode-map (kbd "=") 'my/ediff-dired)
#+end_src

Make all regexp commands share a `%' prefix:
We used to get to the submap via a symbol dired-regexp-prefix,
but that seems to serve little purpose, and copy-keymap
does a better job without it.
#+begin_src emacs-lisp
(evil-define-key 'insert dired-mode-map (kbd "%") nil)
(evil-define-key 'insert dired-mode-map  (kbd "%u") 'dired-upcase)
(evil-define-key 'insert dired-mode-map  (kbd "%l") 'dired-downcase)
(evil-define-key 'insert dired-mode-map  (kbd "%d") 'dired-flag-files-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%g") 'dired-mark-files-containing-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%m") 'dired-mark-files-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%r") 'dired-do-rename-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%C") 'dired-do-copy-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%H") 'dired-do-hardlink-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%R") 'dired-do-rename-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%S") 'dired-do-symlink-regexp)
(evil-define-key 'insert dired-mode-map  (kbd "%&") 'dired-flag-garbage-files)
#+end_src
Commands for marking and unmarking.
#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map (kbd "*") nil)
(evil-define-key 'insert dired-mode-map (kbd "*") nil)
(evil-define-key 'normal dired-mode-map (kbd "**") 'dired-mark-executables)
(evil-define-key 'normal dired-mode-map (kbd "*/") 'dired-mark-directories)
(evil-define-key 'normal dired-mode-map (kbd "*@") 'dired-mark-symlinks)
(evil-define-key 'normal dired-mode-map (kbd "*%") 'dired-mark-files-regexp)

(evil-define-key '(normal insert) dired-mode-map (kbd "*c") 'dired-change-marks)
(evil-define-key '(normal insert) dired-mode-map (kbd "*s") 'dired-mark-subdir-files)
(evil-define-key '(normal insert) dired-mode-map (kbd "*m") 'dired-mark)
(evil-define-key '(normal insert) dired-mode-map (kbd "*u") 'dired-unmark)
(evil-define-key '(normal insert) dired-mode-map (kbd "*?") 'dired-unmark-all-files)
(evil-define-key '(normal insert) dired-mode-map (kbd "*!") 'dired-unmark-all-marks)
(evil-define-key '(normal insert) dired-mode-map (kbd "U") 'dired-unmark-all-marks)
(evil-define-key '(normal insert) dired-mode-map (kbd "*\177") 'dired-unmark-backward)
(evil-define-key '(normal insert) dired-mode-map (kbd "*\C-n") 'dired-next-marked-file)
(evil-define-key '(normal insert) dired-mode-map (kbd "*\C-p") 'dired-prev-marked-file)
(evil-define-key '(normal insert) dired-mode-map (kbd "*t") 'dired-toggle-marks)
#+end_src
Lower keys for commands not operating on all the marked files
#+begin_src emacs-lisp
(evil-define-key 'insert dired-mode-map (kbd "a") 'dired-find-alternate-file)
(evil-define-key '(normal insert) dired-mode-map (kbd "d") 'dired-flag-file-deletion)
(evil-define-key 'insert dired-mode-map (kbd "e") 'counsel-find-file)
#+end_src
(put 'dired-find-file :advertised-binding (kbd "\C-m"))
#+begin_src emacs-lisp
(evil-define-key 'insert dired-mode-map (kbd "g") 'revert-buffer)
(evil-define-key 'insert dired-mode-map (kbd "i") 'dired-maybe-insert-subdir)
#+end_src
Maybe bind this??
#+begin_src emacs-lisp
(evil-define-key 'insert dired-mode-map (kbd "l") 'dired-do-redisplay)
(evil-define-key 'normal dired-mode-map (kbd "M-m") 'dired-mark-subdir-files)
(evil-define-key '(normal insert) dired-mode-map (kbd "m") 'dired-mark)
(evil-define-key 'insert dired-mode-map (kbd "M") 'dired-toggle-marks)
(evil-define-key 'insert dired-mode-map (kbd "n") 'dired-next-line)
(evil-define-key '(normal insert) dired-mode-map (kbd "o") 'dired-find-file-other-window)
(evil-define-key '(normal insert) dired-mode-map (kbd "O") 'dired-insert-subdir)
(evil-define-key 'insert dired-mode-map (kbd "p") 'dired-previous-line)
(evil-define-key 'insert dired-mode-map (kbd "s") 'my/dired-sort-menu)
(evil-define-key 'insert dired-mode-map (kbd "t") 'dired-toggle-marks)
(evil-define-key '(normal insert) dired-mode-map (kbd "u") 'dired-unmark)
(evil-define-key 'insert dired-mode-map (kbd "v") 'dired-view-file)

(evil-define-key 'insert dired-mode-map (kbd "y") 'dired-copy-filename-as-kill)
(evil-define-key 'insert dired-mode-map (kbd "w") 'browse-url-of-dired-file)
(evil-define-key '(normal insert) dired-mode-map (kbd "x") 'dired-do-flagged-delete)

(evil-define-key '(normal insert) dired-mode-map (kbd "?") 'dired-show-file-type)
(evil-define-key '(normal insert) dired-mode-map (kbd "+") 'dired-create-directory)
#+end_src
moving
#+begin_src emacs-lisp
(evil-define-key '(normal insert) dired-mode-map (kbd "<") 'dired-prev-dirline)
(evil-define-key '(normal insert) dired-mode-map (kbd ">") 'dired-next-dirline)
(evil-define-key '(normal insert) dired-mode-map (kbd "^") 'dired-up-directory)
#+end_src
folding
#+begin_src emacs-lisp
(evil-define-key 'normal dired-mode-map (kbd "g") nil)
(define-key dired-mode-map  [remap evil-close-fold] 'dired-hide-subdir)
(define-key dired-mode-map  [remap evil-open-fold] 'dired-unhide-subdir)
(define-key dired-mode-map  [remap my/outline-hide-all-body] 'dired-hide-all)
(define-key dired-mode-map  [remap outline-show-all] 'dired-hide-all)
#+end_src
misc
(evil-define-key 'insert dired-mode-map [remap read-only-mode] 'dired-toggle-read-only)
;; `toggle-read-only' is an obsolete alias for `read-only-mode'
(evil-define-key 'insert dired-mode-map [remap toggle-read-only] 'dired-toggle-read-only)
(evil-define-key 'insert dired-mode-map  (kbd "\177") 'dired-unmark-backward)

thumbnail manipulation (image-dired)
#+begin_src emacs-lisp
(evil-define-key 'insert dired-mode-map (kbd "\C-td") 'image-dired-display-thumbs)
(evil-define-key 'insert dired-mode-map (kbd "\C-tt") 'image-dired-tag-files)
(evil-define-key 'insert dired-mode-map (kbd "\C-tr") 'image-dired-delete-tag)
(evil-define-key 'insert dired-mode-map (kbd "\C-tj") 'image-dired-jump-thumbnail-buffer)
(evil-define-key 'insert dired-mode-map (kbd "\C-ti") 'image-dired-dired-display-image)
(evil-define-key 'insert dired-mode-map (kbd "\C-tx") 'image-dired-dired-display-external)
(evil-define-key 'insert dired-mode-map (kbd "\C-ta") 'image-dired-display-thumbs-append)
(evil-define-key 'insert dired-mode-map (kbd "\C-t.") 'image-dired-display-thumb)
(evil-define-key 'insert dired-mode-map (kbd "\C-tc") 'image-dired-dired-comment-files)
(evil-define-key 'insert dired-mode-map (kbd "\C-tf") 'image-dired-mark-tagged-files)
(evil-define-key 'insert dired-mode-map (kbd "\C-t\C-t") 'image-dired-dired-toggle-marked-thumbs)
(evil-define-key 'insert dired-mode-map (kbd "\C-te") 'image-dired-dired-edit-comment-and-tags)
#+end_src
encryption and decryption (epa-dired)
(evil-define-key 'insert (kbd ":d") 'epa-dired-do-decrypt)
(evil-define-key 'insert  (kbd ":v") 'epa-dired-do-verify)
(evil-define-key 'insert  (kbd ":s") 'epa-dired-do-sign)
(evil-define-key 'insert  (kbd ":e") 'epa-dired-do-encrypt)

* Gud
#+begin_src emacs-lisp
(straight-use-package 'realgud)
(setq gdb-many-windows 'nil)
#+end_src
(require 'realgud)

* Eldoc
Shows information in echo area
Needed??
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+begin_src emacs-lisp
(setq eldoc-echo-area-use-multiline-p t)
(setq-default eldoc-echo-area-use-multiline-p t)
(setq my/eldoc-idle-delay 0)
(setq eldoc-idle-delay my/eldoc-idle-delay)

(setq tooltip-resize-echo-area t)
#+end_src

Update function to only show documentation when not in insert mode
(el-patch-feature eldoc)
(el-patch-defun eldoc-print-current-symbol-info ()
"Print the text produced by `eldoc-documentation-function'."
 This is run from post-command-hook or some idle timer thing,
 so we need to be careful that errors aren't ignored.
(if (not (eq evil-state 'insert))
(with-demoted-errors "eldoc error: %s"
(and (or (eldoc-display-message-p)
 Erase the last message if we won't display a new one.
(when eldoc-last-message
(eldoc-message nil)
nil))
(eldoc-message (funcall eldoc-documentation-function))))))

** Box
(straight-use-package 'eldoc-box)

(add-hook 'eldoc-mode-hook 'eldoc-box-hover-mode)

eldoc-box-hover-at-point-mode needs to be enabled after eldoc-box-hover-mode is done, otherwise problems can appear
(defadvice eldoc-box-hover-mode (after eldoc-box-hover-mode activate) (eldoc-box-hover-at-point-mode 1))

*** Force remove header
(defun eldoc-box--display (str)
  "Display STR in childframe."
  (unless (equal str "") ; WORKAROUND lsp returns empty string from time to time
    (let ((doc-buffer (get-buffer-create eldoc-box--buffer)))
      (with-current-buffer doc-buffer
	(setq mode-line-format nil)
	(setq header-line-format nil)
	;; without this, clicking childframe will make doc buffer the current buffer
	;; and `eldoc-box--maybe-cleanup' in `eldoc-box--cleanup-timer' will clear the childframe
	(setq eldoc-box-hover-mode t)
	(erase-buffer)
	(insert str)
	(goto-char (point-min)))
      (eldoc-box--get-frame doc-buffer))))

** Inline
(straight-use-package 'eldoc-overlay)

(global-eldoc-overlay-mode)

* Code
** Generic
*** Xref
By default xref always prompts with certain commands
#+begin_src emacs-lisp
(setq xref-prompt-for-identifier nil)
#+end_src

**** Ivy-xref
#+begin_src emacs-lisp
(straight-use-package 'ivy-xref)

(require 'ivy-xref)
(setq xref-show-xrefs-function #'ivy-xref-show-xrefs)
#+end_src

*** Smartparens
(straight-use-package 'smartparens)

(smartparens-global-mode)

*** Quick-peek
#+begin_src emacs-lisp
(straight-use-package 'quick-peek)
(require 'quick-peek)

(setq quick-peek-spacer nil)
#+end_src

*** Aggressive indent
#+begin_src emacs-lisp
(straight-use-package 'aggressive-indent)

(global-aggressive-indent-mode)
(add-to-list 'aggressive-indent-excluded-modes 'plantuml-mode)
(add-to-list 'aggressive-indent-excluded-modes 'java-mode)
(add-to-list 'aggressive-indent-excluded-modes 'c-mode)
(add-to-list 'aggressive-indent-excluded-modes 'fsharp-mode)
#+end_src

*** Whitespace cleanup
#+begin_src emacs-lisp
(straight-use-package 'whitespace-cleanup-mode)

(global-whitespace-cleanup-mode)
#+end_src

*** indent guide
(straight-use-package 'highlight-indent-guides)

(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)

(add-hook 'prog-mode-hook '(lambda () (highlight-indent-guides-mode (my/highlight-indent-guide-should-enable))))

;;(defun my/highlight-indent-guide-should-enable ()
;;  (pcase major-mode
;;    ('emacs-lisp-mode -1)
;;    ('lisp-interaction-mode -1)
;;    ('clojure-mode -1)
;;    ('scheme-mode -1)
;;    ('common-lisp-mode -1)
;;    (_ 1)))

(setq highlight-indent-guides-method 'column)
;; (setq highlight-indent-guides-method 'fill)

(setq highlight-indent-guides-responsive 'top)
(setq highlight-indent-guides-delay 0)

*** Auto fix suggested
(straight-use-package 'attrap)
(defun my/auto-fix-suggested ()
 (interactive)
 (pcase major-mode

#+begin_src emacs-lisp
					;    ))
#+end_src

*** Auto jump to definition
#+begin_src emacs-lisp
(straight-use-package 'dumb-jump)

(defun my/auto-jump-to-definition ()
  (interactive)
  (pcase major-mode
    ('fsharp-mode (fsharp-ac/gotodefn-at-point))
    ('clojure-mode (clojure-find-def))
    ('emacs-lisp-mode (call-interactively 'xref-find-definitions))
    ('c-mode (call-interactively 'xref-find-definitions))
    ('c++-mode (call-interactively 'xref-find-definitions))
    ('objc-mode (call-interactively 'xref-find-definitions))
    ('csharp-mode (omnisharp-go-to-definition))
    ;; ('haskell-mode (call-interactively 'xref-find-definitions))
    (_
     (if lsp-mode
	 (lsp-find-definition)
       (dumb-jump-go)))))

(define-key my/leader-map (kbd "t") 'my/auto-jump-to-definition)

(setq dumb-jump-selector 'ivy)
#+end_src

*** Auto find usages
#+begin_src emacs-lisp
(defun my/auto-find-usages ()
  (interactive)
  (pcase major-mode
    ('csharp-mode (omnisharp-find-usages-with-ido))
    (_ (call-interactively 'xref-find-references))))

(define-key my/leader-map (kbd "u") 'my/auto-find-usages)
#+end_src

*** Auto eval
#+begin_src emacs-lisp
(defun my/auto-eval ()
  (interactive)
  (if (string= evil-state 'visual)
      (my/auto-eval-region)
    (pcase major-mode
      ;; Silent result
      ('org-mode (org-babel-execute-src-block nil nil '((:result-params . ("none")))))
      ('scheme-mode (geiser-eval-definition nil))
      ('clojure-mode (cider-eval-last-sexp))
      ('racket-mode (racket-eval-last-sexp))
      ('plantuml-mode (plantuml-preview-region 0 (line-beginning-position) (line-end-position)))
      ('fsharp-mode (fsharp-eval-phrase))
      ('c-mode (cling-send-region (line-beginning-position) (line-end-position)))
      ('c++-mode (cling-send-region (line-beginning-position) (line-end-position)))
      ('csharp-mode (my/csharp-run-repl))
      ('haskell-mode (haskell-interactive-copy-to-prompt))
      (_ (call-interactively 'eros-eval-last-sexp)))))

(defun my/auto-eval-region (beg end)
  (interactive)
  (pcase major-mode
    ('clojure-mode (cider-eval-region beg end))
    ('plantuml-mode (plantuml-preview-region 0 beg end))
    ('fsharp-mode (fsharp-eval-region beg end))
    ('c-mode (cling-send-region beg end))
    ('c++-mode (cling-send-region beg end))
    ('csharp-mode (my/csharp-run-repl))
    ('haskell-mode (haskell-interactive-copy-to-prompt))
    (_
     ;; eval-region doesn't return anything, just prints to the minibuffer so eros can't be used here
     (eros--eval-overlay
      (eval-region beg end t)
      end)
     )))

(defun my/auto-eval-buffer ()
  (interactive)
  (pcase major-mode
    ('scheme-mode (geiser-eval-buffer nil))
    ('clojure-mode (cider-eval-buffer))
    ('plantuml-mode (plantuml-preview-buffer 0))
    ('fsharp-mode (fsharp-eval-region (point-min) (point-max)))
    ('c-mode (cling-send-buffer))
    ('c++-mode (cling-send-buffer))
    ('csharp-mode (my/csharp-run-repl))
    ('haskell-mode (haskell-process-load-file))
    ;; For now disable elisp evaluation
    (_ nil;;(eval-buffer nil)
       )))

(defun my/auto-eval-print ()
  (interactive)
  (pcase major-mode
    ('org-mode (call-interactively #'org-babel-execute-src-block))
    ('scheme-mode (geiser-eval-last-sexp t))
    ('clojure-mode (cider-eval-print-last-sexp))
    ('csharp-mode (haskell-interactive-copy-to-prompt))
    (_ (eval-print-last-sexp nil))))
#+end_src

(define-key my/leader-map (kbd "e") 'my/auto-eval)
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "e") 'my/auto-eval-buffer)
(define-key my/leader-map (kbd "M-e") 'my/auto-eval-print)
#+end_src

*** Auto debug
#+begin_src emacs-lisp
(defun my/auto-debug ()
  (interactive)
  ;;(load-library "realgud")
  (if (eq evil-state 'visual)
      (my/auto-debug-region)
    (pcase major-mode
      ('emacs-lisp-mode (progn (require 'edebug) (call-interactively #'edebug-set-breakpoint)))
      ('c-mode (call-interactively #'gud-break))
      ('c++-mode (call-interactively #'gud-break))
      (_ (eval-last-sexp nil)))))

(defun my/auto-remove-debug ()
  (interactive)
  ;;(load-library "realgud")
  (if (eq evil-state 'visual)
      (my/auto-debug-region)
    (pcase major-mode
      ('emacs-lisp-mode (call-interactively #'edebug-unset-breakpoint))
      ('c-mode (call-interactively #'gud-remove))
      ('c++-mode (call-interactively #'gud-remove))
      (_ (eval-last-sexp nil)))))
#+end_src

(defun my/auto-debug-region ()
(interactive)
)

#+begin_src emacs-lisp
(defun my/start-gdb()
  (split-window-below)
  (call-interactively #'gdb))

(defun my/auto-start-debugger ()
  (interactive)
  ;;(load-library "realgud")
  (pcase major-mode
    ('c-mode (my/start-gdb))
    ('c++-mode (my/start-gdb))
    (_ (eval-last-sexp nil))))

(define-key my/leader-map (kbd "D") 'my/auto-debug)
(define-key my/leader-map (kbd "C-D") 'my/auto-remove-debug)
#+end_src
(define-key my/leader-map (kbd "D") 'my/auto-debug-buffer)
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "M-D") 'my/auto-start-debugger)
#+end_src

*** Auto compile
#+begin_src emacs-lisp
(defun my/auto-compile ()
  (interactive)
  (pcase major-mode
    ('emacs-lisp-mode (emacs-lisp-byte-compile))
    ('clojure-mode (cider-eval-last-sexp))
    ('plantuml-mode (plantuml-preview-buffer 0))
    (_ (recompile))))

(define-key my/leader-map (kbd "C") 'my/auto-compile)
#+end_src

*** Auto docs
#+begin_src emacs-lisp
(defun my/auto-docs ()
  (interactive)
  (pcase major-mode
    ('haskell-mode
     ;; (let ((browse-url-browser-function 'eww-browse-url))
     (my/ivy-hoogle))

    ('nix-mode (my/nixos-options-ivy))))

(define-key my/leader-map (kbd "h") help-map)
(define-key my/leader-map (kbd "H") 'my/auto-docs)
#+end_src

** Documentation
*** Compact-docstrings
(straight-use-package 'compact-docstrings)

*** Zeal
#+begin_src emacs-lisp
(straight-use-package 'zeal-at-point)

(define-key my/leader-map (kbd "T") 'zeal-at-point)
#+end_src

** Plantuml
#+begin_src emacs-lisp
(straight-use-package 'plantuml-mode)
#+end_src

Org src compatibility
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))

(add-hook 'plantuml-mode-hook 'my/plantuml-mode)
#+end_src

** LSP
#+begin_src emacs-lisp
(straight-use-package 'lsp-mode)
#+end_src

Normally lsp-mode starts up flymake mode automaticall which breaks ccls
#+begin_src emacs-lisp
(setq lsp-prefer-flymake nil)

(setq lsp-document-highlight-delay nil)
#+end_src

*** Company LSP
#+begin_src emacs-lisp
(straight-use-package 'company-lsp)
(push 'company-lsp company-backends)
#+end_src

Increases performance
#+begin_src emacs-lisp
(setq company-lsp-cache-candidates 'auto)
#+end_src

*** LSP-ui
#+begin_src emacs-lisp
(straight-use-package 'lsp-ui)
#+end_src
TODO I have to load the package fully here to set the fonts later
#+begin_src emacs-lisp
(require 'lsp-ui)

(add-hook 'lsp-mode-hook 'lsp-ui-mode)

(setq lsp-ui-doc-enable nil
      lsp-ui-peek-enable t
      lsp-ui-sideline-enable t
      lsp-ui-imenu-enable t
      lsp-ui-flycheck-enable t)
#+end_src
(setq lsp-ui-sideline-ignore-duplicate t)

#+begin_src emacs-lisp
(setq lsp-ui-sideline-show-code-actions t
      ;; Errors i think
      lsp-ui-sideline-show-diagnostics nil

      ;; someFunc :: IO ()
      lsp-ui-sideline-show-hover t

      ;; [someFunc]
      lsp-ui-sideline-show-symbol t)

(setq lsp-ui-sideline-delay 0)
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "RET") 'lsp-ui-sideline-apply-code-actions)
#+end_src

** Elgot
(straight-use-package 'eglot)

** Lisps
#+begin_src emacs-lisp
(straight-use-package 'lispy)
(require 'lispy)
#+end_src

*** Common lisp
**** Slime
#+begin_src emacs-lisp
(straight-use-package 'slime)

(setq inferior-lisp-program "/usr/bin/sbcl")
(setq slime-contribs '(slime-fancy))
#+end_src

***** Slime comany
#+begin_src emacs-lisp
(straight-use-package 'slime-company)

(slime-setup '(slime-fancy slime-company))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/common-lisp-mode-map)
(evil-define-key 'normal lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/common-lisp-mode-map)

(define-key my/common-lisp-mode-map (kbd "d") 'slime-inspect-definition)
#+end_src


*** Scheme
(straight-use-package 'geiser)

(define-prefix-command 'my/scheme-mode-map)
(evil-define-key 'normal scheme-mode-map (kbd (concat my/leader-map-key " a")) 'my/scheme-mode-map)

(define-key my/scheme-mode-map (kbd "s") 'geiser-set-scheme)
(define-key my/scheme-mode-map (kbd "C-s") 'run-geiser)

*** Racket
#+begin_src emacs-lisp
(straight-use-package 'racket-mode)
#+end_src

**** Fix eval
#+begin_src emacs-lisp
(defun racket-eval-last-sexp ()
  "Eval the previous sexp asynchronously and `message' the result."
  (interactive)
  (racket--cmd/async
   `(eval
     ,(buffer-substring-no-properties (racket--repl-last-sexp-start)
				      (+ 1(point))))
   (lambda (v)
     (message "%s" v))))

(defun racket--repl-last-sexp-start ()
  (save-excursion
    (condition-case ()
	(progn
	  (my/backward-sexp)
	  (if (save-match-data (looking-at "#;"))
	      (+ (point) 2)
	    (point)))
      (scan-error (user-error "There isn't a complete s-expression before point")))))
#+end_src

*** Emacs-lisp
**** Eros
#+begin_src emacs-lisp
(straight-use-package 'eros)

(eros-mode 1)
#+end_src

**** Litable
;;(straight-use-package '(litable :type git :host github :repo "Fuco1/blablabla"))
(straight-use-package 'litable)
(require 'litable)

;; Eval everything
(defun litable--safe-eval (form)
  (eval form))

;; Make it only eval the parens around cursor
(defun litable-update-defs (&optional a b c)
  (litable-remove-overlays)
  (when a
    (ignore-errors
      (let ((form (save-excursion
                    (backward-up-list)
                    (sexp-at-point))))
        (litable-find-function-subs-arguments form)))))

***** Don't safe check
(defun litable--safe-eval (form)
(eval form))

**** Enable debugging on error
#+begin_src emacs-lisp
(setq debug-on-error nil)
#+end_src

**** Debugging

**** Suggest
#+begin_src emacs-lisp
(straight-use-package 'suggest)
#+end_src


**** Formatting
#+begin_src emacs-lisp
(straight-use-package 'elisp-format)
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/emacs-lisp-mode-map)
(evil-define-key 'normal emacs-lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/emacs-lisp-mode-map)

(define-key my/emacs-lisp-mode-map (kbd "d") 'find-function)
(define-key my/emacs-lisp-mode-map (kbd "D") 'find-variable)

(define-key my/emacs-lisp-mode-map (kbd "c") 'emacs-lisp-byte-compile)

(define-key my/emacs-lisp-mode-map (kbd "s") 'suggest)

(define-prefix-command 'my/emacs-lisp-formatting-map)
(define-key my/emacs-lisp-mode-map (kbd "f") 'my/emacs-lisp-formatting-map)

(define-key my/emacs-lisp-formatting-map (kbd "b") 'elisp-format-buffer)
(define-key my/emacs-lisp-formatting-map (kbd "r") 'elisp-format-region)
(define-key my/emacs-lisp-formatting-map (kbd "f") 'elisp-format-file)
(define-key my/emacs-lisp-formatting-map (kbd "C-d") 'elisp-format-directory)
#+end_src
Format marked files in dired
elisp-format-dired-mark-files


control
#+begin_src emacs-lisp
(define-key my/emacs-lisp-mode-map "n" 'edebug-step-mode)
#+end_src
(define-key my/emacs-lisp-mode-map "n" 'edebug-next-mode)

#+begin_src emacs-lisp
(define-key my/emacs-lisp-mode-map (kbd "s") 'edebug-go-mode)
(define-key my/emacs-lisp-mode-map "S" 'edebug-Go-nonstop-mode)
(define-key my/emacs-lisp-mode-map "t" 'edebug-trace-mode)
(define-key my/emacs-lisp-mode-map "T" 'edebug-Trace-fast-mode)

(define-key my/emacs-lisp-mode-map "g" 'edebug-goto-here)

(define-key my/emacs-lisp-mode-map "i" 'edebug-step-in)
(define-key my/emacs-lisp-mode-map "o" 'edebug-step-out)
#+end_src

*** Clojure
#+begin_src emacs-lisp
(straight-use-package 'clojure-mode)
(require 'clojure-mode)
#+end_src

**** Cider
#+begin_src emacs-lisp
(straight-use-package 'cider)
#+end_src

***** Enlighten
#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'cider-enlighten-mode)
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/clojure-mode-map)
(evil-define-key 'normal clojure-mode-map (kbd (concat my/leader-map-key " a")) 'my/clojure-mode-map)

(define-key my/clojure-mode-map (kbd "C-s") 'cider-connect)
#+end_src

** Java
Try
https://github.com/mopemope/meghanada-emacs
or
=ENSIME=
#+begin_src emacs-lisp
(straight-use-package 'lsp-java)
(require 'lsp-java)

(defun my/java-mode ()
  (lsp)
  (lsp-lens-mode))

(add-hook 'java-mode-hook 'my/java-mode)
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/java-mode-map)
(evil-define-key 'normal java-mode-map (kbd (concat my/leader-map-key " a")) 'my/java-mode-map)

(define-key my/java-mode-map (kbd "r") 'lsp-rename)
(define-key my/java-mode-map (kbd "C-r") 'lsp-workspace-restart)
(define-key my/java-mode-map (kbd "f") 'lsp-format-buffer)
(define-key my/java-mode-map (kbd "i") 'lsp-java-organize-imports)
(define-key my/java-mode-map (kbd "C-b") 'lsp-java-build-project)

(define-key my/java-mode-map (kbd "f") 'xref-find-references)
(define-key my/java-mode-map (kbd "a") 'xref-find-apropos)

(define-prefix-command 'my/java-refractor-map)
(define-key my/java-mode-map (kbd "R") 'my/java-refractor-map)

(define-key my/java-refractor-map (kbd "c") 'lsp-java-extract-to-constant)
(define-key my/java-refractor-map (kbd "u") 'lsp-java-add-unimplemented-methods)
(define-key my/java-refractor-map (kbd "p") 'lsp-java-create-parameter)
(define-key my/java-refractor-map (kbd "f") 'lsp-java-create-field)
(define-key my/java-refractor-map (kbd "l") 'lsp-java-create-local)
(define-key my/java-refractor-map (kbd "m") 'lsp-java-extract-method)
(define-key my/java-refractor-map (kbd "i") 'lsp-java-add-import)
#+end_src

** Python
*** Jedi
#+begin_src emacs-lisp
(straight-use-package 'company-jedi)

(add-to-list 'company-backends 'company-jedi)
#+end_src

** Haskell
#+begin_src emacs-lisp
(straight-use-package '(haskell-mode :type git :host github :repo "walseb/haskell-mode"))

(defun my/haskell-mode ()
  (interactive)
  (setq-local evil-shift-width 2))

(add-hook 'haskell-mode-hook 'my/haskell-mode)
#+end_src

*** haskell-interactive-mode
#+begin_src emacs-lisp
(add-hook 'haskell-mode-hook '(lambda () (add-hook 'after-save-hook 'haskell-process-load-file nil t)))
#+end_src

*** nix-haskell-mode
It's buggy for me
(straight-use-package 'nix-haskell-mode)
(require 'nix-haskell-mode)
(add-hook 'haskell-mode-hook 'nix-haskell-mode)

*** GHC flags
https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html?source=post_page---------------------------
https://medium.com/mercury-bank/enable-all-the-warnings-a0517bc081c3
#+begin_src emacs-lisp
(setq my/ghc-flags
      '(
	"-Weverything"
	"-Wincomplete-uni-patterns"
	"-Wincomplete-record-updates"

	;; Don't warn if prelude is implicitly imported
	;; "-Wimplicit-prelude"
	"-Wno-implicit-prelude"

	;; Dante disables this by default
	"-Wmissing-home-modules"

	"-Widentities"
	"-Wredundant-constraints"
	"-Wpartial-fields"

	;; Normally there is a warning on every non-annotated top-level function https://gitlab.haskell.org/ghc/ghc/issues/14794?source=post_page---------------------------#ticket
	"-Wno-missing-exported-signatures"

	;; Warns that you haven't defined an export list. Without an export list all functions in the file are accessible
	;; "-Wmissing-export-lists"
	"-Wno-missing-export-lists"

	;; Don't give warning when imports arent either qualified or imported using import lists
	"-Wno-missing-import-lists"

	;; "Don’t use Safe Haskell warnings"
	"-Wno-unsafe"
	;; "Don’t use Safe Haskell warnings"
	"-Wno-safe"
	;; "Warning for polymorphic local bindings; nothing wrong with those"
	"-Wno-missing-local-signatures"
	;; "Warn if the monomorphism restriction is used"
	"-Wmonomorphism-restriction"

	;; Warns if haskell has problems inlining
	"-Wall-missed-specialisations"

	"-Wcpp-undef"

	;; By default you get a warning when you don't include type signature when writing function, disable that
	"-Wno-missing-signatures"
	))

(defun my/cabal-ghc-flags-insert ()
  (interactive)
  (insert "ghc-options: ")
  (insert (mapconcat 'identity my/ghc-flags " ")))
#+end_src

*** Hoogle
**** Ivy
(straight-use-package '(ivy-hoogle :type git :host github :repo "sjsch/ivy-hoogle"))

#+begin_src emacs-lisp
(defvar my/ivy-hoogle-max-entries 100)

(defun my/ivy-hoogle--do-search (str)
  (let* ((args (concat
		"search "
		"-l "
		(and my/ivy-hoogle-max-entries (concat "-n " (int-to-string my/ivy-hoogle-max-entries))))))
    (message args)
    (counsel--async-command (format "hoogle %s \"%s\""
				    args
				    str))
    '("working...")))

(defun my/ivy-hoogle ()
  "Perform a hoogle search."
  (interactive)
  (ivy-read "Hoogle: "
	    #'my/ivy-hoogle--do-search
	    :dynamic-collection t
	    :preselect (symbol-at-point)
	    ;; :preselect (counsel-symbol-at-point)
	    :re-builder #'regexp-quote
	    :action (lambda (str)
		      (browse-url
		       (substring-no-properties str
						;; + 3 is to remove the "-- " from the string
						(+ (string-match "-- .*$" str) 3)
						(length str))))
	    :caller 'my/ivy-hoogle))
#+end_src

*** Haskell-doc
Haskell-doc kind of fills in the holes where lsp-haskell doesn't work

(setq haskell-doc-idle-delay 0)

(defun my/haskell-doc-mode ()
 (haskell-doc-mode 1))

(add-hook 'haskell-mode-hook 'my/haskell-doc-mode)

*** Project management
**** Stack
#+begin_src emacs-lisp
(straight-use-package 'hasky-stack)
#+end_src

**** Cabal
(straight-use-package 'hasky-cabal)

**** Nix cabal
Use nix-haskell-mode for automatic project management
(straight-use-package 'nix-haskell-mode)

*** Formatting
(setq haskell-stylish-on-save t)
#+begin_src emacs-lisp
(setq haskell-mode-stylish-haskell-path "brittany")
#+end_src

*** Extension management
#+begin_src emacs-lisp
(straight-use-package 'hasky-extensions)
#+end_src

*** Haskell-cabal
#+begin_src emacs-lisp
(straight-use-package 'company-cabal)
#+end_src

*** Fix lockup
This fixes a lockup that sometimes happens. I think this has to do with flycheck-mode
#+begin_src emacs-lisp
(add-hook 'haskell-mode-hook '(lambda ()
				;; Fixes lockups due to prettify-symbol I think
				(setq-local syntax-propertize-function nil)))
#+end_src

*** lsp-haskell
#+begin_src emacs-lisp
(when my/haskell-hie-enable
  ;; (straight-use-package 'lsp-haskell)
  (straight-use-package '(lsp-haskell :type git :host github :repo "walseb/lsp-haskell"))

  (require 'lsp-haskell)

  (defun my/haskell-lsp-mode ()
    ;; haskll-doc-mode is buggy if eldoc is on
    (setq-local lsp-eldoc-enable-hover nil)

    ;; (setq-local lsp-ui-flycheck-enable nil)

    ;; lsp-haskell doesn't work with native json
    ;; (setq-local lsp-use-native-json nil)

    (lsp)

    ;; Disable flycheck because errors are generated by haskell-interactive-mode anyways
    ;; (flycheck-disable-checker 'lsp-ui)
    (setq-local flycheck-checker 'haskell-ghc)

    ;; (setq-local flycheck-checkers (remove 'lsp-ui flycheck-checkers))
    )

  (add-hook 'haskell-mode-hook 'my/haskell-lsp-mode))
#+end_src

**** Make it start in nix-shell
#+begin_src emacs-lisp
(setq lsp-haskell-process-wrapper-function '(lambda (argv)
					      (append
					       (append (list "nix-shell" "-I" "." "--command" )
						       (list (mapconcat 'identity argv " ")))
					       (list (concat (lsp-haskell--get-root) "/shell.nix")))))
#+end_src
**** Hack in eldoc support
#+begin_src emacs-lisp
(when my/haskell-hie-enable
  (setq my/haskell-lsp-eldoc-entries '())

  ;; This function modifies what's displayed in lsp-ui-sideline. Here it is redefined so that it takes what's supposed to be displayed in the sideline, and instead sends it to an eldoc cache
  (defun lsp-ui-sideline--push-info (symbol tag bounds info bol eol)
    (when (and (= tag (lsp-ui-sideline--calculate-tag))
	       (not (lsp-ui-sideline--stop-p)))
      (let* ((info (concat (thread-first (gethash "contents" info)
			     lsp-ui-sideline--extract-info
			     lsp-ui-sideline--format-info)))
	     (current (and (>= (point) (car bounds)) (<= (point) (cdr bounds)))))
	(when (and (> (length info) 0)
		   (lsp-ui-sideline--check-duplicate symbol info))
	  (let* ((final-string (lsp-ui-sideline--make-display-string info symbol current))
		 (pos-ov (lsp-ui-sideline--find-line (length final-string) bol eol))
		 (ov (when pos-ov (make-overlay (car pos-ov) (car pos-ov)))))

	    ;; My changes:
	    (let ((final-string-formatted (substring-no-properties final-string)))
	      (add-to-list 'my/haskell-lsp-eldoc-entries final-string-formatted))

	    (when pos-ov
	      ;; (overlay-put ov 'info info)
	      ;; (overlay-put ov 'symbol symbol)
	      (overlay-put ov 'bounds bounds)
	      (overlay-put ov 'current current)
	      ;;(overlay-put ov 'after-string final-string)
	      (overlay-put ov 'window (get-buffer-window))
	      (overlay-put ov 'kind 'info)
	      (push ov lsp-ui-sideline--ovs)))))))

  (defun my/haskell-lsp-eldoc-print ()
    (interactive)
    (when my/haskell-lsp-eldoc-entries
      (let ((at-point (thing-at-point 'symbol t)))
	(when at-point
	  (let ((str (seq-find
		      (lambda (candidate)
			(let ((candidate-last-word (string-match (rx (not whitespace) (regexp "*") space eol) candidate)))
			  (if candidate-last-word
			      (progn
				(string=
				 (substring candidate candidate-last-word (- (length candidate) 1))
				 at-point))
			    nil)))
		      my/haskell-lsp-eldoc-entries)))

	    (if str
		(s-trim str)
	      nil))))))

  ;; No idea why but eldoc doesn't run the documentation function unless i press escape, this fixes that
  (add-hook 'haskell-mode-hook '(lambda ()
				  (eldoc-mode -1)
				  (setq-local eldoc-documentation-function 'my/haskell-lsp-eldoc-print)

				  (add-hook 'post-command-hook
					    'eldoc-print-current-symbol-info nil t))))
#+end_src

*** Dante
#+begin_src emacs-lisp
(setq my/haskell-dante-fix nil)

(when (not my/haskell-hie-enable)
  (setq dante-tap-type-time 0)

  (if my/haskell-dante-fix
      (straight-use-package '(dante :type git :host github :repo "purcell/dante" :branch "better-temp-files"))
    ;; (straight-use-package '(dante :type git :host github :repo "soupi/dante" :branch "with-temp-files"))
    (straight-use-package 'dante))

  (require 'dante)
  (add-hook 'haskell-mode-hook 'dante-mode)

  ;; **** Add more warnings
  (setq my/ghc-warning-parameters
	;; Dante disables this by default, so remove it
	(remove "-Wmissing-home-modules" my/ghc-flags))

  (setq dante-load-flags (append dante-load-flags my/ghc-warning-parameters)))
#+end_src

Remove duplicates if any
(setq dante-load-flags (remove-duplicates dante-load-flags :test 'string=))

**** Add hlint to dante
#+begin_src emacs-lisp
(when (not my/haskell-hie-enable)
  (add-hook 'dante-mode-hook
	    '(lambda () (flycheck-add-next-checker 'haskell-dante
						   '(warning . haskell-hlint)))))
#+end_src

**** Make dante not save all the time
#+begin_src emacs-lisp
(when (and (not my/haskell-dante-fix) (not my/haskell-hie-enable))
  (lcr-def dante-async-load-current-buffer (interpret)
    "Load and maybe INTERPRET the temp file for current buffer.
  Interpreting puts all symbols from the current module in
  scope. Compiling to avoids re-interpreting the dependencies over
  and over."
    (let* ((epoch (buffer-modified-tick))
	   (unchanged (equal epoch dante-temp-epoch))
	   (fname (buffer-file-name (current-buffer)))
	   (buffer (lcr-call dante-session))
	   (same-buffer (s-equals? (buffer-local-value 'dante-loaded-file buffer) fname)))
      (if (and unchanged same-buffer) (buffer-local-value 'dante-load-message buffer) ; see #52
	(setq dante-temp-epoch epoch)
	;; (vc-before-save)
	;; (basic-save-buffer-1) ;; save without re-triggering flycheck/flymake nor any save hook
	;; (vc-after-save)
	;; GHCi will interpret the buffer iff. both -fbyte-code and :l * are used.
	(lcr-call dante-async-call (if interpret ":set -fbyte-code" ":set -fobject-code"))
	(with-current-buffer buffer
	  (dante-async-write (if (and (not interpret) same-buffer) ":r"
			       (concat ":l " (if interpret "*" "") (dante-local-name fname))))
	  (cl-destructuring-bind (_status err-messages _loaded-modules) (lcr-call dante-load-loop "" nil)
	    (setq dante-loaded-file fname)
	    (setq dante-load-message err-messages))))))

  ;; ***** Fix flycheck
  ;; Sometimes ghci takes too long to get the results, have a hook that runs 1 second after save to hopefully catch the late error
  ;; Also disable idle-change since it should not be needed
  (add-hook 'dante-mode-hook '(lambda ()
				(add-hook 'after-save-hook
					  '(lambda ()
					     (run-with-timer 1 nil #'flycheck-buffer)) nil t)))
  (add-hook 'dante-mode-hook '(lambda ()
				(setq-local flycheck-check-syntax-automatically '(mode-enabled save idle-change))))

  ;; When hitting esc while in normal mode, refresh flycheck mode for when ghc is slow
  (evil-define-key 'normal dante-mode-map (kbd "<escape>") '(lambda () (interactive)
							      (flycheck-buffer)
							      (evil-force-normal-state))))
#+end_src

*** Flycheck
Remove flycheck stack-ghc since it freezes emacs without stack. Don't remove the standard ghc checker though, because it works fine if I don't have HIE. If I have HIE emacs should use that instead
#+begin_src emacs-lisp
(setq flycheck-checkers (remove 'haskell-stack-ghc flycheck-checkers))
#+end_src

(when my/haskell-hie-enable
(setq flycheck-checkers (remove 'haskell-ghc flycheck-checkers))
(setq flycheck-checkers (remove 'haskell-hlint flycheck-checkers)))

** C/CPP
*** Irony
(straight-use-package 'irony)

(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)

(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

**** Windows tweaks
Windows performance tweaks
(when (boundp 'w32-pipe-read-delay)
(setq w32-pipe-read-delay 0))
;; Set the buffer size to 64K on Windows (from the original 4K)
(when (boundp 'w32-pipe-buffer-size)
(setq irony-server-w32-pipe-buffer-size (* 64 1024)))

**** Flycheck-irony
(straight-use-package 'flycheck-irony)

(with-eval-after-load 'flycheck
  (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))

**** Company-irony
(straight-use-package 'company-irony)

(with-eval-after-load 'company
  (add-to-list 'company-backends 'company-irony))

**** Eldoc-irony
(straight-use-package 'irony-eldoc)

(add-hook 'irony-mode-hook #'irony-eldoc)

*** Elgot
(add-hook 'c-mode-hook 'eglot-ensure)
(add-hook 'c++-mode-hook 'eglot-ensure)
(add-hook 'objc-mode-hook 'eglot-ensure)

*** LSP CCLS
#+begin_src emacs-lisp
(straight-use-package 'ccls)
(require 'ccls)

(setq ccls-executable "/bin/ccls")

(defun my/c-mode ()
  (lsp)
  (lsp-lens-mode)
  (push 'company-lsp company-backends)

  (setq indent-tabs-mode t)
  (setq tab-width 4)
  (setq c-basic-offset 4)
  (setq-local evil-shift-width 4))

(add-hook 'c-mode-hook 'my/c-mode)
(add-hook 'c++-mode-hook 'my/c-mode)
(add-hook 'objc-mode-hook 'my/c-mode)
#+end_src

*** Cling
https://github.com/brianqq/inferior-cling
#+begin_src emacs-lisp
(defun my/cling (&optional flags)
  "Move to the buffer containing Cling, or create one if it does not exist. Defaults to C++11"
  (interactive)
  (let ((flags (or flags "-std=c++11")))
    (make-comint "inferior-cling" "cling" nil flags)
    (switch-to-buffer-other-window "*inferior-cling*")))

(defun my/cling-send-string (string &optional process)
  "Send a string terminated with a newline to the inferior-cling buffer. Has the effect of executing a command"
  (let ((process (or process (get-process "inferior-cling"))))
    (comint-send-string process string)
    (comint-send-string process "\n")))

(defun my/cling-send-region (start end)
  "Sends the region in the current buffer between `start` and `end` to the inferior-cling buffer. Sends the currently selected region when called interactively."
  (interactive "r")
  (my/cling-send-string (buffer-substring start end)))

(defun my/cling-send-buffer ()
  "Sends the current buffer to the inferior-cling buffer."
  (interactive)
  (my/cling-send-region (point-min) (point-max))) ;;do i want to wrap-raw this?

(defun my/cling-wrap-raw (string)
  "Wraps `string` in \".rawInput\", which tells Cling to accept function definitions"
  (format ".rawInput\n%s\n.rawInput" string))

(defun my/cling-wrap-region-and-send (start end)
  "Sends the region between start and end (currently selected when called interactively) to cling in raw input mode "
  (interactive "r")
  (my/cling-send-string (my/cling-wrap-raw (buffer-substring start end))))

(defun my/flatten-function-def ()
  "Flattens a function definition into a single line. This makes it easier to send to the inferior-cling buffer"
  (interactive)
  (replace-regexp "
   " "" nil (mark) (point))) ;;;Why did I do this again?

(defun my/select-defun ()
  "Selects the defun containing the point. Currently only works when point is on the line where the function's name is declared."
  (interactive)
  (move-beginning-of-line nil)
  (push-mark (point))
  (re-search-forward "{")
  (save-excursion
    (my/flatten-function-def))
  (backward-char)
  (forward-sexp))

(defun my/cling-wrap-defun-and-send ()
  "Sends the current defun to cling in raw input mode. Currently only works when point is on the first line of function definition."
  (interactive)
  (save-excursion
    (my/select-defun)
    (my/cling-wrap-region-and-send (mark) (point))
    (undo)
    (undo)));;;this is a rather leaky way of doing temporary changes. there should be some way to save buffer contents or something
   ;;;probably uses with-temp-buffer
#+end_src

*** Etags
(straight-use-package 'etags)
(straight-use-package 'counsel-etags)

*** Rtags


*** Debugging
(require 'gdb-mi)

*** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/c-mode-map)

(evil-define-key 'normal c-mode-map (kbd (concat my/leader-map-key " a")) 'my/c-mode-map)
(evil-define-key 'normal c++-mode-map (kbd (concat my/leader-map-key " a")) 'my/c-mode-map)

(define-key my/c-mode-map (kbd "e") 'cling)

(define-key my/c-mode-map (kbd "n") 'gud-step)
(define-key my/c-mode-map (kbd "N") 'gud-next)

(define-key my/c-mode-map (kbd "p") 'gud-print)
(define-key my/c-mode-map (kbd "P") 'gud-pstar)

(define-key my/c-mode-map (kbd "s") 'gud-go)
#+end_src

Run to selected line
#+begin_src emacs-lisp
(define-key my/c-mode-map (kbd "g") 'gud-until)
#+end_src

Run out of function
#+begin_src emacs-lisp
(define-key my/c-mode-map (kbd "f") 'gud-finish)

(define-key my/c-mode-map (kbd "v") 'gdb-display-locals-buffer)
(define-key my/c-mode-map (kbd "V") 'gdb-display-locals-for-thread)

(define-key my/c-mode-map (kbd "b") 'gdb-display-breakpoints-buffer)
#+end_src

*** Auto view documentation
#+begin_src emacs-lisp
(defun my/auto-view-docs ()
  (interactive)
  (pcase major-mode
    ('csharp-mode (omnisharp-current-type-documentation))
    ;;('haskell-mode (call-interactively 'dante-info))
    (_
     (if lsp-mode
	 (lsp-describe-thing-at-point)
       (find-function-at-point)))))

(define-key my/leader-map (kbd "d") 'my/auto-view-docs)
#+end_src

*** Auto rename
#+begin_src emacs-lisp
(defun my/auto-rename ()
  (interactive)
  (pcase major-mode
    ('csharp-mode (omnisharp-rename))
    (_ (find-function-at-point))))

(define-key my/leader-map (kbd "R") 'my/auto-rename)
#+end_src

*** Auto format
#+begin_src emacs-lisp
(defun my/auto-format-buffer ()
  (interactive)
  (if (string= evil-state 'visual)
      (my/auto-format-region)
    (pcase major-mode
      ('csharp-mode (omnisharp-code-format-entire-file))
      ('nix-mode (nix-mode-format))
      ('haskell-mode (haskell-mode-stylish-buffer))
      (_ ()))))

(defun my/auto-format-region ()
  (interactive)
  (pcase major-mode
    ('csharp-mode (omnisharp-code-format-region))
    ('emacs-lisp-mode (elisp-format-region))
    (_ ())))

(define-key my/leader-map (kbd "<") 'my/auto-format-buffer)
(define-key my/leader-map (kbd ">") 'my/auto-format-buffer)
#+end_src

** C#
#+begin_src emacs-lisp
(straight-use-package 'csharp-mode)
#+end_src

csharp-maybe-insert-codedoc
#+begin_src emacs-lisp
(setq csharp-mode-map (make-sparse-keymap))
#+end_src

*** REPL
#+begin_src emacs-lisp
(defun my/csharp-run-repl()
  (interactive)
  (eshell)
  (insert "csharp")
  (eshell-send-input))
#+end_src

*** Omnisharp-emacs
#+begin_src emacs-lisp
(straight-use-package 'omnisharp)
#+end_src

(add-hook 'csharp-mode-hook (lambda () (push 'company-omnisharp company-backends)))

#+begin_src emacs-lisp
(with-eval-after-load 'company
  (add-to-list 'company-backends #'company-omnisharp))
#+end_src

This hack fixes omnisharp on arch linux
Read https://github.com/OmniSharp/omnisharp-emacs/issues/459
#+begin_src emacs-lisp
(if (eq system-type 'gnu/linux)
    (let ((dotnet-version (string-trim (shell-command-to-string "dotnet --version")))) (setenv "MSBuildSDKsPath" (format "/opt/dotnet/sdk/%s/Sdks" dotnet-version))))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/csharp-mode-map)
(evil-define-key 'normal csharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/csharp-mode-map)

(define-key my/csharp-mode-map (kbd "r") 'omnisharp-run-code-action-refactoring)
(define-key my/csharp-mode-map (kbd "S") 'omnisharp-reload-solution)
(define-key my/csharp-mode-map (kbd "u") 'omnisharp-fix-usings)
(define-key my/csharp-mode-map (kbd "i") 'omnisharp-find-implementations)
(define-key my/csharp-mode-map (kbd "e") 'omnisharp-solution-errors)
(define-key my/csharp-mode-map (kbd "o") 'omnisharp-show-overloads-at-point)

(define-key my/csharp-mode-map (kbd "g") 'omnisharp-navigate-to-solution-file)
#+end_src

**** Write formatting settings to omnisharp server config
omnisharp.json should be in ~/.omnisharp on all OSs
if(not(file-directory-p "~/.omnisharp")
    (make-directory "~/.omnisharp"))

(if(not(file-exists-p "~/.omnisharp/omnisharp.json"))
    (progn
      (write-region "
        {
            \"formattingOptions\": {
                PUT OPTIONS HERE
            }
        }
       " nil "~/.omnisharp/omnisharp.json")

      (message "~/.omnisharp/omnisharp.json created")
      )
  )

*** My csharp mode
#+begin_src emacs-lisp
(defun my/csharp-mode ()
  (omnisharp-mode)
  (company-mode)
  (flycheck-mode)

  (setq indent-tabs-mode nil)
  (setq c-syntactic-indentation t)
  (c-set-style "ellemtel")
  (setq c-basic-offset 4)
  (setq tab-width 4)
  (setq evil-shift-width-local 4))

(add-hook 'csharp-mode-hook 'my/csharp-mode)
#+end_src

** F#
#+begin_src emacs-lisp
(straight-use-package 'fsharp-mode)
#+end_src

:mode ("\\.fs\\'" . fsharp-mode)
#+begin_src emacs-lisp
(setq fsharp-doc-idle-delay 0)
#+end_src

(setq-default fsharp-indent-offset 2)

*** Keys
#+begin_src emacs-lisp
(add-hook 'fsharp-mode-hook 'my/fsharp-keys-init)

(define-prefix-command 'my/fsharp-mode-map)

(defun my/fsharp-keys-init()
  (interactive)
  (evil-define-key 'normal fsharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/fsharp-mode-map))

(define-key my/fsharp-mode-map (kbd "v") 'fsharp-mark-phrase)
(define-key my/fsharp-mode-map (kbd "b") 'fsharp-goto-block-up)
(define-key my/fsharp-mode-map (kbd "C-r") 'fsharp-ac-status)
(define-key my/fsharp-mode-map (kbd "C-k") 'fsharp-ac/stop-process)
(define-key my/fsharp-mode-map (kbd "C-s") 'fsharp-ac/start-process)
#+end_src

*** Settings
#+begin_src emacs-lisp
(defun my/fsharp-mode()
  ;; Fsharp has built in intellisense highlight thing at point
  (symbol-overlay-mode -1)
  ;; Visual line mode in fsharp mode is broken, makes swiper take years to start, use truncate lines mode instead
  ;;(visual-line-mode 0)
  )
#+end_src

Autostart
#+begin_src emacs-lisp
(add-hook 'fsharp-mode-hook 'my/fsharp-mode)
#+end_src

** Markdown
#+begin_src emacs-lisp
(straight-use-package 'markdown-mode)
#+end_src

** Web mode
TODO: Fix settings, grab them from package site
#+begin_src emacs-lisp
(straight-use-package 'web-mode)

(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+end_src
Messes with .cs files???
(add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.xml?\\'" . web-mode))
#+end_src

*** Debugger
#+begin_src emacs-lisp
(straight-use-package 'dap-mode)
#+end_src

* Macros
(define-prefix-command 'my/macro-map)

(define-key my/leader-map (kbd "q") 'my/macro-map)

** Macro manager
#+begin_src emacs-lisp
(defvar my/current-macro-number 0)
(defvar my/macro-store '())
(defvar my/macro-last-name nil)

(defun my/macro-record-toggle ()
  (interactive)
  (if defining-kbd-macro
      (my/macro-record-stop)
    (call-interactively #'start-kbd-macro)))

(defun my/macro-record-stop ()
  (interactive)
  (call-interactively #'end-kbd-macro)
  (let
      ((macro-name (completing-read "Name macro: " nil nil nil "macro-")))
    (name-last-kbd-macro (intern macro-name))
    (add-to-list 'my/macro-store macro-name)))

(defun my/macro-run (&optional count)
  "COUNT is a repeat count, or nil for once, or 0 for infinite loop."
  (interactive "P")
  (let ((to-run (completing-read "Run macro: " my/macro-store)))
    ;; (funcall (symbol-function (intern to-run)))))
    ;; (execute-kbd-macro (intern macro-test)) (intern "macro-test")) count)))
    (execute-kbd-macro (symbol-function (intern to-run)) count)))

(defun my/macro-modify (&optional prefix)
  (interactive "P")
  (let
      ((chosen-macro (completing-read "Modify macro: " my/macro-store)))
    ;; Just simulate the keypresses collected
    (setq unread-command-events (listify-key-sequence (concat chosen-macro "\C-a")))
    ;;            Anything other than this and nil is not accepted it seems
    (edit-kbd-macro 'execute-extended-command prefix)))
#+end_src

*** Evil operator
#+begin_src emacs-lisp
(evil-define-operator evil-macro-run (beg end type)
  "Run macro on BEG to END."
  (interactive "<R>")
  (evil-normal-state)
  (save-restriction
    (goto-char (point-min))
    (narrow-to-region beg end)
    (my/macro-run 0)))
#+end_src

*** Keys
#+begin_src emacs-lisp
(my/evil-normal-define-key "q" 'my/macro-record-toggle)
(my/evil-visual-define-key "q" 'my/macro-record-toggle)

(my/evil-normal-define-key "Q" 'evil-macro-run)
(my/evil-visual-define-key "Q" 'evil-macro-run)

(my/evil-normal-define-key "C-q" 'my/macro-modify)
(my/evil-visual-define-key "C-q" 'my/macro-modify)
#+end_src

** Simple search
Search useful for making macros because it's fast
But is it really faster than isearch?
(defvar my/last-search)
(defun my/search-forward ()
 (interactive)
 (setq my/last-search (completing-read "Search: " nil))
 (search-forward-regexp my/last-search))

(defun my/search-backward ()
 (interactive)
 (setq my/last-search (completing-read "Search: " nil))
 (search-backward-regexp my/last-search))

(defun my/repeat-search-forward ()
 (interactive)
 (search-forward-regexp my/last-search))

(defun my/repeat-search-backward ()
 (interactive)
 (search-backward-regexp my/last-search))

(my/evil-normal-define-key "/" 'my/search-forward)
(my/evil-visual-define-key "/" 'my/search-forward)

(my/evil-normal-define-key "?" 'my/search-backward)
(my/evil-visual-define-key "?" 'my/search-backward)

(my/evil-normal-define-key "j" 'my/repeat-search-forward)
(my/evil-visual-define-key "j" 'my/repeat-search-forward)

(my/evil-normal-define-key "J" 'my/repeat-search-backward)
(my/evil-visual-define-key "J" 'my/repeat-search-backward)

** Elmacro
Elmacro doesn't work with evil
(straight-use-package 'elmacro)
(require 'elmacro)

(define-globalized-minor-mode my/elmacro-global-mode elmacro-mode
(lambda ()
(elmacro-mode 1)))

(my/elmacro-global-mode 1)

*** Macro mechanisms
(defun my/get-interactive-commands ()
(let ((cmds  ()))
(mapatoms (lambda (s) (when (commandp s) (push s cmds))))
cmds))

(defvar my/current-macro-name "")
(defvar my/current-macro-number 0)

(defun my/macro-record-toggle ()
(interactive)
(if elmacro-mode
(my/macro-record-stop)
(my/macro-record)))

(defun my/macro-record ()
(setq my/current-macro-number (+ my/current-macro-number 1))
(setq my/current-macro-name (concat "my/rec-macro-" (number-to-string my/current-macro-number) "-" (completing-read "Macro name: " nil)))
(elmacro-mode 1)
(call-interactively 'kmacro-start-macro-or-insert-counter))

(defun my/macro-record-stop ()
(call-interactively 'kmacro-end-or-call-macro)
(elmacro-show-last-macro my/current-macro-name)
(elmacro-mode -1)
(eval-buffer)
)

(defun my/macro-run()
(interactive)
(call-interactively
(intern (ivy-read "Macros: " (reverse (sort (my/get-interactive-commands) 'string-lessp))
:initial-input "^my/rec-macro- "))))

Get thing
(call-interactively  (intern "counsel-M-x"))

(my/evil-normal-define-key "q" 'my/macro-record-toggle)
(my/evil-normal-define-key "Q" 'my/macro-run)

(my/evil-visual-define-key "q" 'my/macro-record-toggle)
(my/evil-visual-define-key "Q" 'my/macro-run)

* Encryption
** GPG
*** Pinentry
#+begin_src emacs-lisp
(straight-use-package 'pinentry)

(if window-system
    (add-hook 'exwm-init-hook 'pinentry-start)
  (pinentry-start))
#+end_src

*** Reset GPG agent
#+begin_src emacs-lisp
(defun my/reset-gpg-agent ()
  (interactive)
  (shell-command "gpgconf --kill gpg-agent")
  (pinentry-stop)
  (pinentry-start))
#+end_src

** Passwords
Enable org mode for .org.gpg files
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org.gpg\\'" . org-mode))
#+end_src

*** Espy
#+begin_src emacs-lisp
(straight-use-package 'espy)

(setq espy-password-file "~/pass.org.gpg")

(define-prefix-command 'my/password-map)
(define-key my/leader-map (kbd "p") 'my/password-map)

(define-key my/password-map (kbd "r") 'my/reset-gpg-agent)
(define-key my/password-map (kbd "u") 'espy-get-user)
(define-key my/password-map (kbd "p") 'espy-get-pass)
#+end_src

*** Auto-clean kill ring
(defvar my/pass-in-killring nil)

(defun my/ivy-pass ()
(interactive)
(setq my/pass-in-killring t)
(ivy-pass))

(defun my/pass-pop-killring ()
(if (eq my/pass-in-killring t)
(progn
(progn (pop kill-ring)
(message "Password removed"))
(setq my/pass-in-killring nil))))

#+begin_src emacs-lisp
(defun my/pop-killring ()
  (pop kill-ring)
  (setq my/pass-in-killring nil))

(define-key my/leader-map (kbd "C-k") 'my/pop-killring)
#+end_src
(advice-add 'evil-goggles--paste-advice :before (lambda () (interactive) (my/pass-pop-killring)))
(advice-add 'evil-goggles--paste-advice :before
(advice-add 'evil-paste-after :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
(advice-add 'evil-paste-before :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))

* Terminal
** Set max lines to a lot
#+begin_src emacs-lisp
(setq term-buffer-maximum-size 10000)
#+end_src

** Disable line wrapping
#+begin_src emacs-lisp
(add-hook 'term-mode-hook (lambda () (interactive) (visual-line-mode -1)
			    (setq truncate-lines t)))
#+end_src

*** Keys
(my/evil-universal-define-key-in-mode 'term-raw-map "C-," 'term-char-mode)

* Eshell
 https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org
#+begin_src emacs-lisp
(require 'eshell)
#+end_src
Change to temporary name before renaming. This has to be unique. If it isn't the buffer with the same name will get its major mode changed to eshell
#+begin_src emacs-lisp
(setq eshell-buffer-name "*eshell-temp-name*")

(setq-default eshell-status-in-mode-line nil)

(defun my/eshell ()
  (interactive)
  (eshell)
  (my/give-buffer-unique-name "*eshell*"))
#+end_src

** Allow to delete prompt
#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook '(lambda () (setq-local inhibit-read-only t)))
#+end_src

** History
#+begin_src emacs-lisp
(setq eshell-highlight-prompt t)
(setq eshell-hist-ignoredups t)
(setq eshell-history-size 10000)
#+end_src

*** Clean history
#+begin_src emacs-lisp
(with-eval-after-load 'em-hist
  (let ((content (shell-command-to-string (concat "cat " eshell-history-file-name " | awk '{$1=$1};1' | sort | uniq"))))
    (write-region content nil eshell-history-file-name)))
#+end_src

*** Append history
https://emacs.stackexchange.com/questions/18564/merge-history-from-multiple-eshells
#+begin_src emacs-lisp
(setq eshell-save-history-on-exit nil)

(defun eshell-append-history ()
  "Call `eshell-write-history' with the `append' parameter set to `t'."
  (when eshell-history-ring
    (let ((newest-cmd-ring (make-ring 1)))
      (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
      (let ((eshell-history-ring newest-cmd-ring))
	(eshell-write-history eshell-history-file-name t)))))

(add-hook 'eshell-pre-command-hook #'eshell-append-history)

(add-hook 'eshell-mode-hook '(lambda () (interactive) (setq eshell-exit-hook (remove 'eshell-write-history eshell-exit-hook))))
#+end_src

** Prefer lisp to bash
#+begin_src emacs-lisp
(setq eshell-prefer-lisp-functions nil)
(setq eshell-prefer-lisp-variables nil)
#+end_src

** Use tramp for sudo
(require 'em-tramp)
(defalias 'sudo 'eshell/sudo)

** Autocompletion
(defun company-eshell-history (command &optional arg &rest ignored)
(interactive (list 'interactive))
(cl-case command
(interactive (company-begin-backend 'company-eshell-history))
(prefix (and (eq major-mode 'eshell-mode)
(let ((word (company-grab-word)))
(save-excursion
(eshell-bol)
(and (looking-at-p (s-concat word "$")) word)))))
(candidates (remove-duplicates
(->> (ring-elements eshell-history-ring)
(remove-if-not (lambda (item) (s-prefix-p arg item)))
(mapcar 's-trim))
:test 'string=))
(sorted t)))

(add-to-list 'company-backends 'company-eshell-history)

** Eldoc
*** Eshell-eldoc
(straight-use-package '(eshell-eldoc :type git :host github :repo "defaultxr/eshell-eldoc"))
(add-hook 'eshell-mode-hook 'eshell-eldoc-enable-for-buffer)

*** Eshell-help
(straight-use-package 'esh-help)
#+begin_src emacs-lisp
(straight-use-package '(esh-help :type git :host github :repo "defaultxr/esh-help"))

(require 'esh-help)
(setup-esh-help-eldoc)
#+end_src

** Did you mean
(straight-use-package 'eshell-did-you-mean)

(require 'eshell-did-you-mean)
(eshell-did-you-mean-setup)

** Aliases
#+begin_src emacs-lisp
(defun eshell/f (file)
  (find-file file))
#+end_src

** Clear
Default eshell/clear only spams newlines
#+begin_src emacs-lisp
(defun eshell/clear ()
  "Clear the eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)
    ;; Probably not needed
    ;;(eshell-send-input)
    ))
#+end_src

** Term
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "{") 'ansi-term)
#+end_src

** Use ansi term for certain applications
#+begin_src emacs-lisp
(require 'em-term)
(add-to-list 'eshell-visual-commands "vim")
(add-to-list 'eshell-visual-commands "wifi-menu")
(add-to-list 'eshell-visual-commands "htop")

(setq eshell-visual-subcommands
      '(("git" "log" "diff" "show")
	("sudo" "wifi-menu")
	("sudo" "htop")
	("sudo" "vi" "visudo")))
#+end_src

** Remove banner
#+begin_src emacs-lisp
(setq eshell-banner-message "")
#+end_src

** Custom prompt
#+begin_src emacs-lisp
(defvar my/eshell-prompt-symbol)
(if window-system
    (setq my/eshell-prompt-symbol "λ")
  (setq my/eshell-prompt-symbol "$"))

(setq eshell-prompt-function
      (lambda ()
	(concat (abbreviate-file-name (eshell/pwd))
		(if (= (user-uid) 0) " # " (concat " " my/eshell-prompt-symbol " ")))))

(setq eshell-prompt-regexp
      (concat "^[^#$\n]* [#" my/eshell-prompt-symbol "] "))
#+end_src

** Alert when task is done
#+begin_src emacs-lisp
(add-hook 'eshell-post-command-hook (lambda () (interactive)
				      (if (not (= 1 (line-number-at-pos (point))))
					  (progn
					    (my/alert nil 'low)
					    (message "Eshell command done!")))))
#+end_src

** Custom Goto beg of line
#+begin_src emacs-lisp
(defun my/eshell-goto-beg-of-line ()
  (interactive)
  (let ((start-point (point)))
    (if (and
	 (re-search-backward my/eshell-prompt-symbol nil t) (= (line-number-at-pos) (line-number-at-pos start-point)))
	(evil-forward-char 2)
      (goto-char start-point)
      (evil-digit-argument-or-evil-beginning-of-line))))
#+end_src

** With-editor
#+begin_src emacs-lisp
(straight-use-package 'with-editor)

(add-hook 'eshell-mode-hook '(lambda ()
			       (with-editor-export-editor)
			       ;; Clear echo area to remove annoying messages. A problem with this is that it also hides error messages
			       (message nil)))
#+end_src

** Keys
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "[") 'my/eshell)
#+end_src

Eshell keys are buffer local... Bind them on startup
#+begin_src emacs-lisp
(defun my/bind-eshell-keys ()
  (define-prefix-command 'my/eshell-mode-map)
  (evil-define-key 'normal eshell-mode-map (kbd (concat my/leader-map-key " a")) 'my/eshell-mode-map)

  (evil-define-key 'normal eshell-mode-map (kbd "RET") 'eshell-send-input)
  (define-key eshell-mode-map [remap evil-ret] 'eshell-send-input)

  (define-key my/eshell-mode-map (kbd "k") 'counsel-esh-history)

  (evil-define-key 'normal eshell-mode-map (kbd "0") 'my/eshell-goto-beg-of-line)

  (evil-define-key '(normal insert visual replace) eshell-mode-map (kbd "C-c") '(lambda () (interactive) (insert "") (call-interactively 'eshell-send-input)))
  ;;(evil-define-key '(normal insert visual replace) eshell-mode-map (kbd "C-x") 'eshell-interrupt-process)
  (evil-define-key '(normal insert visual replace) eshell-mode-map (kbd "C-z") 'eshell-kill-process)

  (evil-define-key '(normal insert) eshell-mode-map (kbd "C-p") 'eshell-previous-matching-input-from-input)
  (evil-define-key '(normal insert) eshell-mode-map (kbd "C-n") 'eshell-next-matching-input-from-input)

  (evil-define-key '(normal insert) eshell-mode-map (kbd "TAB") 'completion-at-point))

(add-hook 'eshell-mode-hook 'my/bind-eshell-keys)
#+end_src

* Keyboard layouts
** Carpalx
#+begin_src emacs-lisp
(defun my/carpalx-enable ()
  (interactive)
  (async-shell-command "setxkbmap -I ~/.emacs.d/configs/kbd-layouts/ carpalx.xkb -print | xkbcomp -I/home/admin/.emacs.d/configs/kbd-layouts/ - $DISPLAY"))

(when my/carpalx-enable
  (my/carpalx-enable))
#+end_src

* Keys
** Key rebinds
#+begin_src emacs-lisp
(require 'evil-maps)
#+end_src

*** General
#+begin_src emacs-lisp
(straight-use-package 'general)

(general-evil-setup)
#+end_src

*** Language specific symbols
**** Lower
(my/evil-emacs-define-key "M-p" '(lambda () (interactive) (my/exwm-fake-key "å")))
(my/evil-emacs-define-key "M-," '(lambda () (interactive) (my/exwm-fake-key "ä")))
(my/evil-emacs-define-key "M-." '(lambda () (interactive) (my/exwm-fake-key "ö")))

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "M-p") (kbd "å"))
(define-key key-translation-map (kbd "M-,") (kbd "ä"))
(define-key key-translation-map (kbd "M-.") (kbd "ö"))
#+end_src

**** Capital
(my/evil-emacs-define-key "M-P" '(lambda () (interactive) (my/exwm-fake-key ?Å)))
(my/evil-emacs-define-key "M-<" '(lambda () (interactive) (my/exwm-fake-key ?Ä)))
(my/evil-emacs-define-key "M->" '(lambda () (interactive) (my/exwm-fake-key ?Ö)))

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "M-P") (kbd "Å"))
(define-key key-translation-map (kbd "M-<") (kbd "Ä"))
(define-key key-translation-map (kbd "M->") (kbd "Ö"))
#+end_src

*** Rebind backspace with C-f
127 is backspace
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-f") [127])
#+end_src
There are 2 unbinds here for compatibility
#+begin_src emacs-lisp
(define-key key-translation-map [127] (kbd "C-="))
(define-key key-translation-map (kbd "<backspace>") (kbd "C-="))
#+end_src

Don't split up tabs on delete
(global-set-key (kbd "DEL") 'backward-delete-char)

*** Rebind delete with
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-l") (kbd "<deletechar>"))
#+end_src
There are 2 unbinds here for compatibility
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "<deletechar>") (kbd "C-="))
(define-key key-translation-map (kbd "<delete>") (kbd "C-="))
#+end_src

*** k(Move up) <--> p(Paste)
**** k
#+begin_src emacs-lisp
(my/evil-normal-define-key "k" 'evil-paste-after)
(my/evil-normal-define-key "K" 'evil-paste-before)

(define-key evil-visual-state-map "k" 'evil-visual-paste)
#+end_src

Universal paste key
#+begin_src emacs-lisp
(global-set-key (kbd "C-k") 'evil-paste-after)
(global-set-key (kbd "C-K") 'evil-paste-before)
(define-key evil-insert-state-map (kbd "C-k") 'evil-paste-after)
(define-key evil-insert-state-map (kbd "C-K") 'evil-paste-before)

(define-key evil-window-map "k" 'evil-window-mru)
#+end_src

**** p
#+begin_src emacs-lisp
(define-key evil-window-map "p" 'evil-window-up)
(define-key evil-window-map "P" 'evil-window-move-very-top)

(my/evil-normal-define-key "p" 'evil-previous-line)
#+end_src

Rebind to make consistent with N
#+begin_src emacs-lisp
(my/evil-normal-define-key "P" 'delete-indentation)

(define-key evil-window-map (kbd "C-S-p") 'evil-window-move-very-top)
#+end_src

*** n(search-next) <--> j(Move up)
**** n
#+begin_src emacs-lisp
(my/evil-normal-define-key "n" 'evil-next-line)

(my/evil-normal-define-key "N" 'evil-join)
#+end_src

ex
 (evil-ex-define-cmd "j[oin]" 'evil-ex-join)
 (evil-ex-define-cmd "ju[mps]" 'evil-show-jumps)

#+begin_src emacs-lisp
(define-key evil-window-map (kbd "C-S-n") 'evil-window-move-very-bottom)
#+end_src

**** j
(my/evil-normal-define-key "j" 'evil-search-next)
(my/evil-normal-define-key "J" 'evil-search-previous)

(my/evil-normal-define-key "j" 'isearch-repeat-forward)
(my/evil-normal-define-key "J" 'isearch-repeat-backward)

ex
(evil-ex-define-cmd "new" 'evil-window-new)
(evil-ex-define-cmd "norm[al]" 'evil-ex-normal)
(evil-ex-define-cmd "noh[lsearch]" 'evil-ex-nohighlight)

#+begin_src emacs-lisp
(my/evil-normal-define-key "gj" 'evil-next-match)
(my/evil-normal-define-key "gJ" 'evil-previous-match)
#+end_src

*** Rebind search key
(my/evil-normal-define-key "s" 'my/avy-goto-subword-0-below)
(my/evil-normal-define-key "S" 'my/avy-goto-subword-0-above)

(my/evil-visual-define-key "s" 'my/avy-goto-subword-0-below)
(my/evil-visual-define-key "S" 'my/avy-goto-subword-0-above)

#+begin_src emacs-lisp
(my/evil-normal-define-key "s" 'my/isearch-forward-regexp)
(my/evil-normal-define-key "S" 'my/isearch-backward-regexp)

(my/evil-visual-define-key "s" 'my/isearch-forward-regexp)
(my/evil-visual-define-key "S" 'my/isearch-backward-regexp)

(defun my/isearch-repeat-forward-with-cleanup ()
  (interactive)
  (call-interactively 'isearch-repeat-forward)
  ;;(run-with-idle-timer 1 nil 'lazy-highlight-cleanup)
  (run-with-idle-timer 1 nil 'isearch-done))

(defun my/isearch-repeat-backward-with-cleanup ()
  (interactive)
  (call-interactively 'isearch-repeat-backward)
  (run-with-idle-timer 1 nil 'isearch-done))

(my/evil-normal-define-key "g n" 'my/isearch-repeat-forward-with-cleanup)
(my/evil-normal-define-key "g p" 'my/isearch-repeat-backward-with-cleanup)

(my/evil-visual-define-key "g n" 'my/isearch-repeat-forward-with-cleanup)
(my/evil-visual-define-key "g p" 'my/isearch-repeat-backward-with-cleanup)
#+end_src

(my/evil-normal-define-key "/" 'evil-substitute)
(my/evil-normal-define-key "?" 'evil-change-whole-line)

(define-key evil-visual-state-map "/" 'evil-substitute)
(define-key evil-visual-state-map "?" 'evil-change-whole-line)

*** Rebind save key
(defun my/save-and-backup-buffer()
(interactive)
(my/backup-buffer)
(my/fake-open-keymap "C-x")
(my/fake-key (kbd "C-s") ?\C-s)
)

#+begin_src emacs-lisp
(general-simulate-key "C-x C-s")

(defun my/save-and-backup-buffer()
  (interactive)
  (my/backup-buffer-per-session)
  (my/backup-original-buffer)
  (general-simulate-C-x_C-s))

(define-key my/leader-map (kbd "s") 'my/save-and-backup-buffer)
(define-key my/leader-map (kbd "C-s") 'write-file)
#+end_src

*** Rebind C-d
#+begin_src emacs-lisp
(my/evil-normal-define-key "C-d" nil)
#+end_src

*** Rebind esc
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "<escape>") (kbd "C-e"))
(define-key key-translation-map (kbd "C-e") (kbd "<escape>"))
#+end_src

*** Rebind enter
 (define-key key-translation-map (kbd "RET") (kbd "C-a"))
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "C-a") (kbd "RET"))
#+end_src

*** Rebind tab
(define-key my/keys-mode-map (kbd "C-e") 'my/simulate-esc)
(define-key key-translation-map (kbd "?\\t") (kbd "C-="))

If window system, unbind tab key and not C-=

#+begin_src emacs-lisp
(define-key key-translation-map (kbd "TAB") (kbd "C-="))
(define-key key-translation-map (kbd "<tab>") (kbd "C-="))
(define-key key-translation-map (kbd "C-t") (kbd "TAB"))
(define-key key-translation-map (kbd "M-C-t") (kbd "C-TAB"))
#+end_src

(when window-system
 (define-key key-translation-map (kbd "TAB") (kbd "C--"))
 (define-key key-translation-map (kbd "<tab>") (kbd "C--"))

 (define-key key-translation-map (kbd "C-i") (kbd "C-~")))

*** Disable backspace
(define-key key-translation-map (kbd "C-e") (kbd "TAB"))
(define-key key-translation-map (kbd "M-C-i") (kbd "C-TAB"))

*** Rebind number row
**** Numbers
***** Disable number row
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "1") (kbd "C-="))
(define-key key-translation-map (kbd "2") (kbd "C-="))
(define-key key-translation-map (kbd "3") (kbd "C-="))
(define-key key-translation-map (kbd "4") (kbd "C-="))
(define-key key-translation-map (kbd "5") (kbd "C-="))
(define-key key-translation-map (kbd "6") (kbd "C-="))
(define-key key-translation-map (kbd "7") (kbd "C-="))
(define-key key-translation-map (kbd "8") (kbd "C-="))
(define-key key-translation-map (kbd "9") (kbd "C-="))
(define-key key-translation-map (kbd "0") (kbd "C-="))
#+end_src

***** Set new number row
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "M-d") (kbd "1"))
(define-key key-translation-map (kbd "M-s") (kbd "2"))
(define-key key-translation-map (kbd "M-t") (kbd "3"))
(define-key key-translation-map (kbd "M-n") (kbd "4"))
(define-key key-translation-map (kbd "M-r") (kbd "5"))
(define-key key-translation-map (kbd "M-i") (kbd "6"))
(define-key key-translation-map (kbd "M-a") (kbd "7"))
(define-key key-translation-map (kbd "M-e") (kbd "8"))
(define-key key-translation-map (kbd "M-o") (kbd "9"))
(define-key key-translation-map (kbd "M-h") (kbd "0"))
#+end_src

**** Symbols
***** Disable symbol keys
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "!") (kbd "C-="))
(define-key key-translation-map (kbd "@") (kbd "C-="))
(define-key key-translation-map (kbd "#") (kbd "C-="))
(define-key key-translation-map (kbd "$") (kbd "C-="))
(define-key key-translation-map (kbd "%") (kbd "C-="))
(define-key key-translation-map (kbd "^") (kbd "C-="))
(define-key key-translation-map (kbd "&") (kbd "C-="))
(define-key key-translation-map (kbd "*") (kbd "C-="))
(define-key key-translation-map (kbd "(") (kbd "C-="))
(define-key key-translation-map (kbd ")") (kbd "C-="))
#+end_src

***** Set new keys
#+begin_src emacs-lisp
(define-key key-translation-map (kbd "M-q") (kbd "!"))
(define-key key-translation-map (kbd "M-g") (kbd "@"))
(define-key key-translation-map (kbd "M-m") (kbd "#"))
(define-key key-translation-map (kbd "M-l") (kbd "$"))
(define-key key-translation-map (kbd "M-w") (kbd "%"))
(define-key key-translation-map (kbd "M-;") (kbd "^"))
(define-key key-translation-map (kbd "M-b") (kbd "&"))
(define-key key-translation-map (kbd "M-y") (kbd "*"))
(define-key key-translation-map (kbd "M-f") (kbd "("))
(define-key key-translation-map (kbd "M-u") (kbd ")"))
#+end_src

* nix
** Direnv
#+begin_src emacs-lisp
(straight-use-package 'direnv)
(direnv-mode)
#+end_src

** Nix-mode
#+begin_src emacs-lisp
(straight-use-package 'nix-mode)
#+end_src

** Nix-options
*** Company
#+begin_src emacs-lisp
(straight-use-package 'company-nixos-options)
#+end_src
I can't find a pure add-to-list so i have to copy it so that company-backends isn't modified
#+begin_src emacs-lisp
(add-hook 'nix-mode-hook '(lambda () (interactive)
			    (let ((list company-backends))
			      (add-to-list 'list 'company-nixos-options)
			      (setq-local company-backends list))))
#+end_src

*** Ivy
#+begin_src emacs-lisp
(defun my/nixos-options-ivy ()
  (interactive)
  (require 'nixos-options)
  (switch-to-buffer
   (nixos-options-doc-buffer
    (nixos-options-get-documentation-for-option
     (nixos-options-get-option-by-name
      (completing-read "nix-options: " nixos-options))))))
#+end_src

** Pretty sha paths
 (straight-use-package 'pretty-sha-path)

 (add-hook 'eshell-mode-hook 'pretty-sha-path-mode)

* exwm
** Keys before exwm init
Reset exwm-mode map
#+begin_src emacs-lisp
(setq exwm-mode-map (make-sparse-keymap))

(define-key evil-emacs-state-map (kbd "TAB") nil)
(global-unset-key (kbd "TAB"))
#+end_src

Rebind keys in exwm bufffers
#+begin_src emacs-lisp
(setq exwm-input-simulation-keys
      '(
	;; Delete char
	([?\C-l] . [delete])
	([?\C-f] . [backspace])

	;; movement
	([?\C-p] . [up])
	([?\C-n] . [down])

	;; ([?\C-u] . [prior])
	;; ([?\C-w] . [next])
	([?\C-w] . [?\C-d])

	([?\C-s] . [?\C-f])

	([?\C-a] . [return])
	([?\r] . [return])

	;;([?\C-e] . [?\C-[])
	;; ([?\C-e] . [escape])
	;; ([?\e] . [escape])

	([?\C-t] . [tab])
	([?\t] . [tab])

	([?\C-g] . [escape])
	;;([?\e] . [escape])

	;; Firefox hard-coded open url hotkey
	;;([?\C-o] . [f6])

	;; Redo
	([?\C-r] . [?\C-y])
	;; Undo
	([?\M-u] . [?\C-z])

	;; cut/paste.
	([?\C-y] . [?\C-c])
	([?\C-k] . [?\C-v])

	([?\M-f] . [?\C-å])
	([?\M-u] . [?\C-ä])
	([?\M-b] . [?\C-ö])

	([?\M-F] . [?\C-Å])
	([?\M-U] . [?\C-Ä])
	([?\M-B] . [?\C-Ö])

	([?\C-c] . [?\C-c])))

(setq exwm-input-prefix-keys nil)
#+end_src
Exwm don't send back these keys
#+begin_src emacs-lisp
(dolist (k '(
	     XF86AudioLowerVolume
	     XF86AudioRaiseVolume
	     XF86PowerOff
	     XF86AudioMute
	     XF86AudioPlay
	     XF86AudioStop
	     XF86AudioPrev
	     XF86AudioNext
	     XF86ScreenSaver
	     XF68Back
	     XF86Forward
	     Scroll_Lock
	     print
	     ))
  (cl-pushnew k exwm-input-prefix-keys))

(setq exwm-input-global-keys nil)
#+end_src

** load exwm
https://emacs.stackexchange.com/questions/33326/how-do-i-cut-and-paste-effectively-between-applications-while-using-exwm
#+begin_src emacs-lisp
(straight-use-package 'exwm)

(require 'exwm)
#+end_src

enable exwm
#+begin_src emacs-lisp
(exwm-enable)
#+end_src

** exwm keys
#+begin_src emacs-lisp
(exwm-input-set-key (kbd my/mod-leader-map-key) 'my/leader-map)

(exwm-input-set-key (kbd "M-<tab>") 'my/toggle-switch-to-minibuffer)

(exwm-input-set-key (kbd "C-e") 'keyboard-quit)
(exwm-input-set-key (kbd "<tab>") 'my/window-hydra/body)
(exwm-input-set-key (kbd "C-=") 'my/window-hydra/body)

(exwm-input-set-key (kbd "M-x") 'counsel-M-x)
#+end_src

(exwm-input-set-key (kbd "DEL") '(lambda () (interactive) (exwm-input--fake-key 'backspace)))
(exwm-input-set-key (kbd "<deletechar>") '(lambda () (interactive) (exwm-input--fake-key 'delete)))

(exwm-input-set-key (kbd "M-w") '(lambda () (interactive) (exwm-input--fake-key ?\å)))
(exwm-input-set-key (kbd "M-r") '(lambda () (interactive) (exwm-input--fake-key ?\ä)))
(exwm-input-set-key (kbd "M-j") '(lambda () (interactive) (exwm-input--fake-key ?\ö)))

** Exwm-edit
#+begin_src emacs-lisp
(setq exwm-edit-bind-default-keys
      nil)
(straight-use-package '(exwm-edit :type git :host github :repo "walseb/exwm-edit" :branch "AllFixes"))
(require 'exwm-edit)
(global-exwm-edit-mode 1)
#+end_src

*** Remove header
#+begin_src emacs-lisp
(add-hook 'exwm-edit-mode-hook '(lambda () (kill-local-variable 'header-line-format)))
#+end_src

*** Keys
#+begin_src emacs-lisp
(exwm-input-set-key (kbd "C-d") #'exwm-edit--compose)
#+end_src
(exwm-input-set-key (kbd "M-j") #'exwm-edit--compose)

** Set exwm buffer name
*** Manually set buffer name
#+begin_src emacs-lisp
(defun my/exwm-set-window-name ()
  (interactive)
  (exwm-workspace-rename-buffer (completing-read "set title " nil)))

(define-key my/file-options-map (kbd "r") 'my/exwm-set-window-name)
#+end_src

*** Auto set buffer name
We use class names for all windows expect for Java applications and GIMP (because of problems with those).
#+begin_src emacs-lisp
(defun my/exwm-should-use-title-for-buffer-name ()
  (or
   (not exwm-instance-name)
   (string-prefix-p "sun-awt-X11-" exwm-instance-name)
   (string= "gimp" exwm-instance-name)
   ;; Firefox calls itself navigator?
   (string-prefix-p "Navigator" exwm-instance-name t)
   ;;(string-prefix-p "Firefox" exwm-instance-name t)
   ))

(add-hook 'exwm-update-class-hook 'my/exwm-buffer-give-name-class)

(defun my/exwm-buffer-give-name-class ()
  (when (not (my/exwm-should-use-title-for-buffer-name))
    (exwm-workspace-rename-buffer exwm-class-name)))

(add-hook 'exwm-update-title-hook 'my/exwm-buffer-give-name-title)

(defun my/exwm-buffer-give-name-title ()
  (when (my/exwm-should-use-title-for-buffer-name)
    (exwm-workspace-rename-buffer exwm-title)))
#+end_src

** Fix modeline in exwm buffers
#+begin_src emacs-lisp
(add-hook 'exwm-floating-exit-hook '(lambda ()
				      (kill-local-variable 'header-line-format)))
#+end_src

** Disable floating windows
#+begin_src emacs-lisp
(setq exwm-manage-force-tiling t)
#+end_src

** Multi-screen
#+begin_src emacs-lisp
(if my/enable-randr
    (require 'exwm-randr))
#+end_src

*** Get monitor setup
#+begin_src emacs-lisp
(defun my/exwm-randr-auto-get-monitor ()
  (let* ((result)
	 (monitors (nth 1 (exwm-randr--get-monitors))))
    (dotimes (i (/ (length monitors) 2))
      (push (nth (* i 2) monitors) result)
      (push i result))
    result))
#+end_src

Get monitor setup
#+begin_src emacs-lisp
(if my/enable-randr
    (if my/device/monitor-setup
	(progn
	  (setq exwm-workspace-number (/ (length my/device/monitor-setup) 2))
	  (setq exwm-randr-workspace-monitor-plist my/device/monitor-setup))))
#+end_src
(let ((monitor-setup (my/exwm-randr-auto-get-monitor)))
(setq exwm-workspace-number (/ (length monitor-setup) 2))
(setq exwm-randr-workspace-monitor-plist monitor-setup)))

*** Enable
#+begin_src emacs-lisp
(if (and my/enable-randr (> exwm-workspace-number 1))
    (progn
      (exwm-randr-enable)))
#+end_src

*** Switch monitor (workspace) functions
`exwm-workspace-number' is equal to monitor count
(add-hook 'focus-out-hook 'exwm-layout--refresh)
#+begin_src emacs-lisp
(defun my/switch-monitor-left ()
  (interactive)
  (if (>= exwm-workspace-current-index (- exwm-workspace-number 1))
      (exwm-workspace-switch-create 0)
    (exwm-workspace-switch-create (+ exwm-workspace-current-index 1))))

(defun my/switch-monitor-right ()
  (interactive)
  (if (= exwm-workspace-current-index 0)
      (exwm-workspace-switch-create (- exwm-workspace-number 1))
    (exwm-workspace-switch-create (- exwm-workspace-current-index 1))))
#+end_src

(define-key my/keys-mode-map (kbd "M-l") 'my/switch-monitor-right)
(define-key my/keys-mode-map (kbd "M-h") 'my/switch-monitor-left)

** Setting
Garbage collect when entering x window (because x is not in sync with emacs)
(add-hook 'exwm-mode-hook 'garbage-collect)

#+begin_src emacs-lisp
(setq exwm-workspace-show-all-buffers t)

(setq exwm-workspace-minibuffer-position 'top)

(add-hook 'exwm-init-hook (lambda () (interactive) (exwm-workspace-attach-minibuffer)))
#+end_src

* Shr
#+begin_src emacs-lisp
(require 'shr)
#+end_src

*** Fix background colors shr
Try fixing colors
(setq shr-color-visible-luminance-min 80)
(setq shr-color-visible-distance-min 5)

Fully disables colors
#+begin_src emacs-lisp
(advice-add #'shr-colorize-region :around (defun shr-no-colourise-region (&rest ignore)))
#+end_src

*** Auto-open image at point
Redefine function to attempt to open image if link at point wasn't found
#+begin_src emacs-lisp
(el-patch-feature shr)
(el-patch-defun shr-browse-url (&optional external mouse-event)
  "Browse the URL at point using `browse-url'.
   If EXTERNAL is non-nil (interactively, the prefix argument), browse
   the URL using `shr-external-browser'.
   If this function is invoked by a mouse click, it will browse the URL
   at the position of the click.  Optional argument MOUSE-EVENT describes
   the mouse click event."
  (interactive (list current-prefix-arg last-nonmenu-event))
  (mouse-set-point mouse-event)
  (let ((url (get-text-property (point) 'shr-url)))
    (cond
     ((not url)
      ;; Was unsuccessful in opening link, attempt to open image
      (shr-browse-image))
     ((string-match "^mailto:" url)
      (browse-url-mail url))
     (t
      (if external
	  (funcall shr-external-browser url)
	(browse-url url))))))
#+end_src

* Browser
#+begin_src emacs-lisp
(defun my/get-search-url ()
  (interactive)
  (let ((search (completing-read "search: " nil)))
    ;; Don't do a google search for anything that has a dot then a letter
    ;; There are two (not whitespace) here because otherwise the * wildcard would accept strings without any char after a dot
    (if (or
	 (string-match-p (rx whitespace) search)
	 (not (string-match-p (rx (regexp "\\.") (not whitespace) (not whitespace) (regexp "*") eol) search)))
	(concat "https://www.google.com/search?q=" search)
      search)))
#+end_src

** w3m
#+begin_src emacs-lisp
(straight-use-package 'w3m)
(when (and (my/is-system-package-installed 'w3m) my/use-w3m)
  (require 'w3m)
  (w3m-display-mode 'plain))

(setq w3m-use-title-buffer-name t)

(setq w3m-session-crash-recovery nil)

(setq w3m-search-word-at-point nil)
#+end_src

*** Images
Make images load instantly
#+begin_src emacs-lisp
(setq w3m-default-display-inline-images t)
(setq w3m-idle-images-show-interval 0)
#+end_src

*** Launch w3m
#+begin_src emacs-lisp
(defun my/w3m-get-search-url ()
  "Custom w3m search function"
  (interactive)
  (let ((search (completing-read "search: " nil)))
    ;; Don't do a google search for anything that has a dot then a letter
    ;; There are two (not whitespace) here because otherwise the * wildcard would accept strings without any char after a dot
    (if (or
	 (string-match-p (rx whitespace) search)
	 (not (string-match-p (rx (regexp "\\.") (not whitespace) (not whitespace) (regexp "*") eol) search)))
	(w3m-search "google" "test")
      (w3m search t))))

(defun my/launch-w3m ()
  (interactive)
  (my/w3m-get-search-url))

(when my/use-w3m
  (define-key my/leader-map (kbd "b") 'my/launch-w3m))
#+end_src

*** Switch w3m buffer
#+begin_src emacs-lisp
(defun my/switch-w3m-buffer ()
  "Switch w3m buffer"
  (interactive)
  (setq this-command #'my/switch-w3m-buffer)
  (ivy-read "Switch to buffer: " #'internal-complete-buffer
	    :keymap ivy-switch-buffer-map
	    :preselect (buffer-name (other-buffer (current-buffer)))
	    :action #'ivy--switch-buffer-action
	    :matcher #'ivy--switch-buffer-matcher
	    :caller 'ivy-switch-buffer
	    :initial-input "*w3m*"))
#+end_src

*** Keys
#+begin_src emacs-lisp
(evil-define-key 'normal w3m-mode-map (kbd "RET") 'w3m-view-this-url)
(evil-define-key 'normal w3m-mode-map (kbd "o") 'w3m-search)
(evil-define-key 'insert w3m-mode-map (kbd "q") 'undefined)

(evil-define-key 'normal w3m-mode-map (kbd "u") 'w3m-history)
(evil-define-key 'normal w3m-mode-map (kbd "U") 'w3m-db-history)
#+end_src

** Eww/shr
#+begin_src emacs-lisp
(require 'eww)
#+end_src

*** Add URL to buffer name
#+begin_src emacs-lisp
(add-hook 'eww-after-render-hook '(lambda () (interactive) (my/give-buffer-unique-name (concat "eww - " (plist-get eww-data :title)))))
#+end_src

*** Keys
(define-key eww-mode-map [?\d] 'eww-back-url)
(evil-define-key 'normal eww-mode-map [?\d] 'eww-back-url)
(evil-define-key 'visual eww-mode-map [?\d] 'eww-back-url)

#+begin_src emacs-lisp
(evil-define-key 'normal eww-mode-map (kbd "w") 'evil-forward-word-begin)
(setq shr-map (make-sparse-keymap))

(evil-define-key 'normal eww-mode-map (kbd "H") 'eww-back-url)
(evil-define-key 'normal eww-mode-map (kbd "L") 'eww-forward-url)

(define-prefix-command 'my/eww-mode-map)
(evil-define-key 'normal eww-mode-map (kbd (concat my/leader-map-key " a")) 'my/eww-mode-map)

(define-key my/eww-mode-map (kbd "d") 'eww-download)
(define-key my/eww-mode-map (kbd "h") 'eww-history-browse)
(define-key my/eww-mode-map (kbd "o") 'eww-open-in-new-buffer)
(define-key my/eww-mode-map (kbd "r") 'eww-reload)
(define-key my/eww-mode-map (kbd "f") 'eww-open-file)
#+end_src
(define-key my/eww-mode-map (kbd "C-c") 'my/eww-toggle-code-highlighting)

** Firefox exwm integration
#+begin_src emacs-lisp
(with-eval-after-load 'exwm
  (progn
    (straight-use-package '(exwm-firefox-core :type git :host github :repo "walseb/exwm-firefox-core"  :branch "new-exwm-edit-version"))
    (straight-use-package '(exwm-firefox-evil :type git :host github :repo "walseb/exwm-firefox-evil"  :branch "new-exwm-edit-version"))
    ;;    (straight-use-package 'exwm-firefox-core)
    ;;    (straight-use-package 'exwm-firefox-evil)
    (require 'exwm-firefox-evil)

    ;; Auto enable exwm-firefox-evil-mode on all firefox buffers
    (add-hook 'exwm-manage-finish-hook 'exwm-firefox-evil-activate-if-firefox)

    ;; Run firefox buffers in normal mode
    (add-hook 'exwm-firefox-evil-mode-hook 'exwm-firefox-evil-normal)))

(setq exwm-firefox-core-search-bookmarks '(("google.com")
					   ("youtube.com")
					   ("github.com")
					   ("gmail.com")))

(setq exwm-firefox-evil-link-hint-end-key nil)
#+end_src

*** Tabs
http://doc.rix.si/cce/cce-browsers.html

#+begin_src emacs-lisp
(require 'dbus)

(defun my/browser-activate-tabs-cb (dbus ivy-hash choice)
  (funcall dbus "Activate" :int32 (truncate (string-to-number (gethash choice ivy-hash)))))

(defun my/browser-activate-tab ()
  "Activate a browser tab using Ivy. Requires plasma-browser integration"
  (interactive)
  (let ((ivy-hash (make-hash-table :test 'equal))
	(dbus (apply-partially 'dbus-call-method :session
			       "org.kde.plasma.browser_integration" "/TabsRunner"
			       "org.kde.plasma.browser_integration.TabsRunner")))
    (let ((cb (-partial #'my/browser-activate-tabs-cb dbus ivy-hash))
	  (res (funcall dbus "GetTabs")))
      (mapc
       (lambda (obj)
	 (let ((id (number-to-string (car (car (alist-get "id" (car obj) nil nil #'equal)))))
	       (title (car (car (alist-get "title" (car obj) nil nil #'equal)))))
	   (puthash title id ivy-hash)))
       res)
      (ivy-read "Activate tab: " ivy-hash :action cb))))
#+end_src

*** Keys
#+begin_src emacs-lisp
(with-eval-after-load 'exwm
  (progn
       ;;; Normal
    (evil-define-key '(insert visual normal motion) exwm-firefox-evil-mode-map (kbd "C-d") 'exwm-edit--compose)

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "p") 'exwm-firefox-core-up)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "n") 'exwm-firefox-core-down)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-up)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-down)

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "l") 'exwm-firefox-core-right)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "h") 'exwm-firefox-core-left)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "<deletechar>") 'exwm-firefox-core-right)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-h") 'exwm-firefox-core-left)

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-w") 'exwm-firefox-core-half-page-down)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "e") 'my/browser-activate-tab)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "N") 'exwm-firefox-core-tab-next)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "P") 'exwm-firefox-core-tab-previous)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "k") 'exwm-firefox-core-tab-close)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "g n") 'exwm-firefox-core-find-next)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "g p") 'exwm-firefox-core-find-previous)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-s") 'exwm-firefox-core-quick-find)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "t") 'exwm-firefox-core-tab-new)

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "s") 'exwm-firefox-core-find)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "S") 'exwm-firefox-core-find)

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "<prior>") 'exwm-firefox-core-page-up)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "<next>") 'exwm-firefox-core-page-down)


    (evil-define-key '(normal motion visual insert) exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-find-next)
    (evil-define-key '(normal motion visual insert) exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-find-previous)

    ;; Bind tab
    (evil-define-key '(normal motion visual insert) exwm-firefox-evil-mode-map (kbd "TAB") '(lambda () (interactive)
											      (exwm-input--fake-key 'tab)))

    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "f") 'exwm-firefox-evil-link-hint)
    (evil-define-key '(normal motion) exwm-firefox-evil-mode-map (kbd "F") 'exwm-firefox-evil-link-hint-new-tab)

       ;;; Visual
    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "p") 'exwm-firefox-core-up-select)
    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "n") 'exwm-firefox-core-down-select)

    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-w") 'exwm-firefox-core-half-page-down-select)

    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "j") 'exwm-firefox-core-find-next)
    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "J") 'exwm-firefox-core-find-previous)

    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
    (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)

       ;;; Insert
    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-u") '(lambda () (interactive) (exwm-firefox-evil-normal) (exwm-firefox-core-half-page-up)))
    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-w") '(lambda () (interactive) (exwm-firefox-evil-normal) (exwm-firefox-core-half-page-down)))
    ;;
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-f") '(lambda () (interactive) (my/exwm-fake-key "å")))
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-u") '(lambda () (interactive) (my/exwm-fake-key "ä")))
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-b") '(lambda () (interactive) (my/exwm-fake-key "ö")))
    ;;
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-F") '(lambda () (interactive) (my/exwm-fake-key "Å")))
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-U") '(lambda () (interactive) (my/exwm-fake-key "Ä")))
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-B") '(lambda () (interactive) (my/exwm-fake-key "Ö")))

    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-,") '(lambda () (interactive) (exwm-input--fake-key ?ä)))
    ;;    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "ä") '(lambda () (interactive) (exwm-input--fake-key ?ä)))

    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)
    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-l") '(lambda () (interactive) (exwm-input--fake-key 'delete)))
    (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "<backspace>") '(lambda () (interactive) (exwm-input--fake-key 'backspace)))))
#+end_src

** Next browser
(defun my/write-next-config ()
(my/create-dir-if-not-exist "~/.config")
(my/create-dir-if-not-exist "~/.config/next")
(my/create-file-with-content-if-not-exist "~/.config/next/init.lisp")

)

** Set default browser
#+begin_src emacs-lisp
(if my/use-w3m
    (setq-default browse-url-browser-function 'w3m-browse-url)
  (setq-default browse-url-browser-function 'eww-browse-url))
#+end_src

* Version control
** Ediff
#+begin_src emacs-lisp
(require 'ediff)
(setq-default ediff-forward-word-function 'forward-char)
#+end_src

Fixes exwm bug too?
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)

(setq ediff-split-window-function 'split-window-horizontally)
#+end_src

*** A and B to Ancestor
#+begin_src emacs-lisp
(defun ediff-copy-both-to-C ()
  (interactive)
  (ediff-copy-diff ediff-current-difference nil 'C nil
		   (concat
		    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
		    (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
#+end_src

*** Ediff-dired
https://oremacs.com/2017/03/18/dired-ediff/
#+begin_src emacs-lisp
(defun my/ediff-dired ()
  (interactive)
  (let ((files (dired-get-marked-files))
	(wnd (current-window-configuration)))
    (if (<= (length files) 2)
	(let ((file1 (car files))
	      (file2 (if (cdr files)
			 (cadr files)
		       (read-file-name
			"file: "
			(dired-dwim-target-directory)))))
	  (if (file-newer-than-file-p file1 file2)
	      (ediff-files file2 file1)
	    (ediff-files file1 file2)))
      (error "no more than 2 files should be marked"))))
#+end_src

*** Keys
#+begin_src emacs-lisp
(setq-default ediff-mode-map (make-sparse-keymap))

(define-prefix-command 'my/ediff-mode-map)
(evil-define-key 'normal ediff-mode-map (kbd (concat my/leader-map-key " a")) 'my/ediff-mode-map)
(define-key ediff-mode-map "p" 'ediff-previous-difference)
(define-key ediff-mode-map "n" 'ediff-next-difference)
#+end_src

** Projectile
#+begin_src emacs-lisp
(straight-use-package 'projectile)
#+end_src

Disable projectile mode so that CPU isn't taken by projectile wating to refresh git project directory all the time
#+begin_src emacs-lisp
(projectile-mode -1)
#+end_src

** Counsel projectile
If enabled it auto enables projectile, which has high CPU usage
#+begin_src emacs-lisp
(straight-use-package 'counsel-projectile)
#+end_src

** Magit
#+begin_src emacs-lisp
(straight-use-package 'magit)

(setq git-commit-summary-max-length 50)
#+end_src

*** Performance
Disable magit in commit view, makes it possible to do large commits
#+begin_src emacs-lisp
(setq magit-commit-show-diff nil)
#+end_src

*** Diff
(require 'magit-diff)
#+begin_src emacs-lisp
(setq-default magit-diff-refine-hunk 'all)
#+end_src
(setq-default magit-diff-refine-ignore-whitespace nil)

*** Forge
#+begin_src emacs-lisp
(straight-use-package '(forge :type git :host github :repo "magit/forge"))
#+end_src

*** Keys
#+begin_src emacs-lisp
(require 'magit)
(require 'magit-mode)

(evil-define-key '(normal motion) magit-mode-map (kbd "0") 'magit-diff-default-context)
(evil-define-key '(normal motion) magit-mode-map (kbd "1") #'magit-section-show-level-1)
(evil-define-key '(normal motion) magit-mode-map  (kbd "2") #'magit-section-show-level-2)
(evil-define-key '(normal motion) magit-mode-map  (kbd "3") #'magit-section-show-level-3)
(evil-define-key '(normal motion) magit-mode-map  (kbd "4") #'magit-section-show-level-4)
#+end_src

Can't unbind "s"?
(my/evil-normal-define-key-in-mode magit-mode-map  "s" 'isearch-forward)
(define-key magit-status-mode-map "s" 'isearch-forward)
(my/evil-normal-define-key-in-mode magit-status-mode-map  "s" 'isearch-forward)
(my/evil-normal-define-key-in-mode magit-untracked-section-map  "s" 'isearch-forward)

** diff-hl
#+begin_src emacs-lisp
(straight-use-package 'diff-hl)

(setq diff-hl-side 'right)

(global-diff-hl-mode)
#+end_src

If there is no fringe (terminal), use margin instead
#+begin_src emacs-lisp
(unless (display-graphic-p) (diff-hl-margin-mode))

(add-hook 'dired-mode-hook 'diff-hl-dired-mode)

(add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

(setq diff-hl-draw-borders nil)
#+end_src

** Keys
#+begin_src emacs-lisp
(evil-define-key 'insert magit-mode-map (kbd "a") 'evil-append)

(define-prefix-command 'my/vc-map)
(define-key my/leader-map (kbd "v") 'my/vc-map)

(define-key my/vc-map (kbd "n") 'diff-hl-next-hunk)
(define-key my/vc-map (kbd "p") 'diff-hl-previous-hunk)

(define-key my/vc-map (kbd "k") 'diff-hl-revert-hunk)
(define-key my/vc-map (kbd "=") 'diff-hl-diff-goto-hunk)

(define-key my/vc-map (kbd "s") 'counsel-git-grep)
#+end_src
(define-key my/vc-map (kbd "s") 'counsel-projectile-ag)
#+begin_src emacs-lisp
(define-key my/vc-map (kbd "d") 'projectile-dired)
(define-key my/vc-map (kbd "D") 'counsel-projectile-find-dir)

(define-key my/vc-map (kbd "K") 'projectile-kill-buffers)
(define-key my/vc-map (kbd "f") 'counsel-projectile-switch-to-buffer)
(define-key my/vc-map (kbd "F") 'projectile-ibuffer)

(define-key my/vc-map (kbd "O") 'projectile-save-project-buffers)
(define-key my/vc-map (kbd "C") 'projectile-compile-project)

(define-key my/vc-map (kbd "!") 'projectile-run-shell-command-in-root)
(define-key my/vc-map (kbd "&") 'projectile-run-async-shell-command-in-root)

(define-key my/vc-map (kbd "o") 'magit-status)

(define-key my/vc-map (kbd "a") 'counsel-projectile-switch-to-buffer)
(define-key my/vc-map (kbd "A") 'counsel-projectile-switch-project)

(define-key my/vc-map (kbd "f") 'counsel-projectile-find-file)
(define-key my/vc-map (kbd "F") 'counsel-projectile-ag)
#+end_src

* Media
** Volume keys
#+begin_src emacs-lisp
(defvar my/audio-sink nil)
#+end_src
Pulse sometimes first starts when a video, etc starts
#+begin_src emacs-lisp
(defun my/pulse-update-audio-sink ()
  (interactive)
  (setq my/audio-sink (substring (shell-command-to-string "pacmd list-sinks | grep \"\* index\"") (string-match "[0-9]" (shell-command-to-string "pacmd list-sinks | grep \"index\"")) -1)))

(defun my/pulse-mute-toggle ()
  (interactive)
  (my/pulse-update-audio-sink)
  (shell-command (concat "pactl set-sink-mute " my/audio-sink " toggle")))

(global-set-key (kbd "<XF86AudioMute>") 'my/pulse-mute-toggle)
(global-set-key (kbd "s-`") 'my/pulse-mute-toggle)

(defun my/pulse-raise-volume ()
  (interactive)
  (my/pulse-update-audio-sink)
  ;; Unmute
  (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
  (shell-command (concat "pactl set-sink-volume " my/audio-sink " +2.5%")))

(global-set-key (kbd "<XF86AudioRaiseVolume>") 'my/pulse-raise-volume)
(global-set-key (kbd "s-=") 'my/pulse-raise-volume)

(defun my/pulse-lower-volume ()
  (interactive)
  (my/pulse-update-audio-sink)
  ;; Unmute
  (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
  (shell-command (concat "pactl set-sink-volume " my/audio-sink " -2.5%")))

(global-set-key (kbd "<XF86AudioLowerVolume>") 'my/pulse-lower-volume)

(global-set-key (kbd "s--") 'my/pulse-lower-volume)
#+end_src

#+RESULTS:
: my/pulse-lower-volume

** Music
#+begin_src emacs-lisp
(define-prefix-command 'my/music-map)
(define-key my/leader-map (kbd "M") 'my/music-map)
#+end_src

*** EMMS
Setup emms
#+begin_src emacs-lisp
(defvar my/emms-has-init nil)

(defvar my/emms-init-hook nil
  "Hook called when emms has to init fully")

(straight-use-package 'emms)


(add-hook 'my/emms-init-hook (lambda () (interactive)
			       (unless my/emms-has-init
				 (setq my/emms-has-init t)
				 (require 'emms-setup)
				 (require 'emms-player-mpd)

				 (emms-all)
				 ;; Disable name of playing track in modeline (time is kept though)
				 (emms-mode-line-disable))))

(setq emms-mode-line-format nil)

(setq emms-seek-seconds 5)
(setq emms-player-list '(emms-player-mpd))
(setq emms-info-functions '(emms-info-mpd))

(setq emms-player-mpd-server-name "localhost")
(setq emms-player-mpd-server-port "6600")
#+end_src

(setq mpc-host "localhost:6600")

**** Sort by directory name instead of metadata
#+begin_src emacs-lisp
(setq emms-browser-get-track-field-function 'emms-browser-get-track-field-use-directory-name)
#+end_src

**** Open playlist
emms doesn't automatically connect to mpd when loading playlist, results in empty playlist
#+begin_src emacs-lisp
(defun my/open-emms-and-connect()
  "Reconnect to MPD and open emms playlist"
  (interactive)
  (run-hooks 'my/emms-init-hook)
  (emms-player-mpd-connect)
  (emms-smart-browse))
#+end_src

**** Sync MPD and emms
#+begin_src emacs-lisp
(defun my/sync-mpd-and-emms ()
  "Updates the MPD and emms database synchronously."
  (interactive)
  (call-process "mpc" nil nil nil "update")
  (emms-player-mpd-update-all-reset-cache)
  (emms-cache-set-from-mpd-all)
  (emms-player-mpd-connect)
  (message "MPD database and emms updated!"))
#+end_src

**** Keys
#+begin_src emacs-lisp
(require 'emms-browser)
(define-key my/music-map (kbd "u") 'my/sync-mpd-and-emms)

(define-key my/music-map (kbd "o") 'my/open-emms-and-connect)
(define-key my/music-map (kbd "g") 'emms-seek-to)
(define-key my/music-map (kbd "s") 'emms-pause)

(define-key emms-browser-mode-map (kbd "s") 'emms-pause)

(evil-define-key 'normal emms-browser-mode-map (kbd "RET") 'emms-browser-add-tracks)

(evil-define-key 'normal emms-playlist-mode-map (kbd "RET") 'emms-playlist-mode-play-smart)

(global-set-key (kbd "<XF86AudioPlay>") 'emms-pause)
(global-set-key (kbd "<XF86AudioStop>") 'emms-stop)
#+end_src

*** MPD
**** Start MPD
#+begin_src emacs-lisp
(defun my/start-mpd ()
  "Start MPD, connect to it and sync the metadata cache."
  (interactive)
  (start-process "mpd" nil "mpd")
  (message "MPD started and synced!"))
#+end_src

**** Kill daemon
#+begin_src emacs-lisp
(defun my/kill-music-daemon ()
  "Stops playback and kill the music daemon."
  (interactive)
  (emms-stop)
  (call-process "killall" nil nil nil "mpd")
  (message "MPD killed!"))
#+end_src

**** View MPD info
#+begin_src emacs-lisp
(defun my/mpd-info ()
  "Runs mpc, showing info in message field"
  (interactive)
  (shell-command "mpc"))
#+end_src

**** Shuffle playlist random
***** Random on
#+begin_src emacs-lisp
(defun my/mpd-random-on ()
  "Turns on MPD random play"
  (interactive)
  (shell-command "mpc random on"))
#+end_src

***** Random off
#+begin_src emacs-lisp
(defun my/mpd-random-off ()
  "Turns off MPD random play"
  (interactive)
  (shell-command "mpc random off"))
#+end_src

**** Volume control
***** Raise volume
#+begin_src emacs-lisp
(defun my/mpd-raise-volume()
  (interactive)
  (shell-command "mpc volume +4"))
#+end_src

***** Lower volume
#+begin_src emacs-lisp
(defun my/mpd-lower-volume ()
  (interactive)
  (shell-command "mpc volume -4"))
#+end_src

**** Change song
***** Next song
#+begin_src emacs-lisp
(defun my/mpd-next-song()
  (interactive)
  (shell-command "mpc next"))
#+end_src

***** Previous song
#+begin_src emacs-lisp
(defun my/mpd-previous-song()
  (interactive)
  (shell-command "mpc prev"))
#+end_src

**** Change time on track
***** Forward
#+begin_src emacs-lisp
(defun my/mpd-wind-forward()
  (interactive)
  (shell-command "mpc seek +10"))
#+end_src

***** Forward far
#+begin_src emacs-lisp
(defun my/mpd-wind-far-forward()
  (interactive)
  (shell-command "mpc seek +60"))
#+end_src

***** Backwards
#+begin_src emacs-lisp
(defun my/mpd-wind-backward()
  (interactive)
  (shell-command "mpc seek -10"))
#+end_src

***** Backwards far
#+begin_src emacs-lisp
(defun my/mpd-wind-far-backward()
  (interactive)
  (shell-command "mpc seek -60"))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-key my/music-map (kbd "C-s") 'my/start-mpd)
(define-key my/music-map (kbd "C-k") 'my/kill-music-daemon)
(define-key my/music-map (kbd "i") 'my/mpd-info)

(define-key my/music-map (kbd "r") 'my/mpd-random-on)
(define-key my/music-map (kbd "C-r") 'my/mpd-random-off)

(define-key my/music-map (kbd "=") 'my/mpd-raise-volume)
(define-key my/music-map (kbd "-") 'my/mpd-lower-volume)

(define-key my/music-map (kbd "n") 'my/mpd-next-song)
(define-key my/music-map (kbd "p") 'my/mpd-previous-song)

(define-key my/music-map (kbd "l") 'my/mpd-wind-forward)
(define-key my/music-map (kbd "h") 'my/mpd-wind-backward)
(define-key my/music-map (kbd "L") 'my/mpd-wind-far-forward)
(define-key my/music-map (kbd "H") 'my/mpd-wind-far-backward)

(global-set-key (kbd "<XF86AudioNext>") 'my/mpd-next-song)
(global-set-key (kbd "<XF86AudioPrev>") 'my/mpd-previous-song)
#+end_src

* Screenshots
** Functions
*** Entire screen
#+begin_src emacs-lisp
(defun my/take-screenshot ()
  "Takes a fullscreen screenshot of the current workspace"
  (interactive)
  (when window-system
    (sit-for 1)
    (start-process "screenshot" nil "import" "-window" "root"
		   (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))))
#+end_src

*** Region
#+begin_src emacs-lisp
(defun my/take-screenshot-region ()
  "Takes a screenshot of a region selected by the user."
  (interactive)
  (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
		  (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
#+end_src

*** Region ask for name
#+begin_src emacs-lisp
(defun my/take-screenshot-region-and-ask-for-name ()
  "Takes a screenshot of a region selected by the user and asks for file path"
  (interactive)
  (when window-system

    ;; Check if there is a directory called "images" in current dir, if so start read-file-name inside that directory
    (if(file-exists-p (concat default-directory "images/"))
	(setq screenshot-base-path (concat default-directory "images/"))
      (setq screenshot-base-path default-directory))

    ;; If screenshot path is not empty
    (call-process "import" nil nil nil ".newScreen.png")

    ;; Ask for path
    (setq screenshot-path (read-file-name "Screenshot file (.png already added) " screenshot-base-path))

    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1" (concat screenshot-path ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
#+end_src

** Keys
#+begin_src emacs-lisp
(global-set-key (kbd "<print>") 'my/take-screenshot-region-and-ask-for-name)
#+end_src

 (define-key my/leader-map (kbd "p r") 'my/take-screenshot-region)
 (define-key my/leader-map (kbd "p w") 'my/take-screenshot)

* Mail
** Gnus
.gnus.el is written in =write config map=
https://github.com/gongzhitaao/GnusSolution
https://www.gnu.org/software/emacs/manual/html_node/gnus/Comparing-Mail-Back-Ends.html
#+begin_src emacs-lisp
(require 'gnus)
(define-key my/open-map (kbd "g") 'gnus)
#+end_src

Encrypt passwords
#+begin_src emacs-lisp
(setq netrc-file "~/.authinfo.gpg")

(setq gnus-use-full-window nil)
#+end_src

*** Disable state
Gnus normally stores random state inside =~/.newsrc-dribble=, this prevents that from happening
#+begin_src emacs-lisp
(setq gnus-use-dribble-file nil)
#+end_src

*** Sources
#+begin_src emacs-lisp
(if (my/is-system-package-installed 'dovecot)
    (setq gnus-select-method '(nnimap "Dovecot"
				      (nnimap-stream network)
				      (nnimap-address "localhost")
				      (nnimap-authenticator login)
				      (nnimap-user "admin"))))

(setq gnus-secondary-select-methods
      '((nntp "news.gmane.org")))

(setq mail-user-agent 'gnus-user-agent)
(setq read-mail-command 'gnus)
(setq send-mail-function 'message-send-mail-with-sendmail)
(setq sendmail-program "msmtp")
#+end_src

(setq smtpmail-smtp-server "smtp.gmail.com"
smtpmail-smtp-service 587
;; Make Gnus NOT ignore [Gmail] mailboxes
gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

*** Minor settings
Fix bug in gnus, Replace [ and ] with _ in ADAPT file names
(setq nnheader-file-name-translation-alist '((?[ . ?_) (?] . ?_)) )

Maybe disable later
(setq gnus-save-killed-list nil)

#+begin_src emacs-lisp
(setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))
#+end_src

'(gnus-always-force-window-configuration t)

Disable signatures
#+begin_src emacs-lisp
(setq message-signature nil)
#+end_src

never split messages
#+begin_src emacs-lisp
(setq message-send-mail-partially-limit nil)
#+end_src

Disable gnus expiration
#+begin_src emacs-lisp
(setq gnus-agent-enable-expiration 'DISABLE)
#+end_src

Create two connections to the server for faster fetching
#+begin_src emacs-lisp
(setq gnus-asynchronous t)
#+end_src

Disable .newsrc file (file can be read by other newsreaders)
#+begin_src emacs-lisp
(setq gnus-read-newsrc-file nil)
(setq gnus-save-newsrc-file nil)

(setq gnus-completing-read-function 'gnus-emacs-completing-read)
#+end_src

*** Group mode
Mode for choosing server
#+begin_src emacs-lisp
(defun my/gnus-group-mode ()
  ;; Tree view for groups.
  (gnus-topic-mode)
  ;; List all groups over level 5
  (gnus-group-list-all-groups 5))

(add-hook 'gnus-group-mode-hook 'my/gnus-group-mode)
#+end_src

Always show inbox
(setq gnus-permanently-visible-groups "INBOX")

Apparently only some servers support using 'some
(setq gnus-read-active-file 't)
(setq gnus-read-active-file 'some)
(setq gnus-check-new-newsgroups 'ask-server)

**** Keys
#+begin_src emacs-lisp
(evil-define-key 'normal gnus-group-mode-map (kbd "i") 'nil)
(evil-define-key 'normal gnus-group-mode-map (kbd "o") (lambda () (interactive) (gnus-topic-select-group t)))
(evil-define-key 'normal gnus-group-mode-map (kbd "RET") 'gnus-topic-select-group)
(evil-define-key '(normal insert) gnus-group-mode-map (kbd "TAB") 'gnus-topic-select-group)

(define-prefix-command 'my/gnus-group-map)
(evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-group-map)

(defun my/gnus-group-list-all-subscribed-groups ()
  "List all subscribed groups with or without un-read messages"
  (interactive)
  (gnus-group-list-all-groups 5))

(define-key 'my/gnus-group-map (kbd "s") 'my/gnus-group-list-all-subscribed-groups)
#+end_src

*** Topic mode
Adds headers to each server, tree view
#+begin_src emacs-lisp
(defun my/gnus-topic-mode ()
  (my/gnus-topic-setup)
  ;; This doesn't work
  ;;(my/gnus-topic-add-gmane-groups)
  )

(add-hook 'gnus-topic-mode-hook 'my/gnus-topic-mode)
#+end_src

**** Subscribe to gmane groups
#+begin_src emacs-lisp
(defvar my/gnus-topic-gmane-prefix "nntp+news.gmane.org:")

(setq my/gnus-gmane-subscribed-emacs `(
				       ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.help")
				       ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.general")
				       ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.announce")
				       ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.user")))

(setq my/gnus-gmane-subscribed-emacs-blogs `(
					     ,(concat my/gnus-topic-gmane-prefix "gwene.com.oremacs")
					     ,(concat my/gnus-topic-gmane-prefix "gwene.me.emacsair")))

(setq my/gnus-gmane-subscribed-fsharp `(
					,(concat my/gnus-topic-gmane-prefix "gwene.com.reddit.pay.r.fsharp")))

(setq my/gnus-gmane-subscribed-guile `(
				       ,(concat my/gnus-topic-gmane-prefix "gmane.lisp.guile.user")))

(defun my/gnus-gmane-subscribed-get ()
  (append
   my/gnus-gmane-subscribed-guile
   my/gnus-gmane-subscribed-fsharp
   my/gnus-gmane-subscribed-emacs-blogs
   my/gnus-gmane-subscribed-emacs))

(defun my/gnus-topic-add-gmane-groups ()
  (let ((list (my/gnus-gmane-subscribed-get)))
    (dotimes (i (+ 1 (length list)))
      (add-to-list 'gnus-newsrc-alist `(,(nth i list) 3 nil nil "nntp:news.gmane.org"))))

  ;; Move the dummy entry to the top
  (setq gnus-newsrc-alist (delete '("dummy.group" 0 nil) gnus-newsrc-alist))
  ;; We don't need the dummy group?
  ;;(add-to-list 'gnus-newsrc-alist '("dummy.group" 0 nil))
  )
#+end_src

**** Topic setup
#+begin_src emacs-lisp
(defun my/gnus-topic-setup ()
  "Hides non-relevant servers and puts them into categories. To show all servers, disable my/gnus-topic-mode"

  ;; "Gnus" is the root folder, and there are three mail accounts, "misc", "hotmail", "gmail"
  (setq gnus-topic-topology '
	(("Gnus" visible)

	 ;; Mail
	 (("Mail" visible)
	  (("gmail" visible))
	  (("gmail-main" visible)))

	 ;; News
	 (("News" visible)
	  (("Emacs" visible)
	   (("Emacs blogs" visible)))
	  (("Fsharp" visible))
	  (("Guile" visible))
	  )))

  (setq gnus-topic-alist `((("Gnus"))
			   ;; Mail
			   ("gmail-main"
			    "main-gmail/All"
			    "main-gmail/Sent"
			    "main-gmail/Starred"
			    "main-gmail/Trash")

			   ;; News
			   ,(append '("Emacs") my/gnus-gmane-subscribed-emacs)
			   ,(append '("Emacs blogs") my/gnus-gmane-subscribed-emacs-blogs)
			   ,(append '("Fsharp") my/gnus-gmane-subscribed-fsharp)
			   ,(append '("Guile") my/gnus-gmane-subscribed-guile)
			   )))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-topic-map)
(evil-define-key 'normal gnus-topic-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-topic-map)
#+end_src

*** Summary mode
Mode for choosing which mail to open
#+begin_src emacs-lisp
(defun my/gnus-summary-mode ()
  (visual-line-mode -1)
  (setq truncate-lines t))

(add-hook 'gnus-summary-mode-hook 'my/gnus-summary-mode)
#+end_src

'(gnus-summary-mode-line-format "U%U %S" )
https://www.gnu.org/software/emacs/manual/html_node/gnus/Summary-Buffer-Lines.html
#+begin_src emacs-lisp
(setq-default gnus-summary-line-format
	      (concat
	       ;; Is unread
	       "%U"
	       ">"
	       ;; Total thread score
	       "%V"
	       ;; Has been replied to/cached/saved
	       "%R"
	       ;; Tab
	       "\t"
	       ;; Date as specified by `gnus-user-date-format-alist`
	       "%&user-date; \t"
	       ;; Linecount, leave -5,5 spacing
	       "%-5,5L"
	       ;; Sender taken from header, leave -20,20 spacing
	       "%-20,20n"

	       "\t"
	       ;; Reply tree
	       "%B"
	       ;; Article subject string
	       "%-80,80S"
	       ;; End
	       "\n"))

(setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))
(setq gnus-thread-sort-functions '(gnus-thread-sort-by-date))
#+end_src

Supposed to be better
#+begin_src emacs-lisp
(setq-default gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)

(setq gnus-sum-thread-tree-false-root ""
      gnus-sum-thread-tree-single-indent ""
      gnus-sum-thread-tree-root ""
      gnus-sum-thread-tree-vertical"|"
      gnus-sum-thread-tree-leaf-with-other "+-> "
      gnus-sum-thread-tree-single-leaf"\\-> "
      gnus-sum-thread-tree-indent " ")
#+end_src

'(gnus-thread-hide-subtree t)
'(gnus-thread-sort-functions (quote gnus-thread-sort-by-most-recent-date))
'(gnus-treat-hide-citation t)
'(gnus-unread-mark 42)
'(gnus-ancient-mark 32)

**** Visuals
'(gnus-summary-high-unread ((t (:foreground "green"))))
'(gnus-summary-low-read ((t (:foreground "magenta"))))
'(gnus-summary-normal-read ((t (:foreground "red"))))
'(gnus-summary-selected ((t (:background "yellow"))))
'(gnus-summary-normal-unread ((t (:foreground "white"))))

**** Scoring
#+begin_src emacs-lisp
(setq gnus-parameters
      '(("nnimap.*"
	 (gnus-use-scoring nil)) ;; Enable later
	))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-summary-map)
(evil-define-key 'normal gnus-summary-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-summary-map)

(evil-define-key 'normal gnus-summary-mode-map (kbd "i") 'nil)
(evil-define-key 'normal gnus-summary-mode-map (kbd "RET") 'gnus-summary-scroll-up)

(evil-define-key 'insert gnus-summary-mode-map (kbd "n") 'gnus-summary-next-article)
(evil-define-key 'insert gnus-summary-mode-map (kbd "p") 'gnus-summary-prev-article)

(evil-define-key 'insert gnus-summary-mode-map (kbd "N") 'gnus-summary-next-unread-article)
(evil-define-key 'insert gnus-summary-mode-map (kbd "P") 'gnus-summary-prev-unread-article)

(defun my/gnus-summary-show-all-mail ()
  "Show all mail"
  (interactive)
  (gnus-summary-rescan-group 1))

(define-key 'my/gnus-summary-map (kbd "s") 'my/gnus-summary-show-all-mail)
#+end_src

*** Article mode
Mode for reading contents of mail
(defun my/gnus-article-mode ()
Font lock mode disables colors in html mail for whatever reason
(font-lock-mode -1))
)

(add-hook 'gnus-article-mode-hook 'my/gnus-article-mode)

(defun my/gnus-article-display-mode ()
 (gnus-article-de-quoted-unreadable)
 (gnus-article-emphasize)
 (gnus-article-hide-boring-headers)
 (gnus-article-hide-headers-if-wanted)
 (gnus-article-hide-pgp)
 (gnus-article-highlight)
 (gnus-article-highlight-citation)
 (gnus-article-date-local)
)

#+begin_src emacs-lisp
(add-hook 'gnus-article-display-hook 'my/gnus-article-display-mode)
#+end_src

'(gnus-article-mode-line-format "U%U %S" )

**** Date headers
Make date headers better with timezone calculation and time passed
#+begin_src emacs-lisp
(setq gnus-article-date-headers '(user-defined)
      gnus-article-time-format
      (lambda (time)
	(let* ((date (format-time-string "%a, %d %b %Y %T %z" time))
	       (local (article-make-date-line date 'local))
	       (combined-lapsed (article-make-date-line date
							'combined-lapsed))
	       (lapsed (progn
			 (string-match " (.+" combined-lapsed)
			 (match-string 0 combined-lapsed))))
	  (concat local lapsed))))
#+end_src

**** Mail renderers, etc
html renderer
(setq mm-text-html-renderer 'shr)
#+begin_src emacs-lisp
(setq mm-text-html-renderer 'w3m)
#+end_src
Inline images?
#+begin_src emacs-lisp
(setq mm-attachment-override-types '("image/.*"))
#+end_src
No HTML mail
#+begin_src emacs-lisp
(setq mm-discouraged-alternatives '("text/html" "text/richtext"))
#+end_src

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-article-map)
(evil-define-key 'normal gnus-article-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-article-map)
#+end_src

*** Browse server mode
**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-browse-mode-map)
(evil-define-key 'normal gnus-browse-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-browse-mode-map)

(evil-define-key 'normal gnus-browse-mode-map (kbd "RET") 'gnus-browse-select-group)
#+end_src

*** Server mode
**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-server-mode-map)
(evil-define-key 'normal gnus-server-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-server-mode-map)

(evil-define-key 'normal gnus-server-mode-map (kbd "RET") 'gnus-server-read-server)
#+end_src

*** Message mode
Mode for writing mail

**** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/gnus-message-map)
(evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-message-map)
#+end_src

*** Misc
**** Random color gnus logo
#+begin_src emacs-lisp
(random t) ; Randomize sequence of random numbers
(defun my/random-hex (&optional num)
  (interactive "P")
  (let (($n (if (numberp num) (abs num) 6 )))
    (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n))))))

(setq gnus-logo-colors (list (concat "#" (my/random-hex 6)) (concat "#" (my/random-hex 6))))
#+end_src

** mbsync
#+begin_src emacs-lisp
(defvar my/sync-mail-hook nil)
(defvar my/sync-mail-has-begun nil)
(defconst my/mbsync-config "~/.mbsyncrc")

(defun my/sync-mail ()
  (interactive)
  (message (concat "Syncing mail at: " (current-time-string)))
  (if (file-exists-p my/mbsync-config)
      (let ((mbsync-config my/mbsync-config))
	(async-start
	 (lambda ()
	   (shell-command (concat
			   "mbsync -a "
			   "--config "
			   mbsync-config)))
	 (lambda (result)
	   (run-hooks 'my/sync-mail-hook))))
    (message "mbsync config not created")))

(defvar my/is-syncing nil)

(defun my/sync-mail-begin ()
  (when (and (my/is-system-package-installed 'mbsync) (file-exists-p my/mbsync-config) (not my/is-syncing))
    (setq my/is-syncing t)
    (run-with-timer 0 300 'my/sync-mail)))

(if my/run-mail-on-boot
    (add-hook 'exwm-init-hook 'my/sync-mail-begin)
  ;;(my/sync-mail-begin)
  (add-hook 'gnus-topic-mode-hook 'my/sync-mail-begin))
#+end_src

** Display unread mail count
#+begin_src emacs-lisp
(defun my/gnus-scan-unread ()
  (if (get-buffer "*Group*")
      (gnus-group-get-new-news)
    (gnus)))

(defun my/gnus-get-unread-mail-count ()
  (my/gnus-get-unread "Mail"))

(defun my/gnus-get-unread-news-count ()
  (my/gnus-get-unread "News"))

(defun my/gnus-get-unread (inbox)
  (let ((result ""))
    (dotimes (i (length gnus-topic-unreads))
      (if (string= inbox (car (nth i gnus-topic-unreads)))
	  (progn
	    (setq result (number-to-string (cdr (nth i gnus-topic-unreads))))
	    (setq i (length gnus-topic-unreads)))))
    result))
#+end_src

* System
#+begin_src emacs-lisp
(define-prefix-command 'my/system-commands-map)
(define-key my/leader-map (kbd "S") 'my/system-commands-map)
#+end_src

** Suspend
#+begin_src emacs-lisp
(define-prefix-command 'my/system-suspend-map)
(define-key my/system-commands-map (kbd "s") 'my/system-suspend-map)

(defun my/systemd-suspend-PC()
  (interactive)
  (shell-command "systemctl suspend"))
(define-key my/system-suspend-map (kbd "C-s") 'my/systemd-suspend-PC)
#+end_src

(defun my/systemd-hibernate-PC()
 (interactive)
 (shell-command "systemctl hibernate"))
Never used
(define-key my/system-suspend-map (kbd "C-h") 'my/systemd-hibernate-PC)

** Multi-monitor
#+begin_src emacs-lisp
(define-prefix-command 'my/system-monitor-map)
(define-key my/system-commands-map (kbd "m") 'my/system-monitor-map)

(defun my/x-suspend-monitor()
  (interactive)
  (shell-command "xset dpms force suspend"))
(define-key my/system-monitor-map (kbd "s") 'my/x-suspend-monitor)

(defun my/print-monitors ()
  (interactive)
  (shell-command "xrandr"))
(define-key my/system-monitor-map (kbd "p") 'my/print-monitors)

(defun my/monitor-home-setup ()
  (interactive)
  (shell-command "xrandr --output DP-1 --mode 2560x1440 --rate 60 --left-of DVI-D-1 --output DVI-D-1 --mode 1280x800 --rate 59.81"))
(define-key my/system-monitor-map (kbd "h") 'my/monitor-home-setup)

(defun my/auto-connect-screen ()
  (interactive)
  (with-temp-buffer
    (call-process "xrandr" nil t nil)
    (beginning-of-buffer)
    (if (search-forward "VGA1 connected" nil 'noerror)
	(start-process-shell-command
	 "xrandr" nil "xrandr --output VGA1 --primary --auto --output LVDS1 --off")
      (start-process-shell-command
       "xrandr" nil "xrandr --output LVDS1 --auto"))))

(define-key my/system-monitor-map (kbd "a") 'my/auto-connect-screen)

(if (window-system)
    (async-shell-command my/device/monitor-setup-command "xrandr setup buffer"))
#+end_src

** Process monitors
#+begin_src emacs-lisp
(define-prefix-command 'my/processes-map)
(define-key my/system-commands-map (kbd "p") 'my/processes-map)
#+end_src

*** Top - proced
#+begin_src emacs-lisp
(define-key my/processes-map (kbd "t") 'proced)
#+end_src

**** Disable line wrapping
#+begin_src emacs-lisp
(defun my/proced-mode ()
  (interactive)
  (toggle-truncate-lines 1)
  (visual-line-mode -1))
#+end_src

(add-hook 'proced-post-display-hook 'my/proced-mode)
#+begin_src emacs-lisp
(add-hook 'proced-mode-hook 'my/proced-mode)
#+end_src

*** Profiler
#+begin_src emacs-lisp
(define-prefix-command 'my/profiler-map)
(define-key my/processes-map (kbd "p") 'my/profiler-map)

(define-key my/profiler-map (kbd "s") 'profiler-start)
(define-key my/profiler-map (kbd "e") 'profiler-stop)
(define-key my/profiler-map (kbd "r") 'profiler-report)
(define-key my/profiler-map (kbd "R") 'profiler-reset)
#+end_src

** Install software
#+begin_src emacs-lisp
(define-prefix-command 'my/software-install-map)
(define-key my/system-commands-map (kbd "i") 'my/software-install-map)
#+end_src

*** Install eclipse java language server
For use with lsp-java
#+begin_src emacs-lisp
(defun my/install-eclipse-java-language-server()
  (interactive)
  (shell-command "
   cd ~
   rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
   mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
   wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
   tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
   "))

(define-key my/software-install-map (kbd "j") 'my/install-eclipse-java-language-server)
#+end_src

*** Install pdf tools
#+begin_src emacs-lisp
(define-key my/software-install-map (kbd "p") 'pdf-tools-install)
#+end_src

*** Install omnisharp
#+begin_src emacs-lisp
(define-key my/software-install-map (kbd "o") 'omnisharp-install-server)
#+end_src

*** Install rtags
You need llvm
(defun my/install-rtags ()
(interactive)
(async-shell-command " cd ~
git clone --recursive https://github.com/Andersbakken/rtags.git
cd rtags
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .
make"))

(define-key my/software-install-map (kbd "r") 'my/install-rtags)

*** Compile config
#+begin_src emacs-lisp
(defun my/compile-config ()
  (interactive)
  (byte-compile-file my/config-exported-location nil))

(define-key my/software-install-map (kbd "C-c") 'my/compile-config)
#+end_src

* Networking
#+begin_src emacs-lisp
(define-prefix-command 'my/network-map)
(define-key my/system-commands-map (kbd "n") 'my/network-map)
#+end_src

** Network manager
Right now enwc seems to only be able to switch wifi networks and display network status in modeline
Also check out https://github.com/Kodkollektivet/emacs-nm
#+begin_src emacs-lisp
(straight-use-package 'enwc)
(setq enwc-default-backend 'nm)

(define-key my/network-map (kbd "c") 'enwc)
#+end_src

** Tramp
(setq tramp-default-method "scpx")

*** Performance
https://gist.github.com/ralt/a36288cd748ce185b26237e6b85b27bb

** Netstat
#+begin_src emacs-lisp
(defun my/net-utils-mode ()
  (interactive)
  (toggle-truncate-lines 1)
  (visual-line-mode -1))

(add-hook 'net-utils-mode-hook 'my/net-utils-mode)
#+end_src

** Keys
#+begin_src emacs-lisp
(define-key my/network-map (kbd "s") 'netstat)
(define-key my/network-map (kbd "p") 'ping)
(define-key my/network-map (kbd "P") '(lambda () (interactive) (ping "8.8.8.8")))
(define-key my/network-map (kbd "i") 'ifconfig)
#+end_src

* Hardware
#+begin_src emacs-lisp
(define-prefix-command 'my/hardware-info-map)
(define-key my/system-commands-map (kbd "h") 'my/hardware-info-map)
#+end_src

Memory
#+begin_src emacs-lisp
(defun my/unix-get-memory-available()
  (interactive)
  (shell-command "grep \"MemAvailable\" /proc/meminfo"))
(define-key my/hardware-info-map (kbd "m") 'my/unix-get-memory-available)
#+end_src

GPU
#+begin_src emacs-lisp
(defun my/unix-get-gpu()
  (interactive)
  (shell-command "lspci | grep ' VGA ' | cut -d\" \" -f 1 | xargs -i lspci -v -s {}"))
(define-key my/hardware-info-map (kbd "g") 'my/unix-get-gpu)
#+end_src

Blocked devices
#+begin_src emacs-lisp
(defun my/rfkill-get-blocked-devices()
  (interactive)
  (shell-command "rfkill list"))
(define-key my/hardware-info-map (kbd "b") 'my/rfkill-get-blocked-devices)
#+end_src

Get devices
#+begin_src emacs-lisp
(defun my/rfkill-get-devices()
  (interactive)
  (shell-command "cat /proc/devices"))
(define-key my/hardware-info-map (kbd "d") 'my/rfkill-get-devices)
#+end_src

** CPU
Linux temps
#+begin_src emacs-lisp
(if (file-exists-p "/proc/cpuinfo") (progn
				      (define-prefix-command 'my/cpu-info-map)
				      (define-key my/hardware-info-map (kbd "c") 'my/cpu-info-map)

				      (defun my/unix-cpu-get-clock()
					(interactive)
					(shell-command "grep \"cpu MHz\" /proc/cpuinfo"))
				      ;; Clock speed
				      (define-key my/cpu-info-map (kbd "f") 'my/unix-cpu-get-clock)
				      ;; Model name
				      (defun my/unix-cpu-get-name()
					(interactive)
					(shell-command "grep \"model name\" /proc/cpuinfo"))
				      (define-key my/cpu-info-map (kbd "n") 'my/unix-cpu-get-name)
				      ;; Core count
				      (defun my/unix-cpu-get-core-count()
					(interactive)
					;; Linux
					(shell-command "grep \"cores\" /proc/cpuinfo"))

				      (define-key my/cpu-info-map (kbd "c") 'my/unix-cpu-get-core-count)
				      ;; Flags
				      (defun my/unix-cpu-get-flags()
					(interactive)
					(shell-command "grep \"flags\" /proc/cpuinfo"))
				      (define-key my/cpu-info-map (kbd "F") 'my/unix-cpu-get-flags)
				      ;; Vendor
				      (defun my/unix-cpu-get-vendor-id()
					(interactive)
					(shell-command "grep \"vendor_id\" /proc/cpuinfo"))
				      (define-key my/cpu-info-map (kbd "v") 'my/unix-cpu-get-vendor-id)
				      ;; Bugs (Bugs that has affected CPU model)
				      (defun my/unix-cpu-get-bugs()
					(interactive)
					(shell-command "grep \"bugs\" /proc/cpuinfo"))
				      (define-key my/cpu-info-map (kbd "b") 'my/unix-cpu-get-bugs)
				      ;; Cache size
				      (defun my/unix-cpu-get-cache-size()
					(interactive)
					(shell-command "grep \"cache size\" /proc/cpuinfo"))
				      (define-key my/cpu-info-map (kbd "C") 'my/unix-cpu-get-cache-size)))
#+end_src

Windows cpu core count
(if (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
(let ((number-of-processors (getenv "NUMBER_OF_PROCESSORS")))
(if number-of-processors
(string-to-number number-of-processors))))

* Find
#+begin_src emacs-lisp
(straight-use-package '(ellocate :type git :host github :repo "walseb/ellocate"))
#+end_src

* Spelling
#+begin_src emacs-lisp
(define-prefix-command 'my/spell-map)
#+end_src
(define-key my/leader-map (kbd "S") 'my/spell-map)

#+begin_src emacs-lisp
(define-key my/spell-map (kbd "d") 'ispell-change-dictionary)
(define-key my/spell-map (kbd "s") 'flyspell-mode)
#+end_src

List of major modes not to check
#+begin_src emacs-lisp
(setq my/flyspell-do-not-check '(
				 minibuffer-inactive-mode
				 eshell-mode
				 shell-mode
				 term-mode

				 wdired-mode
				 ))

(defun my/flyspell-mode-auto-select ()
  ;; Don't run this right when flyspell mode is on, the mode might not have changed yet. Instead wait a millisecond until the mode has been decided and then check for prog-mode
  (run-with-timer 0.5 nil (lambda ()
			    (if (derived-mode-p 'prog-mode)
				(flyspell-prog-mode)
			      ;; It has to be both writable and not a part of the do not check list for spell checking to activate
			      (when (and (not buffer-read-only) (not (member major-mode my/flyspell-do-not-check)))
				(flyspell-mode 1))))))

(define-globalized-minor-mode global-my/flyspell-mode
  nil my/flyspell-mode-auto-select)
(global-my/flyspell-mode 1)
#+end_src

** Flyspell-prog enable only for certain faces
Don't auto correct strings
#+begin_src emacs-lisp
(setq flyspell-prog-text-faces
      '(
	;; font-lock-string-face
	font-lock-comment-face
	font-lock-doc-face))
#+end_src

** Flyspell-Correct
#+begin_src emacs-lisp
(straight-use-package 'flyspell-correct)
#+end_src

http://aspell.net/0.50-doc/man-html/4_Customizing.html#suggestion
#+begin_src emacs-lisp
(setq ispell-extra-args (list "--sug-mode=bad-spellers" "--run-together"))
#+end_src

*** Key
#+begin_src emacs-lisp
(my/evil-normal-define-key (kbd "C-d") 'flyspell-correct-at-point)
(my/evil-visual-define-key (kbd "C-d") 'flyspell-correct-at-point)
#+end_src

** Company
#+begin_src emacs-lisp
(defun my/toggle-company-ispell ()
  (interactive)
  (cond
   ((memq 'company-ispell company-backends)
    (setq company-backends (delete 'company-ispell company-backends))
    (message "company-ispell disabled"))
   (t
    (add-to-list 'company-backends 'company-ispell)
    (message "company-ispell enabled!"))))

(define-key my/spell-map (kbd "c") 'my/toggle-company-ispell)
#+end_src

* Calc
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "m") 'calc)

(defun my/calc-kill-current-line ()
  (interactive)
  (calc-kill-region (line-beginning-position) (line-end-position)))

(evil-define-key 'normal calc-mode-map [remap evil-delete-whole-line] 'my/calc-kill-current-line)
(evil-define-key 'visual calc-mode-map (kbd "d") 'calc-kill-region)
#+end_src

* Artist mode
** Completing read
https://www.emacswiki.org/emacs/ArtistMode
#+begin_src emacs-lisp
(defun my/artist-select-operation (type)
  "Use ido to select a drawing operation in artist-mode"
  (interactive (list (completing-read "Drawing operation: "
				      (list "Pen" "Pen Line" "line" "straight line" "rectangle"
					    "square" "poly-line" "straight poly-line" "ellipse"
					    "circle" "text see-thru" "text-overwrite" "spray-can"
					    "erase char" "erase rectangle" "vaporize line" "vaporize lines"
					    "cut rectangle" "cut square" "copy rectangle" "copy square"
					    "paste" "flood-fill"))))
  (artist-select-operation type))

(defun my/artist-select-settings (type)
  "Use ido to select a setting to change in artist-mode"
  (interactive (list (completing-read "Setting: "
				      (list "Set Fill" "Set Line" "Set Erase" "Spray-size" "Spray-chars"
					    "Rubber-banding" "Trimming" "Borders"))))
  (if (equal type "Spray-size")
      (artist-select-operation "spray set size")
    (call-interactively (artist-fc-get-fn-from-symbol
			 (cdr (assoc type '(("Set Fill" . set-fill)
					    ("Set Line" . set-line)
					    ("Set Erase" . set-erase)
					    ("Rubber-banding" . rubber-band)
					    ("Trimming" . trimming)
					    ("Borders" . borders)
					    ("Spray-chars" . spray-chars))))))))
#+end_src

** Picture mode keys
#+begin_src emacs-lisp
(setq picture-mode-map (make-sparse-keymap))
(setq-default picture-mode-map (make-sparse-keymap))
#+end_src

** Keys
(define-key my/leader-map (kbd "k") 'artist-mode)

#+begin_src emacs-lisp
(define-prefix-command 'my/artist-mode-map)
(evil-define-key 'normal artist-mode-map (kbd (concat my/leader-map-key " a")) 'my/artist-mode-map)

(define-key my/artist-mode-map (kbd "o") 'my/artist-select-operation)
(define-key my/artist-mode-map (kbd "s") 'my/artist-select-settings)
#+end_src


(evil-define-key 'insert artist-mode-map (kbd "SPC") '(lambda () (interactive) (insert " ")))
(evil-define-key 'insert artist-mode-map (kbd "SPC") 'self-insert-command)

#+begin_src emacs-lisp
(setq artist-mode-map (make-sparse-keymap))
(setq-default artist-mode-map (make-sparse-keymap))
#+end_src
(evil-define-key 'insert artist-mode-map (kbd "<delete>") 'picture-backward-clear-column)

(evil-define-key 'insert artist-mode-map (kbd "RET") 'newline)

#+begin_src emacs-lisp
(evil-define-key 'normal artist-mode-map (kbd "p") 'artist-previous-line)
(evil-define-key 'normal artist-mode-map (kbd "n") 'artist-next-line)


(evil-define-key 'normal artist-mode-map (kbd "n") 'artist-next-line)

(evil-define-key 'emacs artist-mode-map [down-mouse-1] 'artist-down-mouse-1)
(evil-define-key 'emacs artist-mode-map [S-down-mouse-1] 'artist-down-mouse-1)
(evil-define-key 'emacs artist-mode-map [down-mouse-2] 'artist-mouse-choose-operation)
(evil-define-key 'emacs artist-mode-map [S-down-mouse-2] 'artist-mouse-choose-operation)
(evil-define-key 'emacs artist-mode-map [down-mouse-3] 'artist-down-mouse-3)
(evil-define-key 'emacs artist-mode-map [S-down-mouse-3] 'artist-down-mouse-3)
(evil-define-key 'emacs artist-mode-map [C-mouse-4] 'artist-select-prev-op-in-list)
(evil-define-key 'emacs artist-mode-map [C-mouse-5] 'artist-select-next-op-in-list)
#+end_src

* Hydra
#+begin_src emacs-lisp
(straight-use-package 'hydra)

(setq hydra-hint-display-type 'message)
#+end_src

** Window and buffer management
#+begin_src emacs-lisp
(defhydra my/window-hydra (:hint nil
				 :color red
				 :pre (setq my/window-hydra/hint
					    (concat "next: "
						    (let ((list (ivy--buffer-list "")))
						      (when
							  (if (and (string= (car list) (buffer-name))
								   ;; If there is only 1 buffer in emacs
								   (> (length list) 1))
							      (substring-no-properties
							       (nth 1 list))
							    (substring-no-properties
							     (car list))))))))
  "movement"

  ;; Move focus
  ("p" evil-window-up nil)
  ("n" evil-window-down nil)
  ("l" evil-window-right nil)
  ("h" evil-window-left nil)

  ;; Move focus to edge window
  ;; Frame border window
  ("|" evil-window-mru nil)

  ;; Move window
  ;; Move up
  ("P" evil-move-very-top nil)
  ;; Move down
  ("N" evil-move-very-bottom nil)
  ;; Move right
  ("L" evil-move-far-right nil)
  ;; Move left
  ("H" evil-move-far-left nil)

  ;; Switch monitor right
  ("$" my/switch-monitor-right nil)
  ;; Switch monitor left
  ("0" my/switch-monitor-left nil)

  ;; Resize window
  ;; Resize up
  ("C-p" (evil-window-increase-height 10) nil)
  ;; Resize down
  ("C-n" (evil-window-decrease-height 10) nil)
  ;; Resize right
  ;;("<delete>" (evil-window-decrease-width 10) nil)
  ("<deletechar>" (evil-window-decrease-width 10) nil)
  ;; Resize left
  ;;("\b" (evil-window-increase-width 10) nil)
  ("C-h" (evil-window-increase-width 10) nil)

  ;; Resize up
  ("C-S-p" (evil-window-increase-height 40) nil)
  ;; Resize down
  ("C-S-n" (evil-window-decrease-height 40) nil)
  ;; Resize right
  ("C-S-l" (evil-window-decrease-width 40) nil)
  ;; Resize left
  ("C-S-h" (evil-window-increase-width 40) nil)


  ;; Split
  ("o" my/window-split-right nil)
  ("O" my/window-split-left nil)
  ("v" my/window-split-down nil)
  ("V" my/window-split-up nil)

  ("i" my/clone-indirect-buffer nil)
  ("I" my/clone-indirect-buffer-other-window nil)

  ;; Search
  ("C-s" swiper-all nil)

  ;; Close window
  ("s" delete-window nil)
  ;; Focus on window
  ("d" my/delete-other-windows nil)

  ;; minimize window
  ("S" (lambda () (interactive) (evil-window-increase-height 1000) (evil-window-increase-width 1000)) nil)
  ;; maximize window
  ("D" (lambda () (interactive) (evil-window-decrease-height 1000) (evil-window-decrease-width 1000)) nil)

  ;; Buffer management
  ;; Find file
  ("e" counsel-find-file nil)
  ("E" my/dired-curr-dir nil)
  ("M-e" my/change-default-directory nil)

  ;; Find
  ("f" ellocate nil)
  ("F" my/counsel-ag nil)

  ;; Browser
  ("b" my/switch-w3m-buffer nil)
  ("B" my/browser-activate-tab nil)

  ;; Switch buffer
  ("a" ivy-switch-buffer nil)
  ("A" my/switch-to-last-buffer nil)

  ;; Kill buffer
  ("k" my/auto-kill-buffer nil)

  ;; Move around in buffer
  ("C-u" evil-scroll-up nil)
  ("C-w" evil-scroll-down nil)

  ("y" counsel-linux-app nil)

  ;; Switch window configuration
  ("t" my/load-window-config nil)
  ("T" my/add-window-config nil)
  ("C-t" my/delete-window-config nil)

  (";" counsel-bookmark nil)
  (":" my/add-bookmark nil)
  ("C-;" my/delete-bookmark nil)

  ("u" winner-undo nil)
  ("C-r" winner-redo nil)

  ("R" rename-buffer nil)

  ;; Add this to not auto exit insert mode after closing the hydra
  ;; ("<escape>" nil)
  )
#+end_src

** Structural navigation
*** Evil-lispy
#+begin_src emacs-lisp
(defhydra my/lispy-hydra (:hint nil
				:color red)
  "lisp"

  ("H" (call-interactively #'lispy-backward nil))
  ("L" (call-interactively #'lispy-flow nil))

  ("C-l" (call-interactively #'lispy-knight-down) nil)
  ("C-h" (call-interactively #'lispy-knight-up) nil)

  ("l" (call-interactively #'lispy-right) nil)
  ("h" (call-interactively #'lispy-left) nil)

  ;;   ("l" (call-interactively #'down-list) nil)
  ;;   ("h" (call-interactively #'up-list) nil)

  ("N" (call-interactively #'lispy-raise) nil)
  ("P" (call-interactively #'lispy-convolute) nil)

  ("n" (call-interactively #'lispy-down) nil)
  ("p" (call-interactively #'lispy-up) nil)

  ("u" (call-interactively #'undo nil))
  ;;("u" (call-interactively #'lispy-back nil))

  ("e" (call-interactively #'my/auto-eval nil))

  ("o" (call-interactively #'lispy-different nil))
  ("d" (call-interactively #'lispy-kill nil))

  ;;("y" (call-interactively #'lispy-occur nil))


  (">" (call-interactively #'lispy-slurp nil))
  ("<" (call-interactively #'lispy-barf nil))
  ("/" (call-interactively #'lispy-splice nil))

  ;;  ("r" (call-interactively #'lispy-raise nil))
  ;;  ("R" (call-interactively #'lispy-raise-some nil))

  ;;("+" (call-interactively #'lispy-join nil))

  ;;  ("C" (call-interactively #'lispy-splice nil))
  ;;  ("X" (call-interactively #'lispy-splice nil))
  ;;  ("w" (call-interactively #'lispy-splice nil))
  ;;  ("s" (call-interactively #'lispy-splice nil))
  ;;  ("/" (call-interactively #'lispy-splice nil))
  ;;  ("/" (call-interactively #'lispy-splice nil))
  ;;  ("/" (call-interactively #'lispy-splice nil))
  ;;  ("/" (call-interactively #'lispy-splice nil))
  ;;  ("/" (call-interactively #'lispy-splice nil))

  ("<escape>" nil nil))
#+end_src

;; navigation
(lispy-define-key map "C" 'lispy-convolute)
(lispy-define-key map "X" 'lispy-convolute-left)
(lispy-define-key map "w" 'lispy-move-up)
(lispy-define-key map "s" 'lispy-move-down)
(lispy-define-key map "O" 'lispy-oneline)
(lispy-define-key map "M" 'lispy-alt-multiline)
(lispy-define-key map "S" 'lispy-stringify)
;; marking
(lispy-define-key map "a" 'lispy-ace-symbol
  :override '(cond ((looking-at lispy-outline)
                    (lispy-meta-return))))
(lispy-define-key map "H" 'lispy-ace-symbol-replace)
(lispy-define-key map "m" 'lispy-mark-list)
;; dialect-specific
(lispy-define-key map "e" 'lispy-eval)
(lispy-define-key map "E" 'lispy-eval-and-insert)
(lispy-define-key map "G" 'lispy-goto-local)
(lispy-define-key map "g" 'lispy-goto)
(lispy-define-key map "F" 'lispy-follow t)
(lispy-define-key map "D" 'pop-tag-mark)
(lispy-define-key map "A" 'lispy-beginning-of-defun)
(lispy-define-key map "_" 'lispy-underscore)
;; miscellanea
(define-key map (kbd "SPC") 'lispy-space)
(lispy-define-key map "i" 'lispy-tab)
(lispy-define-key map "I" 'lispy-shifttab)
(lispy-define-key map "N" 'lispy-narrow)
(lispy-define-key map "W" 'lispy-widen)
(lispy-define-key map "c" 'lispy-clone)
(lispy-define-key map "u" 'lispy-undo)
(lispy-define-key map "q" 'lispy-ace-paren
  :override '(cond ((bound-and-true-p view-mode)
                    (View-quit))))
(lispy-define-key map "Q" 'lispy-ace-char)
(lispy-define-key map "v" 'lispy-view)
(lispy-define-key map "t" 'lispy-teleport
  :override '(cond ((looking-at lispy-outline)
                    (end-of-line))))
(lispy-define-key map "n" 'lispy-new-copy)
(lispy-define-key map "b" 'lispy-back)
(lispy-define-key map "B" 'lispy-ediff-regions)
(lispy-define-key map "x" 'lispy-x)
(lispy-define-key map "Z" 'lispy-edebug-stop)
(lispy-define-key map "V" 'lispy-visit)
(lispy-define-key map "-" 'lispy-ace-subword)
(lispy-define-key map "." 'lispy-repeat)
(lispy-define-key map "~" 'lispy-tilde)

Goto
("d" lispy-goto)
("l" lispy-goto-local)
("r" lispy-goto-recursive)
("p" lispy-goto-projectile)
("f" lispy-follow)
("b" pop-tag-mark)
("q" lispy-quit)
("j" lispy-goto-def-down)
("a" lispy-goto-def-ace)
("e" lispy-goto-elisp-commands)

Other
(("h" lispy-move-left)
 ("j" lispy-down-slurp)
 ("k" lispy-up-slurp)
 ("l" lispy-move-right)
 ("SPC" lispy-other-space)
 ("g" lispy-goto-mode)))

Knight
  ("j" lispy-knight-down)
  ("k" lispy-knight-up)
   ("z" nil))

*** Structured haskell mode
#+begin_src emacs-lisp
(straight-use-package 'shm)
(require 'shm-case-split)

(defhydra my/structured-haskell-hydra (:hint nil
					     :color red)
  "haskell"
  ("U" (call-interactively '(lambda () (interactive) (insert "undefined"))) nil)

  ;; Also check forward/backward node
  ("l" shm/goto-parent-end nil)
  ("h" shm/goto-parent nil)
  ("RET" (call-interactively #'shm/newline-indent) nil)

  ("N" (call-interactively #'shm/raise) nil)

  ("u" (call-interactively #'undo) nil)

  ("e" (call-interactively #'my/auto-eval) nil)

  ("k" (call-interactively #'shm/yank) nil)
  ("d" (call-interactively #'shm/kill) nil)
  ("D" (call-interactively #'shm/kill-line) nil)

  ("c" (call-interactively #'shm/case-split) nil)

  ("<escape>" nil))
#+end_src

*** Keys
#+begin_src emacs-lisp
(my/evil-universal-define-key my/mod-window-leader-key 'my/window-hydra/body)
(my/evil-universal-define-key my/window-leader-key 'my/window-hydra/body)
#+end_src

(defun my/structural-navigation-state ()
 (interactive)
 (pcase major-mode
   ('haskell-mode (my/structured-haskell-hydra/body))
   (_ (my/lispy-hydra/body))))

(my/evil-visual-define-key "z" 'my/structural-navigation-state)
(my/evil-normal-define-key "z" 'my/structural-navigation-state)

#+begin_src emacs-lisp
(my/evil-visual-define-key "z" 'my/lispy-hydra/body)
(my/evil-normal-define-key "z" 'my/lispy-hydra/body)
#+end_src

* Image modes
** PDF view
#+begin_src emacs-lisp
(defun my/pdf-view-mode()
  (interactive)
  (display-line-numbers-mode -1))

(add-hook 'pdf-view-mode-hook 'my/pdf-view-mode t)
#+end_src

** PDF tools
#+begin_src emacs-lisp
(straight-use-package 'pdf-tools)

(add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . my/init-pdf-tools))
#+end_src
(add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))

#+begin_src emacs-lisp
(setq my/pdf-tools-installed nil)

(defun my/init-pdf-tools ()
  (interactive)
  (if (not my/pdf-tools-installed)
      (progn
	(require 'pdf-view)
	(pdf-tools-install)
	;; reload buffer with everything set
	(revert-buffer :ignore-auto :noconfirm)))
  (setq my/pdf-tools-installed t)
  (pdf-view-mode))
#+end_src

(add-hook 'pdf-view-mode-hook 'my/init-pdf-tools)

Enable pdf-links
#+begin_src emacs-lisp
(add-hook 'pdf-view-mode-hook 'pdf-links-minor-mode)
#+end_src

Remove default keys
#+begin_src emacs-lisp
(setq pdf-view-mode-map (make-sparse-keymap))
#+end_src

*** Keys
Disable insert mode
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap evil-insert] 'evil-force-normal-state)
#+end_src

Scroll half page
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap View-scroll-half-page-backward] 'pdf-view-scroll-down-or-previous-page)
(define-key pdf-view-mode-map [remap View-scroll-half-page-forward] 'pdf-view-scroll-up-or-next-page)

(define-key pdf-view-mode-map [remap evil-scroll-up] 'pdf-view-scroll-down-or-previous-page)
(define-key pdf-view-mode-map [remap evil-scroll-down] 'pdf-view-scroll-up-or-next-page)
#+end_src

goto
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap evil-goto-first-line] 'pdf-view-first-page)
#+end_src

(kbd "G") = (evil-goto-line LAST-LINE)
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap evil-goto-line] 'pdf-view-last-page)
#+end_src
search
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap counsel-grep-or-swiper] 'isearch-forward)
(define-key pdf-view-mode-map [remap my/use-swiper-or-grep] 'isearch-forward)
(define-key pdf-view-mode-map [remap swiper] 'isearch-forward)
(define-key pdf-view-mode-map [remap counsel-grep] 'isearch-forward)
#+end_src

Movement
#+begin_src emacs-lisp
(define-key pdf-view-mode-map [remap evil-next-line] '(lambda () (interactive) (image-next-line 4)))
(define-key pdf-view-mode-map [remap evil-previous-line] '(lambda () (interactive) (image-previous-line 4)))

(define-key pdf-view-mode-map [remap evil-forward-char] '(lambda () (interactive) (image-forward-hscroll 8)))
(define-key pdf-view-mode-map [remap evil-backward-char] '(lambda () (interactive) (image-backward-hscroll 8)))
#+end_src

Disable other modes
#+begin_src emacs-lisp
(evil-define-key 'normal pdf-view-mode-map (kbd "i") 'nil)
(evil-define-key 'normal pdf-view-mode-map (kbd "v") 'nil)
(evil-define-key 'normal pdf-view-mode-map (kbd "R") 'nil)
#+end_src

Zoom
#+begin_src emacs-lisp
(evil-define-key 'normal pdf-view-mode-map (kbd "-") 'pdf-view-shrink)
(evil-define-key 'normal pdf-view-mode-map (kbd "=") 'pdf-view-enlarge)
(evil-define-key 'normal pdf-view-mode-map (kbd "_") 'pdf-view-scale-reset)
(evil-define-key 'normal pdf-view-mode-map (kbd "+") 'pdf-view-scale-reset)
#+end_src

Add to leader map
#+begin_src emacs-lisp
(define-prefix-command 'my/pdf-view-mode-map)
(evil-define-key 'normal pdf-view-mode-map (kbd (concat my/leader-map-key " a")) 'my/pdf-view-mode-map)

(define-key my/pdf-view-mode-map (kbd "o") 'pdf-occur)
(define-key my/pdf-view-mode-map (kbd "t") 'doc-view-open-text)
(define-key my/pdf-view-mode-map (kbd "n") 'pdf-view-midnight-minor-mode)
(define-key my/pdf-view-mode-map (kbd "g") 'pdf-view-goto-label)
(define-key my/pdf-view-mode-map (kbd "i") 'pdf-view-extract-region-image)
#+end_src

** Image mode
#+begin_src emacs-lisp
(require 'image-mode)

(add-hook 'image-mode-hook '(lambda () (interactive) (display-line-numbers-mode -1)))
#+end_src

Make animated images loop
#+begin_src emacs-lisp
(setq image-animate-loop t)
#+end_src

*** Open otf fonts with image mode
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.otf\\'" . image-mode))
#+end_src

*** Blimp
#+begin_src emacs-lisp
(straight-use-package 'blimp)

(setq eimp-enable-undo t)

(add-hook 'image-mode-hook 'blimp-mode)
#+end_src

**** Recolor
#+begin_src emacs-lisp
(defun my/blimp-annotate-middle()
  (interactive)
  (blimp-add-to-command-stack (list "-gravity" "Center" "-fill" "red" "-pointsize" "25" "-annotate" "0,0" (completing-read "enter text " nil)))
  (blimp-execute-command-stack)
  (sleep-for 0.2))
#+end_src

*** Keys
#+begin_src emacs-lisp
(evil-define-key 'normal image-mode-map (kbd "-") 'image-decrease-size)
(evil-define-key 'normal image-mode-map (kbd "=") 'image-increase-size)
(evil-define-key 'normal image-mode-map (kbd "_") 'image-transform-fit-to-height)
(evil-define-key 'normal image-mode-map (kbd "+") 'image-transform-fit-to-width)

(evil-define-key 'normal image-mode-map (kbd "C-u") 'image-scroll-down)
(evil-define-key 'normal image-mode-map (kbd "C-w") 'image-scroll-up)

(evil-define-key 'normal image-mode-map (kbd "n") '(lambda () (interactive) (image-next-line 8)))
(evil-define-key 'normal image-mode-map (kbd "p") '(lambda () (interactive) (image-previous-line 8)))
(evil-define-key 'normal image-mode-map (kbd "h") '(lambda () (interactive) (image-backward-hscroll 8)))
(evil-define-key 'normal image-mode-map (kbd "l") '(lambda () (interactive) (image-forward-hscroll 8)))

(evil-define-key 'normal image-mode-map (kbd "G") '(lambda () (interactive) (image-next-line 1000)))
(evil-define-key 'normal image-mode-map (kbd "g g") '(lambda () (interactive) (image-previous-line 1000)))

(evil-define-key 'normal image-mode-map (kbd "$") '(lambda () (interactive) (image-forward-hscroll 1000)))
(evil-define-key 'normal image-mode-map (kbd "0") '(lambda () (interactive) (image-backward-hscroll 1000)))

(define-prefix-command 'my/image-mode-map)
(evil-define-key 'normal image-mode-map (kbd (concat my/leader-map-key " a")) 'my/image-mode-map)

(define-key my/image-mode-map (kbd "i") 'blimp-interface)
(define-key my/image-mode-map (kbd "I") 'blimp-interface-execute)

(define-key my/image-mode-map (kbd "r") 'blimp-clear-command-stack)
(define-key my/image-mode-map (kbd "e") 'blimp-execute-command-stack)
(define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)
(define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)

(define-key my/image-mode-map (kbd "a") 'my/blimp-annotate-middle)
#+end_src

* Spray
#+begin_src emacs-lisp
(straight-use-package 'spray)
(require 'spray)

(setq spray-wpm 500)

(define-key spray-mode-map (kbd "p") 'spray-slower)
(define-key spray-mode-map (kbd "n") 'spray-faster)

(define-key my/leader-map (kbd "M-v") 'spray-mode)
#+end_src

* Ligatures
#+begin_src emacs-lisp
(if window-system
    (global-prettify-symbols-mode 1))
(setq prettify-symbols-unprettify-at-point 'right-edge)
#+end_src

Redefine so that prettify mode is enabled even if a buffer local symbols alist isn't defined
(defun turn-on-prettify-symbols-mode ()
(when (not prettify-symbols-mode)
(prettify-symbols-mode 1)))

Replace comments with symbol
"^[\s\\|\t]*;+"
\\(^ *;; \\*\\)

** Magit
Prettify symbols doesn't work with magit
#+begin_src emacs-lisp
(add-hook 'magit-mode-hook '(lambda () (interactive) (prettify-symbols-mode -1)))
#+end_src

** Symbols
Read =reference-point-alist= to understand how to merge characters and add spaces to characters

*** Generic
#+begin_src emacs-lisp
(defconst my/generic-equality-symbols
  '(
    ("==" . ?≡)
    ("/=" . ?≢)
    ("!=" . ?≠)
    (">=" . ?≥)
    ("<=" . ?≤)
    ))

(defconst my/generic-arrow-symbols
  '(
    ;; Fish here is a bit wrong but there isn't a proper double arrowed one in the utf spec that I could find
    ;; ("<=<" . ?↢)
    ;; (">=>" . ?↣)

    ("<-<" . ?↢)
    (">->" . ?↣)

    ("-<" . ?⤙)
    (">-" . ?⤚)

    ("~>" . ?⇝)
    ("<~" . ?⇜)

    ("->" . ?→)
    ("<-" . ?←)

    ("=>" . ?⇒)
    ;; Conflicting with equality symbols
    ;; ("<=" . ?⇐)

    ("->>" . ?↠)
    ("<<-" . ?↞)

    ("|>" . ?⊳)
    ("<|" . ?⊲)

    ("<<" . ?≪)
    (">>" . ?≫)

    ("<<<" . ?⋘)
    (">>>" . ?⋙)

    ("><" . ?⋈)
    ))

(defconst my/generic-greek-symbols
  '(("lambda" . ?λ)))

(defconst my/generic-logic-symbols
  '(("&&" . ?∧)
    ("||" . ?∨)))

(setq my/pretty-comment-symbol ?|)

(when window-system
  ;; https://www.w3schools.com/charsets/ref_utf_block.asp
  ;; https://en.wikipedia.org/wiki/Block_Elements
  ;; █ comment
  ;; ▉ comment
  ;; ▊ comment
  ;; ▋ comment
  ;; ▌ comment
  ;; ▌ comment
  ;; ▍ comment
  ;; ▎ comment
  ;; ▏ comment
  ;; ▐ comment

  ;; (setq my/pretty-comment-symbol ?\x2502)
  ;; (setq my/pretty-comment-symbol ?█)
  ;; (setq my/pretty-comment-symbol ?▏)
  ;; (setq my/pretty-comment-symbol ?▐)
  (setq my/pretty-comment-symbol ?▍)
  )

(defun my/prettify-comment ()
  `((,(string-trim comment-start) . ,my/pretty-comment-symbol)))

(defun my/prettify-comment-lisp ()
  `((,(concat (string-trim comment-start) (string-trim comment-start)) . ,my/pretty-comment-symbol)))

(defun my/prettify-outline-heading ()
  `(
    (,(concat (string-trim comment-start) " *") . ?◉)
    (,(concat (string-trim comment-start) " **") . (?\s (Br . Bl) ?○))
    (,(concat (string-trim comment-start) " ***") . (?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(concat (string-trim comment-start) " ****") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))
    (,(concat (string-trim comment-start) " *****") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?◉))
    (,(concat (string-trim comment-start) " ******") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?○))
    (,(concat (string-trim comment-start) " *******") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(concat (string-trim comment-start) " ********") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))))

(defun my/prettify-outline-heading-lisp ()
  `((,(concat (string-trim comment-start) (string-trim comment-start) " *") . ?◉)
    (,(concat (string-trim comment-start) (string-trim comment-start) " **") . (?\s (Br . Bl) ?○))
    (,(concat (string-trim comment-start) (string-trim comment-start) " ***") . (?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(concat (string-trim comment-start) (string-trim comment-start) " ****") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))
    (,(concat (string-trim comment-start) (string-trim comment-start) " *****") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?◉))
    (,(concat (string-trim comment-start) (string-trim comment-start) " ******") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?○))
    (,(concat (string-trim comment-start) (string-trim comment-start) " *******") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(concat (string-trim comment-start) (string-trim comment-start) " ********") . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))))

(defun my/prettify-outline-heading-lisp-classic ()
  `((,(my/repeat-char (string-trim comment-start) "" 3) . ?◉)
    (,(my/repeat-char (string-trim comment-start) "" 4) . (?\s (Br . Bl) ?○))
    (,(my/repeat-char (string-trim comment-start) "" 5) . (?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(my/repeat-char (string-trim comment-start) "" 6) . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))
    (,(my/repeat-char (string-trim comment-start) "" 7) . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?◉))
    (,(my/repeat-char (string-trim comment-start) "" 8) . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?○))
    (,(my/repeat-char (string-trim comment-start) "" 9) . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✸))
    (,(my/repeat-char (string-trim comment-start) "" 10) . (?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?\s (Br . Bl) ?✿))))
#+end_src

*** Fsharp
#+begin_src emacs-lisp
(defconst my/fsharp-symbols
  (list))
#+end_src

*** Haskell
https://github.com/roelvandijk/base-unicode-symbols
https://github.com/enomsg/vim-haskellConcealPlus/blob/master/after/syntax/haskell.vim
http://haskell.github.io/haskell-mode/manual/latest/Unicode-support.html#Unicode-support
https://github.com/roelvandijk/emacs-haskell-unicode-input-method/blob/master/haskell-unicode-input-method.el
#+begin_src emacs-lisp
(defconst my/haskell-symbols
  '(("\\" . ?λ)
    ("()" . ?∅)
    ("!!" . ?‼)
    ("sqrt" . ?√)
    ("undefined" . ?⊥)
    ("pi" . ?π)
    ("not" . ?¬)
    ;;("::" . ?∷)
    ("exists" . ?∃)

    ;; Here we construct a custom symbol that has the spaces that are removed when replacing " . " with a single char
    (" . " . (?\s (Br . Bl) ?\s (Bc . Bc) ?\s (Br . Bl) ?\s (Bc . Bc) ?∘)) ; "○"
    ;; Doesn't work?
    ;;haskell-font-lock-dot-is-not-composition)
    ("forall" . ?∀)

    ;; ("(*)" . ?×)

    ;; Foldable
    ("elem" . ?∈)
    ("notElem" . ?∉)

    ;; List
    ("[]" . ?ε)
    ("++" . ?⧺)
    ("union" . ?∪)
    ("intersect" . ?∩)
    ("isSubsetOf" . ?⊆)
    ("isProperSubsetOf" . ?⊂)

    ;; ("\\" . ?∖)

    ;; Monoid
    ("mempty" . ?∅)
    ("mappend" . ?⊕)

    ;; Arrows
    ("***" . ?⁂)
    ("|||" . ?⫴)
    ("+++" . ?⧻)
    ))

(defconst my/haskell-type-symbols
  '(
    ("Bool" . ?𝔹)
    ("Real" . ?ℝ)
    ("Integer" . ?ℤ)
    ("Natural" . ?ℕ)
    ("Rational" . ?ℚ)
    ("Irrational" . ?ℙ)
    ))
#+end_src

*** Elisp
#+begin_src emacs-lisp
(defconst my/elisp-symbols
  '(("defun" . ?λ)
    ("not" . ?¬)))
#+end_src

*** Set symbol by mode
#+begin_src emacs-lisp
(defun my/get-pretty-symbols-by-mode (mode)
  (pcase mode
    ('haskell-mode (append
		    (my/prettify-comment)
		    my/haskell-symbols
		    my/haskell-type-symbols
		    my/generic-greek-symbols
		    my/generic-equality-symbols
		    my/generic-arrow-symbols
		    my/generic-logic-symbols
		    (my/prettify-outline-heading)))
    ('fsharp-mode (append
		   (my/prettify-comment)
		   my/fsharp-symbols
		   my/generic-greek-symbols
		   my/generic-equality-symbols
		   my/generic-arrow-symbols
		   (my/prettify-outline-heading)
		   ))
    ('emacs-lisp-mode (append
		       (my/prettify-comment-lisp)
		       my/elisp-symbols
		       my/generic-greek-symbols
		       my/generic-equality-symbols
		       my/generic-arrow-symbols
		       (my/prettify-outline-heading-lisp)
		       ;; (my/prettify-outline-heading-lisp-classic)
		       ))
    ('lisp-interaction-mode (append
			     (my/prettify-comment-lisp)
			     my/elisp-symbols
			     my/generic-greek-symbols
			     my/generic-equality-symbols
			     my/generic-arrow-symbols
			     (my/prettify-outline-heading-lisp)
			     ;; (my/prettify-outline-heading-lisp-classic)
			     ))

    (_ (append
	(my/prettify-comment)
	my/generic-greek-symbols
	my/generic-equality-symbols
	my/generic-arrow-symbols
	my/generic-logic-symbols
	(my/prettify-outline-heading)
	))))

(add-hook 'prog-mode-hook '(lambda () (interactive)
			     (setq-local prettify-symbols-alist
					 (my/get-pretty-symbols-by-mode major-mode))))
#+end_src

** Enable modify symbols inside comment blocks
#+begin_src emacs-lisp
(defun my/prettify-symbols-default-compose-p (start end _match)
  "Return true iff the symbol MATCH should be composed.
   The symbol starts at position START and ends at position END.
   This is the default for `prettify-symbols-compose-predicate'
   which is suitable for most programming languages such as C or Lisp."
  ;; Check that the chars should really be composed into a symbol.
  (let* ((syntaxes-beg (if (memq (char-syntax (char-after start)) '(?w ?_))
			   '(?w ?_) '(?. ?\\)))
	 (syntaxes-end (if (memq (char-syntax (char-before end)) '(?w ?_))
			   '(?w ?_) '(?. ?\\))))
    (not (or (memq (char-syntax (or (char-before start) ?\s)) syntaxes-beg)
	     (memq (char-syntax (or (char-after end) ?\s)) syntaxes-end)
	     ;; It looks like this part makes it ignore comments, remove it
	     ;;(nth 8 (syntax-ppss))
	     ))))

(setq-default prettify-symbols-compose-predicate #'my/prettify-symbols-default-compose-p)
#+end_src

* Visuals
** Indicate empty lines
#+begin_src emacs-lisp
(setq-default indicate-empty-lines t)
#+end_src

** Center text
#+begin_src emacs-lisp
(straight-use-package 'olivetti)

(setq-default olivetti-body-width 150)

(define-key my/leader-map (kbd "V") 'olivetti-mode)
#+end_src

** Fringe size
Used by diff-hl and flycheck
Fringe only on the left side
#+begin_src emacs-lisp
(fringe-mode '(5 . 5))
#+end_src

** Beacon
(straight-use-package 'beacon)

(beacon-mode 1)

** Rainbow
Changes background of eg. #FF00FF to represent color
#+begin_src emacs-lisp
(straight-use-package 'rainbow-mode)
#+end_src

** Highlight current line
#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src

** Symbol overlay
Supposed to be faster thang highlight-thing
#+begin_src emacs-lisp
(straight-use-package '(symbol-overlay :type git :host github :repo "walseb/symbol-overlay"))

(setq symbol-overlay-idle-time nil)

(define-globalized-minor-mode global-symbol-overlay
  symbol-overlay-mode symbol-overlay-mode)
(symbol-overlay-mode)
(global-symbol-overlay)
#+end_src

*** Disable in insert mode
#+begin_src emacs-lisp
(defun symbol-overlay-post-command ()
  "Installed on `post-command-hook'."
  (unless (or (not (eq evil-state 'normal)) (string= (symbol-overlay-get-symbol nil t) symbol-overlay-temp-symbol))
    (symbol-overlay-remove-temp)
    (when (not symbol-overlay-idle-time)
      (symbol-overlay-maybe-put-temp))))
#+end_src

** Show paren
Highlights matching paren under cursor

*** Delay
#+begin_src emacs-lisp
(setq show-paren-delay 0)
#+end_src

*** Set paren style
#+begin_src emacs-lisp
(setq show-paren-style 'paren)
#+end_src

*** Show offscreen expression
https://with-emacs.com/posts/editing/show-matching-lines-when-parentheses-go-off-screen/
Not implemented yet
Define face to use
#+begin_src emacs-lisp
(defface my/show-paren-offscreen-face
  '((t :inherit highlight))
  "Face for showing function names offscreen")

(setq show-paren-highlight-openparen t)
(setq show-paren-when-point-inside-paren nil)
(setq show-paren-when-point-in-periphery t)

(show-paren-mode 1)
#+end_src

** Highlight parens
Highlights surrounding parens
#+begin_src emacs-lisp
(straight-use-package 'highlight-parentheses)
(global-highlight-parentheses-mode)
#+end_src

*** Set delay
#+begin_src emacs-lisp
(setq hl-paren-delay 0)
#+end_src

** Highlight changes
#+begin_src emacs-lisp
(define-key my/leader-map (kbd "q") 'highlight-changes-mode)
#+end_src

** Scrollbar
#+begin_src emacs-lisp
(straight-use-package 'yascroll)
(global-yascroll-bar-mode)
(setq yascroll:scroll-bar '(left-fringe))
#+end_src

*** Fix for emacs 27
Seems like this doesn't apply any more to latest?
;; Yasnippet is broken on emacs 27 with error:
;; yascroll: (wrong-number-of-arguments (left-width right-width outside-margins) 4)
;; This fixes that
(when (>= emacs-major-version 27)
  (defun yascroll:choose-scroll-bar ()
    (when (memq window-system yascroll:enabled-window-systems)
      (cl-destructuring-bind (left-width right-width outside-margins pers)
	  (window-fringes)
	(cl-loop for scroll-bar in (yascroll:listify yascroll:scroll-bar)
		 if (or (eq scroll-bar 'text-area)
			(and (eq scroll-bar 'left-fringe)
			     (> left-width 0))
			(and (eq scroll-bar 'right-fringe)
			     (> right-width 0)))
		 return scroll-bar)))))

** Hl-Todo
#+begin_src emacs-lisp
(straight-use-package 'hl-todo)

(global-hl-todo-mode)
#+end_src

** Hl-anything
Really buggy and makes buffer switching slow
(straight-use-package 'hl-anything)

(define-globalized-minor-mode global-hl-highlight-mode
  hl-highlight-mode hl-highlight-mode)
(hl-highlight-mode)
(global-hl-highlight-mode 1)

(define-key my/leader-map (kbd "M") 'hl-highlight-thingatpt-local)

** Disable blinking cursor
#+begin_src emacs-lisp
(blink-cursor-mode 0)
#+end_src

** Disable GUI
#+begin_src emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

** Disable comments with toggle
#+begin_src emacs-lisp
(straight-use-package 'hide-comnt)
(require 'hide-comnt)
(define-key my/leader-map (kbd "c") 'hide/show-comments-toggle)
#+end_src

** Font lock
*** Font lock profiler
Use font-lock-profiler-buffer
#+begin_src emacs-lisp
(straight-use-package 'font-lock-profiler)
#+end_src

*** Remove unnecessary font-locks
**** Haskell
#+begin_src emacs-lisp
(setq haskell-font-lock-keywords '())

(defun haskell-font-lock-keywords ()
  '())
#+end_src

**** Elisp
#+begin_src emacs-lisp
(setq lisp-el-font-lock-keywords '())
(setq lisp-el-font-lock-keywords-1 '())
(setq lisp-el-font-lock-keywords-2 '())
#+end_src

**** Csharp
Doesn't seem to work fully, there are still lots of keywords left
#+begin_src emacs-lisp
(setq csharp-font-lock-keywords '())
(setq csharp-font-lock-keywords-1 '())
(setq csharp-font-lock-keywords-2 '())
(setq csharp-font-lock-keywords-3 '())
#+end_src

** Modeline
Make mode line appear in echo area instead of in the mode line area. This saves space and makes it so that the mode line can't be split

*** Calculate frame width
#+begin_src emacs-lisp
(defvar my/frame-width (frame-width))

(defun my/frame-width-update()
  (interactive)
  (setq my/frame-width (frame-width)))
#+end_src

*** Disable mode line
#+begin_src emacs-lisp
(setq mode-line-format nil)
(setq-default mode-line-format nil)
#+end_src

*** Mode line highlight face
#+begin_src emacs-lisp
(defface my/mode-line-highlight
  '((t :inherit highlight))
  "Face for highlighting something in mode line")
#+end_src

*** Mode line contents
Don't set it directly here, because the variable is needed to fix exwm
#+begin_src emacs-lisp
(setq-default header-line-format
	      (quote
	       (
		;; Print if recursive editing
		"%["

		;; Information bar
		mode-line-mule-info
		mode-line-client

		;; If buffer is modified
		mode-line-modified

		;; Turns into @ when remote
		mode-line-remote

		" "

		;; Print current line number
		;;"%l"
		;;"%p"
		;;(:eval (format "%d" (/ (window-start) 0.01 (point-max))))
		;;"%p"

		;;"@"
		;; Print total line number and buffer position
		;; (:eval
		;; (let
		;; ((line-number-count (+ (count-lines (point-min) (point-max)) 1))
		;; (point-pos (count-lines (point) (point-min))))
		;; (let
		;; ((point-in-buffer-percentage (floor (* (/ (float point-pos) line-number-count) 100))))
		;; (concat (int-to-string point-in-buffer-percentage) "% ~" (int-to-string line-number-count)))))

		(:eval
		 (int-to-string (count-lines (point-min) (point-max))))

		;;"%I"

		;; is narrowed
		"%n"

		;; Is loccur
		(:eval (when loccur-mode
			 " Loccur"))

		" | "

		;; Print error if any
		"%e"

		;; Print mode
		(:eval (when defining-kbd-macro
			 (concat
			  (propertize
			   "[MACRO]"
			   'face 'my/mode-line-highlight)
			  " ")))

		;; Print buffer name
		"%b > "

		;; Print mode
		"%m"

		;; Git
		(:eval
		 (if (and my/projectile-project-name my/buffer-git-branch (not (string= my/projectile-project-name "-")))
		     (concat
		      " > "
		      my/buffer-git-branch
		      "@"
		      my/projectile-project-name
		      (when my/git-changes-string
			(concat
			 "["
			 my/git-changes-string
			 "]"
			 )))))

		(" "
		 (company-candidates
		  (:eval
		   (if (consp company-backend)
		       (my/company--group-lighter (nth company-selection
						       company-candidates)
						  company-lighter-base)
		     (concat
		      "| "
		      (symbol-name company-backend)
		      )))
		  ;; Symbol when company is not in use
		  ""))
		)))
#+end_src

*** LV-line (top modeline)
Use lv-line to create a mode line on the top of the screen
#+begin_src emacs-lisp
(defvar my/lv-line-format "")
(defconst my/lv-line--buffer " *LV-line*")
(defvar my/lv-line-window nil)
#+end_src

**** Allocate lv line update timings
#+begin_src emacs-lisp
(defvar my/lv-line-update-offset 8)
(defvar my/lv-line-allocated-update-limit my/lv-line-update-offset)
(defvar my/lv-line-allocated-update-current 0)

(defun my/lv-line-allocate-update-time (task)
  (if (> my/lv-line-allocated-update-current my/lv-line-allocated-update-limit)
      (setq my/lv-line-allocated-update-current 0)
    (setq my/lv-line-allocated-update-current (+ my/lv-line-allocated-update-current 1))
    (run-with-timer my/lv-line-allocated-update-current 60 task)))
#+end_src

**** LV-line update
#+begin_src emacs-lisp
(defun my/lv-line-update ()
  (interactive)
  (let* ((buffer (get-buffer my/lv-line--buffer)))
    (if (not buffer)
	(progn
	  (message "LV-line buffer not found - creating new one")
	  (my/lv-line-create)))
    (with-current-buffer buffer
      (erase-buffer)
      (insert (format-mode-line my/lv-line-format)))))
#+end_src

**** Create LV-line at top
#+begin_src emacs-lisp
(defun my/lv-line-set-buffer ()
  (setq-local mode-line-format nil)
  (setq-local header-line-format nil)
  (setq indicate-empty-lines nil)
  (set-window-hscroll my/lv-line-window 0)
  (setq window-size-fixed t)
  (setq truncate-lines t)
  (visual-line-mode -1)

  ;; Offset by 10 pixels to make text fit
  ;;(set-window-fringes (selected-window) 10 0)

  ;; Disable char at end of line
  (set-display-table-slot standard-display-table 0 ?\ )

  ;; Disable cursor
  (setq cursor-type nil)
  (setq cursor-in-non-selected-windows nil)

  (set-window-dedicated-p my/lv-line-window t)
  (set-window-parameter my/lv-line-window 'no-other-window t))

(defun my/lv-line-create ()
  (interactive)
  (if (not (get-buffer my/lv-line--buffer))
      (generate-new-buffer my/lv-line--buffer))
  (if (not (window-live-p my/lv-line-window))
      (let* ((original-window (selected-window)))
	(setq my/lv-line-window
	      (select-window
	       (let ((ignore-window-parameters t))
		 (split-window
		  (frame-root-window) -1 'above))))
	(switch-to-buffer my/lv-line--buffer)
	(my/lv-line-set-buffer)
	(select-window original-window)))
  (my/frame-width-update))
#+end_src

(defun my/lv-line-create ()
"Ensure that LV window is live and return it."
(if (window-live-p my/lv-line-window)
my/lv-line-window
(let ((ori (selected-window)) buf)
(prog1 (setq my/lv-line-window
(select-window
(let ((ignore-window-parameters t))
(split-window
(frame-root-window) -1 'above))))
(my/lv-line-create-buffer)
(select-window ori)))))

**** Update it
#+begin_src emacs-lisp
(defun my/lv-line-start()
  (my/lv-line-create)
  (my/lv-line-update)
  (run-with-timer my/lv-line-update-offset 60 'my/lv-line-update))

(if window-system
    (add-hook 'exwm-init-hook 'my/lv-line-start)
  (my/lv-line-start))
#+end_src

*** Keys
#+begin_src emacs-lisp
(define-prefix-command 'my/mode-line-map)
(define-key my/leader-map (kbd "M-m") 'my/mode-line-map)
#+end_src

**** Garbage Collection
#+begin_src emacs-lisp
(defvar my/mode-line-show-GC-stats nil)
(defun my/mode-line-toggle-show-GC-stats ()
  (interactive)
  (setq my/mode-line-show-GC-stats (not my/mode-line-show-GC-stats)))

(define-key my/mode-line-map (kbd "G") 'my/mode-line-toggle-show-GC-stats)
#+end_src

*** Mode line modules
http://www.holgerschurig.de/en/emacs-tayloring-the-built-in-mode-line/
**** Cursor position
#+begin_src emacs-lisp
(setq mode-line-position
      '(;; %p print percent of buffer above top of window, o Top, Bot or All
	;; (-3 "%p")
	;; %I print the size of the buffer, with kmG etc
	;; (size-indication-mode ("/" (-4 "%I")))
	;; " "
	;; %l print the current line number
	;; %c print the current column
	(line-number-mode ("%l" (column-number-mode ":%c")))))
#+end_src

**** Buffer name
(defvar my/buffer-name "")
(defvar my/max-buffer-name-length 10)

(defun my/update-max-buffer-name-length()
(interactive)
(setq my/max-buffer-name-length (floor (/ (frame-width) 10))))

(defun my/update-buffer-name-string (BUFFER)
(interactive)
(setq my/buffer-name
(if (> (string-width BUFFER) my/max-buffer-name-length)
(concat (string-trim-right (substring BUFFER 0 my/max-buffer-name-length)) "...")
BUFFER)))

(if window-system
;; At this point in the code, exwm hasn't had time to maximize the emacs frame
(add-hook 'exwm-init-hook 'my/update-max-buffer-name-length)
;; If on terminal, just run it now since it's always maximized
(my/update-max-buffer-name-length))

;;(add-hook 'buffer-list-update-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)
(add-hook 'my/switch-buffer-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)

;;(add-hook 'window-configuration-change-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)

**** Which function
#+begin_src emacs-lisp
(require 'which-func)

(setq which-func-unknown "")

(setq which-func-current
      '(:eval
	(let ((result (gethash (selected-window) which-func-table)))
	  (if result
	      (concat
	       " | < "
	       (replace-regexp-in-string "%" "%%" result)
	       " >"
	       )))))
#+end_src

(which-function-mode 1)

(remove-hook 'my/switch-buffer-hook 'which-func-update)

(replace-regexp-in-string "%" "%%"
(or
(gethash
(selected-window)
which-func-table)
which-func-unknown)))
Could be used if doing func mode manually
(setq my/which-function-modes '(c-mode emacs-lisp-mode))

(defun my/enable-which-function ()
(if (member major-mode my/which-function-modes)
(which-function-mode 1)))

(add-hook 'prog-mode-hook 'my/enable-which-function)

**** CPU heat
#+begin_src emacs-lisp
(defvar my/mode-line-enable-cpu-temp nil)

(if (and
     ;; If lm_sensors is not installed
     (my/is-system-package-installed 'sensors)
     ;; If there aren't any cpu heat sensors (eg. virtual machine)
     (= 0 (string-match-p ""
			  (shell-command-to-string "sensors | grep \"Core 0:\"")))
     ;; If it returns "no sensors found"
     (not (= 0 (string-match-p "No sensors found"
			       (shell-command-to-string "sensors | grep \"Core 0:\"")))))
    (setq my/mode-line-enable-cpu-temp t))

(defvar my/cpu-temp "")

(defun my/update-cpu-temp ()
  (interactive)
  ;; FIXME emacs regexes are wierd, use position of temp in print insead
  (string-match "\+.*C\s" (shell-command-to-string "sensors | grep \"Core 0:\""))
  (setq my/cpu-temp (substring (match-string 0 (shell-command-to-string "sensors | grep \"Core 0:\"")) 0 -3)))

(if my/mode-line-enable-cpu-temp
    (my/lv-line-allocate-update-time 'my/update-cpu-temp))
#+end_src

**** Disk space
#+begin_src emacs-lisp
(defvar my/disk-space nil)
(defun my/update-disk-space ()
  (interactive)
  (setq my/disk-space (my/file-size-human-readable (floor (* 1000 (string-to-number (get-free-disk-space user-emacs-directory)))))))
#+end_src

**** Network traffic
***** Linux
#+begin_src emacs-lisp
(defvar my/mode-line-enable-network-traffic nil)

(if (file-exists-p "/proc/net/dev")
    (setq my/mode-line-enable-network-traffic t))
#+end_src

****** RX
Received
#+begin_src emacs-lisp
(defvar my/rx 0)
(defvar my/rx-delta-formatted "0")

(defun my/linux-get-network-rx ()
  (with-temp-buffer
    (insert-file-contents "/proc/net/dev")
    (goto-char 1)
    (let ((rx 0))
      (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
	(unless (string= (match-string 1) "lo")
	  (setq rx (+ rx (read (current-buffer))))))
      rx)))

(defun my/linux-update-network-rx-delta ()
  (interactive)
  (setq my/rx-new (my/linux-get-network-rx))
  (setq my/rx-delta-formatted (my/file-size-human-readable (- my/rx-new my/rx)))
  (setq my/rx my/rx-new))

(if my/mode-line-enable-network-traffic
    (my/lv-line-allocate-update-time 'my/linux-update-network-rx-delta))

(my/linux-update-network-rx-delta)
#+end_src

****** TX
Transmitted
#+begin_src emacs-lisp
(setq my/tx 0)
(defvar my/tx-delta-formatted "0")

(defun my/linux-get-network-tx ()
  (with-temp-buffer
    (insert-file-contents "/proc/net/dev")
    (goto-char 1)
    (let ((tx 0))
      (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
	(unless (string= (match-string 1) "lo")
	  (forward-word 8)
	  (setq tx (+ tx (read (current-buffer))))))
      tx)))

(defun my/linux-update-network-tx-delta ()
  (interactive)
  (setq my/tx-new (my/linux-get-network-tx))
  (setq my/tx-delta-formatted  (my/file-size-human-readable (- my/tx-new my/tx)))
  (setq my/tx my/tx-new))

(if my/mode-line-enable-network-traffic
    (my/lv-line-allocate-update-time 'my/linux-update-network-tx-delta))

(my/linux-update-network-tx-delta)
#+end_src

**** Mail
#+begin_src emacs-lisp
(defvar my/gnus-unread-string nil)

(defun my/gnus-update-unread()
  (my/gnus-scan-unread)
  (setq my/gnus-unread-string
	(concat
	 "M:"
	 (my/gnus-get-unread-mail-count)
	 " > N:"
	 (my/gnus-get-unread-news-count)))
  (my/lv-line-update))

(add-hook 'my/sync-mail-hook 'my/gnus-update-unread)
(add-hook 'gnus-summary-exit-hook 'my/gnus-update-unread)
#+end_src

**** Battery
If there is a battery, display it in the mode line
#+begin_src emacs-lisp
(require 'battery)

(display-battery-mode 1)
(setq battery-mode-line-format "%th - %p")
#+end_src

***** Reload battery display mode
#+begin_src emacs-lisp
(defun my/battery-display-mode-reload ()
  (interactive)
  (display-battery-mode -1)
  (setq battery-status-function
	(cond ((and (eq system-type 'gnu/linux)
		    (file-readable-p "/proc/apm"))
	       #'battery-linux-proc-apm)
	      ((and (eq system-type 'gnu/linux)
		    (file-directory-p "/proc/acpi/battery"))
	       #'battery-linux-proc-acpi)
	      ((and (eq system-type 'gnu/linux)
		    (file-directory-p "/sys/class/power_supply/")
		    (directory-files "/sys/class/power_supply/" nil
				     battery-linux-sysfs-regexp))
	       #'battery-linux-sysfs)
	      ((and (eq system-type 'berkeley-unix)
		    (file-executable-p "/usr/sbin/apm"))
	       #'battery-bsd-apm)
	      ((and (eq system-type 'darwin)
		    (condition-case nil
			(with-temp-buffer
			  (and (eq (call-process "pmset" nil t nil "-g" "ps") 0)
			       (> (buffer-size) 0)))
		      (error nil)))
	       #'battery-pmset)
	      ((fboundp 'w32-battery-status)
	       #'w32-battery-status)))
  (display-battery-mode 1))
#+end_src

**** Date and time
Display time and date in good format (also displays CPU load)
#+begin_src emacs-lisp
(defvar my/date "")
(defvar my/time "")

(defun my/update-date ()
  (interactive)
  (setq my/date (format-time-string "%d-%m-%Y")))

(defun my/update-time ()
  (interactive)
  (setq my/time (format-time-string "%H:%M")))

(my/lv-line-allocate-update-time 'my/update-time)
(run-with-timer 0 3600 'my/update-date)
#+end_src

Update date now
#+begin_src emacs-lisp
(my/update-time)
(my/update-date)
#+end_src

**** Git project and branch name
#+begin_src emacs-lisp
(require 'vc-git)
#+end_src

When projectile-mode is on, project name is updated on every keypress, here it is fixed
#+begin_src emacs-lisp
(defvar-local my/projectile-project-name nil)
(defvar-local my/buffer-git-branch nil)

(defun my/update-projectile-project-name()
  (interactive)
  ;; Some virtual buffers don't work, but dired-mode does
  (when (or (string= major-mode 'dired-mode) (and buffer-file-name (file-exists-p buffer-file-name)))
    (setq my/projectile-project-name (projectile-project-name))
    (setq my/buffer-git-branch (car (vc-git-branches)))))

(add-hook 'my/switch-buffer-hook 'my/update-projectile-project-name)
#+end_src

**** Git changes
#+begin_src emacs-lisp
(require 'diff-hl)
(defvar-local my/git-changes-string nil)

(defvar-local my/vc-insert-count 0)
(defvar-local my/vc-change-count 0)
(defvar-local my/vc-delete-count 0)

(defun my/mode-line-update-git-changes-string ()
  (setq my/git-changes-string (format "+%d ~%d -%d"
				      my/vc-insert-count
				      my/vc-change-count
				      my/vc-delete-count)))

(defun my/mode-line-update-git-changes-string-reset ()
  (setq my/vc-insert-count 0)
  (setq my/vc-change-count 0)
  (setq my/vc-delete-count 0)
  (setq my/git-changes-string nil))

(defun my/modeline-update-git-changes (changes)
  "CHANGES is generated by `(diff-hl-changes)'"
  (my/mode-line-update-git-changes-string-reset)
  (mapc #'(lambda (entry)
	    (pcase (nth 2 entry)
	      ('insert (setq my/vc-insert-count (+ my/vc-insert-count (nth 1 entry))))
	      ('change (setq my/vc-change-count (+ my/vc-change-count (nth 1 entry))))
	      ('delete (setq my/vc-delete-count (+ my/vc-delete-count (nth 1 entry))))))
	changes)
  (my/mode-line-update-git-changes-string))
#+end_src

***** Override old function
#+begin_src emacs-lisp
(defun diff-hl-changes ()
  (my/mode-line-update-git-changes-string-reset)
  (let* ((file buffer-file-name)
	 (backend (vc-backend file)))
    (when backend
      (let ((state (vc-state file backend)))
	(cond
	 ((diff-hl-modified-p state)
	  (let* (diff-auto-refine-mode res)
	    (with-current-buffer (diff-hl-changes-buffer file backend)
	      (goto-char (point-min))
	      (unless (eobp)
		(ignore-errors
		  (diff-beginning-of-hunk t))
		(while (looking-at diff-hunk-header-re-unified)
		  (let ((line (string-to-number (match-string 3)))
			(len (let ((m (match-string 4)))
			       (if m (string-to-number m) 1)))
			(beg (point)))
		    (diff-end-of-hunk)
		    (let* ((inserts (diff-count-matches "^\\+" beg (point)))
			   (deletes (diff-count-matches "^-" beg (point)))
			   (type (cond ((zerop deletes) 'insert)
				       ((zerop inserts) 'delete)
				       (t 'change))))
		      (when (eq type 'delete)
			(setq len 1)
			(cl-incf line))
		      (push (list line len type) res))))))
	    (my/modeline-update-git-changes res)
	    (nreverse res)))
	 ((eq state 'added)
	  `((1 ,(line-number-at-pos (point-max)) insert)))
	 ((eq state 'removed)
	  `((1 ,(line-number-at-pos (point-max)) delete))))))))
#+end_src

**** Load average
#+begin_src emacs-lisp
(defvar my/load-average 0)
(defvar my/high-load-average 2)

(defun my/update-load-average ()
  (interactive)
  (setq my/load-average (/ (nth 0 (load-average)) 100.0)))

(my/lv-line-allocate-update-time 'my/update-load-average)

(my/update-load-average)
#+end_src

**** Ram usage
#+begin_src emacs-lisp
(defvar my/mode-line-enable-available-mem nil)

(if (and (file-exists-p "/proc/meminfo")
	 (progn
	   (with-temp-buffer

	     (insert-file-contents "/proc/meminfo")
	     (setq my/mem-string (buffer-string))
	     (ignore-errors
	       (string-match "MemAvailable:.*\s" my/mem-string)))))
    (setq my/mode-line-enable-available-mem t))

(defvar my/available-mem-formatted "nil")
(defvar my/available-mem 0)

(defun my/linux-update-available-mem ()
  (interactive)
  (with-temp-buffer
    (insert-file-contents "/proc/meminfo")
    (setq my/mem-string (buffer-string))

    (when (ignore-errors
	    (string-match "MemAvailable:.*\s" my/mem-string))
      (setq my/mem-string (match-string 0 my/mem-string))

      ;; Default returns kb, *1000 to get it to bytes
      (setq my/available-mem
	    (* 1000 (string-to-number
		     (substring my/mem-string (string-match "[0-9]" my/mem-string) -1))))

      (setq my/available-mem-formatted (my/file-size-human-readable my/available-mem nil t)))))

(if my/mode-line-enable-available-mem
    (my/lv-line-allocate-update-time 'my/linux-update-available-mem))
#+end_src

Update available mem on startup
#+begin_src emacs-lisp
(my/linux-update-available-mem)
#+end_src

**** Uptime
#+begin_src emacs-lisp
(defvar my/uptime-start-time (float-time))
(defvar my/uptime-total-time-formated "0M")

(defun my/get-uptime-formated-time ()
  (let* ((total-time  (- (float-time) my/uptime-start-time)))
    (if (> total-time (* 60 60))
	(concat (format "%0.1f"(/ total-time 3600.0)) "H")
      (concat (int-to-string (/ (floor total-time) 60)) "M"))))

(defun my/update-uptime-timer ()
  (interactive)
  (setq my/uptime-total-time-formated (my/get-uptime-formated-time)))

(my/lv-line-allocate-update-time 'my/update-uptime-timer)
#+end_src

**** Break timer
In seconds
#+begin_src emacs-lisp
(defvar my/break-time (* 21 60))
(defvar my/enable-breaks t)

(defun my/break-screen ()
  (when my/enable-breaks
    ;; Restart timer
    (my/break-timer-run)

    ;; Show break buffer
    (switch-to-buffer "Break")
    (insert "Break")))

(defun my/break-timer-run ()
  (interactive)
  (run-with-timer my/break-time nil #'my/break-screen))

(when my/enable-breaks
  (my/break-timer-run))
#+end_src

*** Mode line format
Only applicable to X since terminal never stretches, etc
#+begin_src emacs-lisp
(add-hook 'exwm-workspace-switch-hook 'my/frame-width-update)
(add-hook 'exwm-init-hook (lambda () (interactive) (run-with-timer 1 nil '(lambda () (interactive) (my/frame-width-update) (my/lv-line-update)))) t)

(defun my/mode-line-align (left right)
  "Return a string of `window-width' length containing LEFT, and RIGHT aligned respectively."
  (let* ((available-width (- my/frame-width (length left) 2)))
    (format (format "%%s %%%ds" available-width) left right)))
#+end_src

mode-line-format
#+begin_src emacs-lisp
(setq-default my/lv-line-format
	      '(:eval
		(my/mode-line-align
		 (format-mode-line
		  (quote
		   (
		    (:eval my/past-alerts)
		    )))

		 (format-mode-line
		  (quote
		   (
		    "| "

		    (:eval (if my/mode-line-show-GC-stats
			       (concat
				" GC: " (number-to-string (truncate gc-elapsed))
				"(" (number-to-string gcs-done) ")"
				" |"
				)))

		    (:eval (if my/mode-line-enable-network-traffic
			       (concat
				my/tx-delta-formatted " ↑ "
				my/rx-delta-formatted " ↓ "
				"| "
				)))

		    (:eval
		     (when my/mode-line-enable-available-mem
		       (concat
			"MEM: "
			;; If < 100 mb mem, make text red
			(if (< my/available-mem 1000000000)
			    (propertize my/available-mem-formatted 'face `(:background "red"))
			  my/available-mem-formatted)
			" | ")))

		    ;;(:eval (concat "Org:" org-mode-line-string))
		    (:eval (if (boundp 'org-mode-line-string)
			       (concat "Org:" org-mode-line-string " | ")))
		    (:eval (if (not (eq battery-mode-line-string ""))
			       (concat "BAT: " battery-mode-line-string "%%%   | ")))

		    (:eval (if my/mode-line-enable-cpu-temp
			       (concat " - " my/cpu-temp)))

		    "C: "
		    (:eval (number-to-string my/load-average))

		    " |"

		    (:eval (concat " Up: " my/uptime-total-time-formated))

		    (:eval (if (and my/gnus-unread-string (not (string= my/gnus-unread-string "")))
			       (concat " | "
				       my/gnus-unread-string)))


		    " | "

		    (:eval my/time)

		    " - "

		    (:eval my/date)
		    ))))))
#+end_src

**** Csharp
#+begin_src emacs-lisp
(setq csharp-font-lock-keywords '())
(setq csharp-font-lock-keywords-1 '())
(setq csharp-font-lock-keywords-2 '())
(setq csharp-font-lock-keywords-3 '())
#+end_src

**** C
#+begin_src emacs-lisp
(setq cpp-font-lock-keywords '())
(setq c++-font-lock-keywords '())
(setq c++-font-lock-keywords-1 '())
(setq c++-font-lock-keywords-2 '())
(setq c++-font-lock-keywords-3 '())
(setq c-font-lock-keywords '())
(setq c-font-lock-keywords-1 '())
(setq c-font-lock-keywords-2 '())
(setq c-font-lock-keywords-3 '())
#+end_src


* Set theme
#+begin_src emacs-lisp
(defvar my/default-face-list '())

(defun my/set-face-to-default (face-name is-syntax)
  (add-to-list 'my/default-face-list face-name)
  ;; Reset face
  (set-face-attribute face-name nil :family 'unspecified :foundry 'unspecified :width 'unspecified :height 'unspecified :weight 'unspecified :slant 'unspecified :foreground 'unspecified :background 'unspecified :underline 'unspecified :overline 'unspecified :strike-through 'unspecified :box 'unspecified :stipple 'unspecified :font 'unspecified :inherit 'default))
#+end_src

** Define colors
#+begin_src emacs-lisp
(setq my/diff-added-color "#335533")
(setq my/diff-added-hl-color (color-lighten-name "#335533" 20))

(setq my/diff-changed-color "#aaaa22")
(setq my/diff-changed-hl-color (color-lighten-name "#aaaa22" 20))

(setq my/diff-removed-color "#553333")
(setq my/diff-removed-hl-color (color-lighten-name "#553333" 20))

(setq my/diff-ancestor-color "#5f06b26ccd93")
(setq my/diff-ancestor-hl-color (color-lighten-name "#5f06b26ccd93" 20))

(if window-system
    (progn
      (setq my/mark-color my/diff-changed-color)
      (setq my/mark-color-1 (color-darken-name my/diff-changed-color 5))
      (setq my/mark-color-2 (color-darken-name my/diff-changed-color 10))
      (setq my/mark-color-3 (color-darken-name my/diff-changed-color 15))
      (setq my/mark-color-4 (color-darken-name my/diff-changed-color 20))
      (setq my/mark-color-5 (color-darken-name my/diff-changed-color 25))
      (setq my/mark-color-6 (color-darken-name my/diff-changed-color 30))

      (setq my/foreground-color "#E6E1DC")
      ;; (setq my/foreground-color (color-darken-name my/foreground-color 10))
      (setq my/foreground-color-1 (color-darken-name my/foreground-color 5))
      (setq my/foreground-color-2 (color-darken-name my/foreground-color 10))
      (setq my/foreground-color-3 (color-darken-name my/foreground-color 15))
      (setq my/foreground-color-4 (color-darken-name my/foreground-color 20))
      (setq my/foreground-color-5 (color-darken-name my/foreground-color 25))
      (setq my/foreground-color-6 (color-darken-name my/foreground-color 30))

      (setq my/background-color "#121212")
      ;; (setq my/background-color "#212121")
      ;; (setq my/background-color "#232323")
      ;; (setq my/background-color "#000000")
      (setq my/background-color-1 (color-lighten-name my/background-color 5))
      (setq my/background-color-2 (color-lighten-name my/background-color 10))
      (setq my/background-color-3 (color-lighten-name my/background-color 15))
      (setq my/background-color-4 (color-lighten-name my/background-color 20)))

  (setq my/mark-color "yellow")

  (setq my/foreground-color "white")
  (setq my/foreground-color-1 "white")
  (setq my/foreground-color-2 "white")
  (setq my/foreground-color-3 "white")
  (setq my/foreground-color-4 "white")
  (setq my/foreground-color-5 "white")
  (setq my/foreground-color-6 "white")

  (setq my/background-color "black")
  (setq my/background-color-1 "black")
  (setq my/background-color-2 "black")
  (setq my/background-color-3 "black")
  (setq my/background-color-4 "black")

  (setq my/diff-added-color "green")
  (setq my/diff-changed-color "yellow")
  (setq my/diff-removed-color "red"))
#+end_src

** Remove color
#+begin_src emacs-lisp
(defun my/theme-remove-color ()
  (cl-loop for face in (face-list) do
	   ;; Don't change magit faces
	   (if (and (not (string-match "magit" (symbol-name face))) (not (string-match "w3m" (symbol-name face))))
	       (set-face-attribute face nil :foreground nil :background nil))))
#+end_src

** Set colors
*** Default colors
#+begin_src emacs-lisp
(defun my/theme-default-colors ()
  (set-face-attribute 'default nil :foreground my/foreground-color :background my/background-color)
  (set-face-attribute 'link nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'highlight nil :foreground my/foreground-color :background my/mark-color)
  (set-face-attribute 'region nil :foreground my/foreground-color :background my/mark-color)
  (set-face-attribute 'error nil :foreground "#c6350b" :background)
  (set-face-attribute 'warning nil :foreground "DarkOrange" :background)

  (set-face-attribute 'font-lock-doc-face nil :foreground my/foreground-color :background my/background-color-4)
  ;; (set-face-attribute 'font-lock-comment-face nil :foreground (color-lighten-name my/background-color 30) :background my/background-color)
  (set-face-attribute 'font-lock-comment-face nil :foreground (color-lighten-name my/background-color 30) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'font-lock-comment-delimiter-face nil :foreground (color-lighten-name my/background-color 15) :background my/background-color)
  (my/set-face-to-default 'font-lock-string-face t)
  (my/set-face-to-default 'font-lock-function-name-face t))

(defun my/theme-outline-colors ()
  (set-face-attribute 'outline-1 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-2 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-3 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-4 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-5 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-6 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-7 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2))
  (set-face-attribute 'outline-8 nil :foreground (color-darken-name my/foreground-color 50) :background (color-lighten-name my/background-color 2)))

(defun my/theme-header-line-color ()
  (set-face-attribute 'header-line nil
		      :foreground my/foreground-color
		      ;;:background "#063000"
		      :background "#001330")

  (set-face-attribute 'my/mode-line-highlight nil
		      :foreground "#063000"
		      :background my/foreground-color)

  ;; Mode line separator
  ;; Set mode line height
  ;;  (set-face-attribute 'mode-line nil
  ;;                      :foreground my/foreground-color
  ;;                      :background my/background-color-1)
  ;;
  ;;  (set-face-attribute 'mode-line-inactive nil
  ;;                      :foreground my/foreground-color
  ;;                      :background my/background-color)
  )

(defun my/theme-evil-colors ()
  ;; Evil
  (setq evil-emacs-state-cursor '("purple" box))
  (setq evil-normal-state-cursor '("red" box))
  (setq evil-visual-state-cursor '("yellow" box))
  (setq evil-insert-state-cursor '("orange" box))
  (setq evil-replace-state-cursor '("green" box))
  (setq evil-operator-state-cursor '("white" hollow))
  (setq evil-operator-state-cursor '("white" hollow)))

(defun my/theme-diff-colors ()
  ;; Diff
  (set-face-attribute 'diff-added nil  :background my/diff-added-color)
  (set-face-attribute 'diff-changed nil :background my/diff-changed-color)
  (set-face-attribute 'diff-removed nil :background my/diff-removed-color)

  (set-face-attribute 'diff-refine-added nil  :background my/diff-added-hl-color)
  (set-face-attribute 'diff-refine-changed nil :background my/diff-changed-hl-color)
  (set-face-attribute 'diff-refine-removed nil :background my/diff-removed-hl-color)

  ;; Ediff
  (set-face-attribute 'ediff-current-diff-A nil :background my/diff-removed-color)
  (set-face-attribute 'ediff-current-diff-Ancestor nil :background my/diff-ancestor-color)
  (set-face-attribute 'ediff-current-diff-B nil :background my/diff-added-color)
  (set-face-attribute 'ediff-current-diff-C nil :background my/diff-changed-color)
  (set-face-attribute 'ediff-even-diff-A nil :background (color-darken-name my/diff-removed-color 18))
  (set-face-attribute 'ediff-even-diff-Ancestor nil :background (color-darken-name my/diff-ancestor-color 30))
  (set-face-attribute 'ediff-even-diff-B nil :background (color-darken-name my/diff-added-color 18))
  (set-face-attribute 'ediff-even-diff-C nil :background (color-darken-name my/diff-changed-color 18))
  (set-face-attribute 'ediff-fine-diff-A nil :background my/diff-removed-hl-color)
  (set-face-attribute 'ediff-fine-diff-Ancestor nil :background my/diff-ancestor-hl-color)
  (set-face-attribute 'ediff-fine-diff-B nil :background my/diff-added-hl-color)
  (set-face-attribute 'ediff-fine-diff-C nil :background my/diff-changed-hl-color)
  (set-face-attribute 'ediff-odd-diff-A nil :background (color-darken-name my/diff-removed-color 20))
  (set-face-attribute 'ediff-odd-diff-Ancestor nil :background (color-darken-name my/diff-ancestor-color 50))
  (set-face-attribute 'ediff-odd-diff-B nil :background (color-darken-name my/diff-added-color 20))
  (set-face-attribute 'ediff-odd-diff-C nil :background (color-darken-name my/diff-changed-color 20)))

(defun my/theme-org-colors ()
  ;; =affects this text=
  (set-face-attribute 'org-verbatim nil :weight 'bold)
  (set-face-attribute 'org-quote nil :slant 'italic)
  (set-face-attribute 'org-mode-line-clock nil :foreground my/foreground-color :background my/foreground-color :height 'unspecified)
  (set-face-attribute 'org-mode-line-clock-overrun nil :foreground my/foreground-color :background "red" :height 'unspecified)
  (set-face-attribute 'org-agenda-filter-effort nil :foreground my/foreground-color :background my/background-color :height 'unspecified)
  (set-face-attribute 'org-agenda-filter-regexp nil :foreground my/foreground-color :background my/background-color :height 'unspecified)
  (set-face-attribute 'org-agenda-filter-tags nil :foreground my/foreground-color :background my/background-color :height 'unspecified) (set-face-attribute 'org-agenda-filter-category nil :foreground my/foreground-color :background my/background-color :height 'unspecified)

  (set-face-attribute 'org-code nil :background (color-darken-name my/background-color 5) :underline t)
  (set-face-attribute 'org-block nil :background my/background-color-1)

  ;; Disable right of header background coloring
  (set-face-attribute 'org-meta-line nil :background nil)

  ;; Used by org-src block borders, by default it uses the comment face
  ;;  (set-face-attribute 'org-block-begin-line nil :background my/background-color-3)
  ;;  (set-face-attribute 'org-block-end-line nil :background my/background-color-3)

  ;; Used by org src-blocks when in use, might also be used for other things
  (set-face-attribute 'secondary-selection nil :background (color-darken-name my/background-color 5)))
#+end_src

*** Package colors
#+begin_src emacs-lisp
(defun my/theme-package-colors ()
  (when (require 'hl-line nil 'noerror)
    (set-face-attribute 'hl-line nil :foreground my/foreground-color :background my/background-color-2 :underline nil))


  ;;  Show-paren
  (set-face-attribute 'show-paren-match nil :background my/background-color :foreground my/foreground-color)
  (set-face-attribute 'show-paren-match-expression nil :background my/foreground-color :foreground my/background-color)
  (set-face-attribute 'my/show-paren-offscreen-face nil :inherit 'highlight)

  ;; Wgrep
  (set-face-attribute 'wgrep-file-face nil :background my/foreground-color-6 :foreground my/background-color)

  ;; Ivy grep
  (set-face-attribute 'ivy-grep-info nil :background my/foreground-color-6 :foreground my/background-color)

  ;; Symbol overlay
  (if window-system
      (set-face-attribute 'symbol-overlay-default-face nil :foreground my/foreground-color :background my/mark-color-5))

  ;; Dired
  (set-face-attribute 'dired-directory nil :foreground my/background-color :background my/foreground-color)
  (my/set-face-to-default 'dired-perm-write 't)

  ;; Spray
  ;;  (set-face-attribute 'spray-accent-face nil :foreground "red" :background my/background-color)
  (set-face-attribute 'spray-accent-face nil :foreground my/foreground-color :background my/background-color :underline t)

  ;; Isearch
  (set-face-attribute 'isearch nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'lazy-highlight nil :foreground my/background-color :background my/foreground-color)
  ;; Haskell
  (set-face-attribute 'haskell-literate-comment-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)

  ;; Highlight thing
  ;;(set-face-attribute 'symbol-overlay nil :foreground my/foreground-color :background my/mark-color)

  ;; Company
  (set-face-attribute 'company-scrollbar-bg nil :background my/background-color)
  (set-face-attribute 'company-scrollbar-fg nil :background my/foreground-color)
  ;; Selected entry
  (set-face-attribute 'company-tooltip-selection nil :background my/foreground-color :foreground my/background-color)
  ;; All unmatching text
  (set-face-attribute 'company-tooltip nil :foreground my/foreground-color :background my/background-color-1)
  ;; All matching text
  (set-face-attribute 'company-tooltip-common nil :foreground my/background-color :background my/foreground-color)

  ;; Popup menu
  ;; Selected entry
  (when (require 'popup nil 'noerror)
    (set-face-attribute 'popup-menu-selection-face nil :foreground my/background-color :background my/foreground-color)
    ;; All unmatching text
    (set-face-attribute 'popup-menu-face nil :foreground my/foreground-color :background my/background-color-1))

  ;; Ivy
  ;; Ivy also uses "font-lock-doc-face" for the documentation
  (set-face-attribute 'ivy-current-match nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'ivy-cursor nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'ivy-minibuffer-match-highlight nil :foreground my/background-color :background my/foreground-color)
  ;;(set-face-attribute 'ivy-separator nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)

  (set-face-attribute 'ivy-minibuffer-match-face-1 nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'ivy-minibuffer-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
  (set-face-attribute 'ivy-minibuffer-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
  (set-face-attribute 'ivy-minibuffer-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

  ;; Ivy yasnippet
  (set-face-attribute 'ivy-yasnippet-key nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)

  ;; Ivy rich
  (set-face-attribute 'my/ivy-rich-doc-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-switch-buffer-indicator-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-switch-buffer-major-mode-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-switch-buffer-size-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-switch-buffer-path-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-switch-buffer-project-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)
  (set-face-attribute 'my/ivy-rich-find-file-symlink-face nil :foreground 'unspecified :background 'unspecified :inherit font-lock-comment-face)

  ;; Swiper
  (set-face-attribute 'swiper-match-face-1 nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'swiper-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
  (set-face-attribute 'swiper-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
  (set-face-attribute 'swiper-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

  ;; Avy
  (set-face-attribute 'avy-lead-face nil :foreground my/background-color :background my/foreground-color-6)
  (set-face-attribute 'avy-lead-face-0 nil :foreground my/background-color :background my/foreground-color-2)
  (set-face-attribute 'avy-lead-face-1 nil :foreground my/background-color :background my/foreground-color-4)
  (set-face-attribute 'avy-lead-face-2 nil :foreground my/background-color :background my/foreground-color-6)

  ;; Eshell
  (require 'em-prompt)
  (if window-system
      (set-face-attribute 'eshell-prompt nil :foreground "purple" :background my/background-color)
    (set-face-attribute 'eshell-prompt nil :foreground "magenta" :background my/background-color))

  ;; Yascroll
  (set-face-attribute 'yascroll:thumb-fringe nil :background "slateblue" :foreground "slateblue")
  (set-face-attribute 'yascroll:thumb-text-area nil :background "slateblue")

  ;; Term
  (set-face-attribute 'term-color-black nil :foreground "black" :background "black")
  (set-face-attribute 'term-color-blue nil :foreground "blue" :background "blue")
  (set-face-attribute 'term-color-cyan nil :foreground "cyan" :background "cyan")
  (set-face-attribute 'term-color-green nil :foreground "green" :background "green")
  (set-face-attribute 'term-color-magenta nil :foreground "magenta" :background "magenta")
  (set-face-attribute 'term-color-red nil :foreground "red" :background "red")
  (set-face-attribute 'term-color-white nil :foreground "white" :background "white")
  (set-face-attribute 'term-color-yellow nil :foreground "yellow" :background "yellow")

  ;; Flyspell
  (when window-system
    (set-face-attribute 'flyspell-incorrect nil :underline '(:style wave :color "Blue"))
    (set-face-attribute 'flyspell-duplicate nil :underline '(:style wave :color "LightBlue")))

  ;; Litable
  (when (require 'litable nil 'noerror)
    (set-face-attribute 'litable-result-face nil :foreground my/foreground-color :background my/background-color :weight 'bold)
    (set-face-attribute 'litable-substitution-face nil :foreground my/foreground-color :background my/background-color :weight 'bold))

  ;; Diff-hl
  (set-face-attribute 'diff-hl-change nil :background (face-attribute 'diff-changed :background))

  ;; Paren highlight
  ;;(set-face-attribute 'show-paren-match nil :foreground my/foreground-color :background my/mark-color-5)
  (set-face-attribute 'show-paren-match nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'show-paren-mismatch nil :background "red")

  ;; Flycheck-posframe
  (set-face-attribute 'flycheck-posframe-background-face nil :foreground my/foreground-color :background "#000000")

  ;; lsp
  (my/set-face-to-default 'lsp-ui-doc-background nil)
  ;;(set-face-attribute 'lsp-ui-doc-background nil :foreground my/foreground-color :background my/background-color)

  ;; lsp Doc
  (set-face-attribute 'lsp-ui-doc-header nil :foreground my/foreground-color :background my/background-color-4)
  (set-face-attribute 'lsp-ui-doc-url nil :foreground my/background-color :background my/foreground-color)

  ;; lsp Sideline
  (my/set-face-to-default 'lsp-ui-peek-filename nil)
  (my/set-face-to-default 'lsp-ui-peek-footer nil)
  (my/set-face-to-default 'lsp-ui-peek-header nil)
  (my/set-face-to-default 'lsp-ui-peek-highlight nil)
  (my/set-face-to-default 'lsp-ui-peek-line-number nil)
  (my/set-face-to-default 'lsp-ui-peek-list nil)
  (my/set-face-to-default 'lsp-ui-peek-peek nil)
  (my/set-face-to-default 'lsp-ui-peek-selection nil)
  (my/set-face-to-default 'lsp-ui-sideline-code-action nil)
  (my/set-face-to-default 'lsp-ui-sideline-current-symbol nil)

  ;;  (set-face-attribute 'lsp-ui-peek-filename nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-footer nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-header nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-highlight nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-line-number nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-list nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-peek nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-peek-selection nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-sideline-code-action nil :foreground my/foreground-color :background my/background-color)
  ;;  (set-face-attribute 'lsp-ui-sideline-current-symbol nil :foreground my/foreground-color :background my/background-color)

  (set-face-attribute 'lsp-ui-sideline-global nil :foreground nil :background nil)
  (set-face-attribute 'lsp-ui-sideline-symbol nil :foreground my/background-color :background my/foreground-color)
  (set-face-attribute 'lsp-ui-sideline-symbol-info nil :foreground my/mark-color :background my/background-color)

  ;; lsp lens
  ;; (set-face-attribute 'lsp-lens-face nil :foreground my/foreground-color :background my/mark-color-4 :height 0.8)
  (set-face-attribute 'lsp-lens-face nil :foreground 'unspecified :background my/background-color :inherit font-lock-comment-face)

  ;; Highlight faces
  (when (require 'highlight-indent-guides nil 'noerror)
    (highlight-indent-guides-auto-set-faces)))

(defun my/theme ()
  (interactive)
  (my/theme-remove-color)
  (my/theme-default-colors)
  (my/theme-outline-colors)
  (my/theme-header-line-color)
  (my/theme-evil-colors)
  (my/theme-diff-colors)
  (my/theme-org-colors)
  (my/theme-package-colors))

(if window-system
    (add-hook 'exwm-init-hook 'my/theme)
  (add-hook 'after-init-hook 'my/theme))

(define-key my/leader-map (kbd "M-c") 'my/theme)
#+end_src

* Backups
Stop emacs from creating backup files on every save
#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src
Max amount of characters, 200 000 ~200kb
#+begin_src emacs-lisp
(defvar my/per-session-backup-limit 200000)

(defvar my/backup-directory (concat (expand-file-name user-emacs-directory) "backups/"))
(defvar my/backup-per-session-directory (concat my/backup-directory "per-session/"))
(defvar my/auto-saves-directory (concat (expand-file-name user-emacs-directory) "auto-saves/"))

(my/create-dir-if-not-exist my/backup-directory)
(my/create-dir-if-not-exist my/backup-per-session-directory)
(my/create-dir-if-not-exist my/auto-saves-directory)
(defun my/backup-buffer-mode-ok ()
  (pcase (file-name-extension (buffer-name))
    ("gpg" nil)
    (_ (pcase major-mode
	 ('image-mode nil)
	 (_ t)))))

(defun my/should-backup-buffer ()
  (and (buffer-modified-p) buffer-file-name (my/backup-buffer-mode-ok) (< (point-max) my/per-session-backup-limit)))

(defun my/backup-format-file-path (path)
  (replace-regexp-in-string "/" "!" path))

(defun my/backup-buffer (backup-path)
  (interactive)
  (if (my/should-backup-buffer)
      (save-restriction (widen) (write-region (point-min) (point-max) (concat backup-path (number-to-string (floor (float-time))) (my/backup-format-file-path (buffer-file-name)))))))
#+end_src

** Make backup on first save
#+begin_src emacs-lisp
(defvar my/first-save t)

(defun my/backup-original-buffer ()
  (interactive)
  (if my/first-save
      (progn
	(my/backup-buffer my/backup-directory)
	(setq-local my/first-save nil))))
#+end_src

** Make backup on every save
#+begin_src emacs-lisp
(defun my/backup-buffer-per-session ()
  (interactive)
  (if (not my/first-save)
      (my/backup-buffer my/backup-per-session-directory)))
#+end_src

** Delete old backups
Automatically delete old backup files older than a week
#+begin_src emacs-lisp
(message "Deleting old backup files...")
(let ((week (* 60 60 24 7))
      (current (float-time (current-time))))
  (dolist (file (directory-files my/backup-directory t))
    (when (and (backup-file-name-p file)
	       (> (- current (float-time (nth 5 (file-attributes file))))
		  week))
      (message "%s" file)
      (delete-file file))))
#+end_src

** Delete per-session backups on startup
#+begin_src emacs-lisp
(ignore-errors
  (async-shell-command (concat "rm " my/backup-per-session-directory "*" )))
#+end_src

** Undo
*** Disable undo warning buffer
There is a warning window that pops up if you have made too many changes to a buffer, this might stop long macros, so stop that window from popping up
#+begin_src emacs-lisp
(require 'warnings)
(add-to-list 'warning-suppress-types '(undo discard-info))
#+end_src

** Undo tree
#+begin_src emacs-lisp
(straight-use-package 'undo-tree)

(setq global-undo-tree-mode t)
#+end_src

Fixes errors
#+begin_src emacs-lisp
(setq undo-tree-enable-undo-in-region nil)
(setq-default undo-tree-enable-undo-in-region nil)

(setq undo-tree-visualizer-lazy-drawing nil)
(setq-default undo-tree-visualizer-lazy-drawing nil)

(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
#+end_src

*** Keys
#+begin_src emacs-lisp
(add-hook 'undo-tree-visualizer-mode-hook '(lambda () (interactive) (run-with-timer 0.1 nil 'evil-force-normal-state)))

(setq undo-tree-visualizer-mode-map (make-sparse-keymap))

(evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "p") #'undo-tree-visualize-undo)
(evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "n") #'undo-tree-visualize-redo)
(evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "l") #'undo-tree-visualize-switch-branch-right)
(evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "h") #'undo-tree-visualize-switch-branch-left)
(evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "d") #'undo-tree-visualizer-toggle-diff)
#+end_src

* Run command on boot
#+begin_src emacs-lisp
(if my/run-command-on-boot
    (async-shell-command my/run-command-on-boot))
#+end_src

* Restore gc mem
#+begin_src emacs-lisp
(setq gc-cons-threshold my/after-gc-mem)
#+end_src

* Report start time
#+begin_src emacs-lisp
(run-with-timer 4 nil (lambda () (interactive) (message (concat "Booted in " (emacs-init-time)))))
#+end_src

* Byte-compile the config
Byte compilation doesn't work before loading everything because of some reason, so do it now
#+begin_src emacs-lisp
(unless (and (file-exists-p my/config-compiled-location) (my/is-file-more-up-to-date my/config-compiled-location my/config-location))
  (byte-compile-file "~/.emacs.d/config.el")
  (message "Config is now byte compiled, restart to run it"))
#+end_src
