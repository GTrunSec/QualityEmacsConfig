* Docs
** Requirements
*** Volume control
=amixer=

*** Music
=mpd= =mpc= 
=pulse audio= if alsa, etc, edit "MPD/Create config".

*** Search
=the silver searcher/ ag=
=grep=

*** Code
**** Documentation
=zeal=

**** C#
=mono= 
=M-x omnisharp-install-server=

**** F#
=mono= (3.10.X or higher) =F#= (3.0 or higher) 
To create solution file, check github
On windows, you may need to manually point to server path, see github

**** Clojure
=leiningen= =clojure=

*** Screenshots
=imagemagick=

*** Dired
**** Sorting
=ls=

*** Overtone
=jack2= =leiningen= =cider=

To start =leiningen= in emacs do =cider-jack-in=

Input =(use 'overtone.live)= into leiningen to install

**** To use with pulse audio
=cadence= and =pulseaudio-jack=

*** password-store.el
=bash=
=GnuPG2=
=git=
=xclip=
=greencode=

*** Spelling
=aspell-en= etc

*** Gnus
Set adress in gnus.el

*** Laptop
=xorg-xbacklight=
=wpa_supplicant=

*** Switch Ctrl and Caps
=xmodmap= =xsession=

*** PDF tools
=poppler= =poppler-glib=
M-x =pdf-tools-install=

*** Misc
=redshift= 

** FSharp
*** File is not part of the loaded projects
Try having the =fsproj= file open in a buffer or try moving the project folder directly to the home folder

** Overtone
*** How to configure jack2 to work with pulse
https://wiki.archlinux.org/index.php/PulseAudio/Examples#PulseAudio_through_JACK
(The KXStudio method)

1. get =cadence= and =pulseaudio-jack=
   
2. Bridge alsa -> pulse -> jack

3. Autostart maybe???

4. Configure -> Alsa -> Good settings

*** Sounds only play in one ear??
https://github.com/overtone/overtone/wiki/Multi-channel-expansion,-stereo-and-panning
You have to specify sound channel in the code when using certain sounds

*** Pauvcontrol measures sound but can't hear anything
Unmute the sound device in pauvcontrol

*** Overtone errors out all the time
Execute script up to down, put =(use 'overtone.live)= on top of file, and in leiningen

*** How should jack be started???
Let overtone (actually it's supercollider, since overtone is just a wrapper for using supercollider in clojure) do it (it does it automatically when inputting =(use 'overtone.live)= in leiningen)

*** Shit doesn't work
just fiddle around with cadence (check if bridge type is correct, then force restart until it works)

** Dired
*** Archives in dired
Press c to compress, Z to extract
To stop dired from creating new folder when unpacking, change in section "Dired atool"

** Can't find package error
run
=package-refresh-contents=
or restart emacs
** Gnus 
*** How to setup name and password
Create authinfo.pgp file. It is auto encrypted/decrypted

Format for gmail is currently
#+BEGIN_SRC
machine imap.gmail.com login <USER> password <APP-PASSWORD> port imaps
machine smtp.gmail.com login <USER> password <APP-PASSWORD> port 587
machine imap-mail.outlook.com login my-username@hotmail.com password my-secret-password port 993
#+END_SRC

*** gnus mails are not updating
Try doing C-u M-g twice inside that inbox

*** Where are my servers/passwords stored?
=~/.authinfo.gpg=

*** How to download articles using gnus?
use =M-x gnus-agent-add-server=

*** Mail server mails aren't marked as read when marking as read in gnus, and gnus isn't marking them as read either after exit
You have to press =q= in order to save changes

** wpa supplicant
https://wiki.archlinux.org/index.php/WPA_supplicant#Connecting_with_wpa_cli

** MPD
*** "no mpd daemon running" 
Disable daemon if using systemctl with =systemctl disable mpd.service mpd.socket=

** Eww
*** Opening local file results in raw page
This is because the file isn't named =FILE.html=, when eww saves pages, it doesn't add =.html= at the end

** Keyboard setup
*** Change keyboard layout
To list keymaps, do =localectl list-keymaps=

=carpalx= is example layout
To load keymaps, in terminal do: =loadkeys carpalx=

To make permanent:
in =/etc/vconsole.conf=
#+BEGIN_SRC
KEYMAP=carpalx
FONT=lat9w-16
#+END_SRC

*** Swap Ctrl and Caps_Lock
Load correct keymap
1. Do =sudo dumpkeys | head -1 > ~/Keys.map=
2. Add this under the one line long Keys.map
#+BEGIN_SRC maps
keycode 58 = Control # Makes Caps Lock act as ctrl
keycode 29 = Caps_Lock # Makes ctrl act as caps
# alt_is_meta # Fix the alt key?
#+END_SRC
3. Do =sudo loadkeys ~/Keys.map=

** Interesting stuff
highlight-changes-mode (built in)
goto-chg (goto last change)

** Color picking
Get =gpick=

* Package management

** Local packages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name (concat user-emacs-directory "local-packages")))
#+END_SRC

* Security
#+BEGIN_SRC emacs-lisp
  (setq network-security-level 'paranoid)
#+END_SRC

** Make authinfo gpg file
#+BEGIN_SRC emacs-lisp
  (setq netrc-file "~/.authinfo.gpg")
#+END_SRC

* Persistent keys
#+BEGIN_SRC emacs-lisp
  (defvar my/keys-mode-map (make-sparse-keymap))

  ;; Emacs 27 doesn't support :init-value, :keymap, etc
  (if (string< emacs-version "27")
      (define-minor-mode my/keys-mode
        ;; init value t to enable it in fundamental mode
        ;; More info: http://emacs.stackexchange.com/q/16693/115
        :init-value t
        :keymap my/keys-mode-map)
    (define-minor-mode my/keys-mode nil t nil my/keys-mode-map))

  (add-to-list 'emulation-mode-map-alists `((my/keys-mode . ,my/keys-mode-map)))

  ;; Turn off the minor mode in the minibuffer
  (defun my/keys-mode-turn-off ()
    (my/keys-mode -1))

  (defun my/keys-mode-turn-on ()
    (my/keys-mode 1))
#+END_SRC

** Mode specific settings
#+BEGIN_SRC emacs-lisp
  ;; Disable keys in minibuffers such as ivy, etc
  (add-hook 'minibuffer-setup-hook 'my/keys-mode-turn-off)
  ;;(add-hook 'messages-buffer-mode-hook 'my/keys-mode-turn-on)
#+END_SRC

* Generic functions and variables
** File management
*** Create directory if directory doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-dir-if-not-exist (dir)
    (if (not (file-directory-p dir))
        (progn
          (make-directory dir)
          (message (concat "dir: " dir " created!")))))
#+END_SRC

*** Create file if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-if-not-exist (file)
    (if (not (file-exists-p file))
        (progn
          (write-region "" nil file)
          (message (concat "file: " file " created!")))))
#+END_SRC

*** Create file with content if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-with-content-if-not-exist (file content)
    (if (not (file-exists-p file))
        (progn
          (write-region content nil file)
          (message (concat "file: " file " with contents")))))
;;" created with content: " content)))))
#+END_SRC

** Is external package installed
#+BEGIN_SRC emacs-lisp
  (defun my/run-and-is-external-package-installed (package)
    (not (string-match-p "not found"
                       (shell-command-to-string package))))
#+END_SRC

** Give buffer unique name
#+BEGIN_SRC emacs-lisp
  (defun my/give-buffer-unique-name(base-name)
    (rename-buffer base-name t))
#+END_SRC

** Is font installed
#+BEGIN_SRC emacs-lisp
  (defvar my/font-family-list (font-family-list))
  (defun my/font-installed (font)
    (if (member font my/font-family-list)
      t
      nil))
#+END_SRC

** Fold ellipsis 
#+BEGIN_SRC emacs-lisp
  (defvar my/fold-ellipsis)

  (when window-system
    (setq my/fold-ellipsis "↴"))

  ;; The terminal probably doesn't support unicode
  (when (not window-system)
    (setq my/fold-ellipsis "↓"))
#+END_SRC

** File size human readable
Default file-size-human-readable returns decimal values
#+BEGIN_SRC emacs-lisp
  (require 'files)

  (defun my/file-size-human-readable (file-size &optional flavor decimal)
    "Produce a string showing FILE-SIZE in human-readable form.

  Optional second argument FLAVOR controls the units and the display format:

   If FLAVOR is nil or omitted, each kilobyte is 1024 bytes and the produced
      suffixes are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `si', each kilobyte is 1000 bytes and the produced suffixes
      are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `iec', each kilobyte is 1024 bytes and the produced suffixes
      are \"KiB\", \"MiB\", \"GiB\", \"TiB\", etc.
   If DECIMAL is true, a decimal number is returned"
    (setq 1024Decimal (if decimal 1024.0 1024))
    (setq 1000Decimal (if decimal 1000.0 1000))

    (let ((power (if (or (null flavor) (eq flavor 'iec))
                     1024Decimal
                   1000Decimal))
          (post-fixes
           ;; none, kilo, mega, giga, tera, peta, exa, zetta, yotta
           (list "" "k" "M" "G" "T" "P" "E" "Z" "Y")))
      (while (and (>= file-size power) (cdr post-fixes))
        (setq file-size (/ file-size power)
              post-fixes (cdr post-fixes)))
      (format (if (> (mod file-size 1.0) 0.05)
                  "%.1f%s%s"
                "%.0f%s%s")
              file-size
              (if (and (eq flavor 'iec) (string= (car post-fixes) "k"))
                  "K"
                (car post-fixes))
              (if (eq flavor 'iec) "iB" ""))))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package twilight-anti-bright-theme)
    (load-theme 'twilight-anti-bright t))

  (when (not window-system)
    (load-theme 'wheatgrass t))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
  (defvar my/is-font-mono nil)
  (defvar my/font nil)

  (if (my/font-installed "Open Sans")
      (setq my/font "opensans")
    (if (my/font-installed "dejavu sans")
        (setq my/font "DejaVuSans")))

  (if my/font
      (set-face-attribute 'default nil
                          :family my/font
                          :height 120))
#+END_SRC

** Mono font
#+BEGIN_SRC emacs-lisp
  (defun my/get-best-mono-font ()
    (if my/is-font-mono
        my/font
      (if (my/font-installed "Inconsolata")
          "Inconsolata"
        (if (my/font-installed "dejavu sans mono")
            "DejaVuSansMono"
          (if (my/font-installed "Noto Sans Mono")
              "NotoSansMono"
            (if (my/font-installed "Perfect DOS VGA 437")
                "Perfect DOS VGA 437"))))))

  (defvar my/mono-font (my/get-best-mono-font))
#+END_SRC

** Make sure mode line is disabled before any windows are created
#+BEGIN_SRC emacs-lisp
 (setq mode-line-format nil)
 (setq-default mode-line-format nil)
#+END_SRC

* Startup processes
** Prevent async command from opening new window
#+BEGIN_SRC emacs-lisp
  ;; Buffers that I don't want popping up by default
  (add-to-list 'display-buffer-alist
               '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+END_SRC

** Check if OS is fully compatible
#+BEGIN_SRC emacs-lisp
  (defvar fully-compatible-system (or (eq system-type 'gnu/linux)(eq system-type 'gnu)(eq system-type 'gnu/kfreebsd)))
#+END_SRC

** Redshift 
#+BEGIN_SRC emacs-lisp
  (if(my/run-and-is-external-package-installed "redshift -h")
      (start-process "redshift" nil "redshift"))
#+END_SRC

** Garbage collection
#+BEGIN_SRC emacs-lisp
  (setq garbage-collection-messages t)

  ;; Get 80% of memory
  (defvar my/emacs-max-ram-usage (floor (* (* (car (memory-info)) 0.8) 1024))
    "Max ram emacs can use before having to jump ship
  Is in bytes")

    (if my/emacs-max-ram-usage
        (setq gc-cons-threshold my/emacs-max-ram-usage))

  (defun garbage-collect (&rest args) 
    (message "Emacs is trying to garbage collect, it's time to jump ship"))
#+END_SRC

** Disable custom
Stop custom from editing init.el
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory ".emacs-custom.el"))
#+END_SRC

* Backups
Stop emacs from creating backup files on every save
#+BEGIN_SRC emacs-lisp
  ;;(setq make-backup-files nil)
  ;;(setq auto-save-default nil)
  ;; Make multiple backups
  (setq version-control t)

  ;; Backup even if file is under version control
  (setq vc-make-backup-files t)

  (setq backup-by-copying t)      ; don't clobber symlinks
  (setq delete-old-versions t)
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)

  (defvar my/backup-directory (concat user-emacs-directory "backups/"))
  (defvar my/auto-saves-directory (concat user-emacs-directory "auto-saves/"))

  (my/create-dir-if-not-exist my/backup-directory)

  (my/create-dir-if-not-exist my/auto-saves-directory)

  (setq backup-directory-alist `(("." . ,my/backup-directory)))
  (setq auto-save-file-name-transforms `((".*" ,my/auto-saves-directory t)))
#+END_SRC

** Make backup on every save
https://www.emacswiki.org/emacs/ForceBackups
#+BEGIN_SRC emacs-lisp
  (defvar my/create-per-session-backups t)
  ;; Max amount of characters, 200 000 ~200kb
  (defvar my/per-session-backup-limit 200000)

  (defvar my/backup-per-session-directory (concat my/backup-directory "per-session/"))

  (my/create-dir-if-not-exist my/backup-per-session-directory)

  (defun my/force-backup-of-buffer ()
    (interactive)
    (if (and my/create-per-session-backups (< (point-max) my/per-session-backup-limit) (buffer-modified-p))
        (save-restriction (widen) (write-region (point-min) (point-max) (concat my/backup-per-session-directory (number-to-string (time-to-seconds)) (buffer-name)) nil nil nil))))
#+END_SRC

** Delete old backups
#+BEGIN_SRC emacs-lisp
  ;; Automatically delete old backup files older than a week
  (message "Deleting old backup files...")
  (let ((week (* 60 60 24 7))
        (current (float-time (current-time))))
    (dolist (file (directory-files my/backup-directory t))
      (when (and (backup-file-name-p file)
               (> (- current (float-time (nth 5 (file-attributes file))))
                  week))
        (message "%s" file)
        (delete-file file))))
#+END_SRC

*** Delete per-session backups on startup
#+BEGIN_SRC emacs-lisp
  (shell-command (concat "rm " my/backup-per-session-directory "*" ))
#+END_SRC

** Disble backups for certain files
#+BEGIN_SRC emacs-lisp
  (define-minor-mode my/no-backups-mode
    "http://anirudhsasikumar.net/blog/2005.01.21.html
  For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    "no-backups"
    ;; The minor mode bindings.
    nil
    (if (symbol-value my/no-backups-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t) 
          ;; disable auto-save
          (if auto-save-default
              (progn
                (setq my/create-per-session-backups nil)
                (auto-save-mode -1))))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (progn
            (setq my/create-per-session-backups t)
            (auto-save-mode 1)))))
#+END_SRC

*** File types to not backup
#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist
        (append '(("\\.gpg$" . my/no-backups-mode))
                auto-mode-alist))
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)

  (setq global-undo-tree-mode t)

  ;; Might fix undo tree
  (setq undo-tree-enable-undo-in-region nil)


  ;;(setq undo-tree-auto-save-history t)

  ;;(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/saves")))
  ;;(make-directory (concat spacemacs-cache-directory "undo")))
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil)

  ;;(fset 'evil-visual-update-x-selection 'ignore)
  (evil-mode)

  (setq evil-search-module 'evil-search)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)

  ;; Makes swiper A LOT faster
  (setq evil-ex-interactive-search-highlight t)
  (setq evil-ex-search-persistent-highlight nil)
#+END_SRC

** Settings
*** Disable messages in echo area
Evil spams message area
#+BEGIN_SRC emacs-lisp
(setq
    evil-emacs-state-message nil
    evil-operator-state-message nil
    evil-insert-state-message nil
    evil-replace-state-message nil
    evil-motion-state-message nil
    evil-normal-state-message nil
    evil-visual-state-message nil)
#+END_SRC

*** Cursor states
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-cursor '("purple" box))
  (setq evil-normal-state-cursor '("white" box))
  (setq evil-visual-state-cursor '("yellow" box))
  (setq evil-insert-state-cursor '("orange" box))
  (setq evil-replace-state-cursor '("green" box))
  (setq evil-operator-state-cursor '("white" hollow))
#+END_SRC

*** Exit emacs state with esc
#+BEGIN_SRC emacs-lisp
  (define-key evil-emacs-state-map [escape] 'evil-normal-state)
#+END_SRC

*** Disable emacs mode 
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-modes nil)
#+END_SRC

*** Set which modes use which evil state by default
Example
#+BEGIN_SRC emacs-lisp
  (setq evil-insert-state-modes nil)

  (if (string< emacs-version "24.3")
      (error "Since emacs version is under 24.3, you need to remove cl-... in this section, and add (require 'cl) (not recommended to do in later versions)"))

  (cl-loop for (mode . state) in '(
                                   ;; So i C-leader works for exwm windows
                                   (exwm-mode . emacs)
                                   (eshell-mode . insert)
                                   (term-mode . insert)
                                   ;;(org-agenda-mode . insert)
                                   (magit-popup-mode . insert)
                                   (proced-mode . insert)
                                   (emms-playlist-mode . insert))
           do (evil-set-initial-state mode state))
#+END_SRC

*** Switching to normal state without moving cursor
#+BEGIN_SRC emacs-lisp
  (defun my/evil-normal-state (&optional arg)
    (if (not(eq evil-state 'normal))
        (progn
          (evil-normal-state arg)
          (move-to-column (+ 1 (current-column))))))
#+END_SRC

*** Make one space enough to end work for use with evil sentence motion
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Evil-lion
#+BEGIN_SRC emacs-lisp
  ;;(use-package evil-lion)

  ;;(evil-lion-mode)
#+END_SRC

** Evil-indent-plus
Allows for using indention as text objects
#+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus)

  (evil-indent-plus-default-bindings)
#+END_SRC

** Evil-goggles
#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles)
  (evil-goggles-mode)
  ;; Disable pulse which both fixes so that you can set foreground color on the pulse font and saves on performance
  (setq evil-goggles-pulse nil)
  (setq evil-goggles-duration 60)

  (evil-goggles-use-diff-faces)
#+END_SRC

** Evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit)
  (global-evil-matchit-mode 1)
#+END_SRC

** Evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

** Evil-args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args)

  ;; bind evil-args text objects
  (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
  (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
#+END_SRC

** Evil-visual-mark-mode
Replaced by bookmarks??
#+BEGIN_SRC emacs-lisp
  ;; (use-package evil-visual-mark-mode)
  ;; (evil-visual-mark-mode)
#+END_SRC

* Leader
When changing leader, change =my/leader-map-key= and manually change all general simulate key rebinds
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/leader-map)

  (defvar my/leader-map-key "SPC")
  (defvar my/mod-leader-map-key "C-SPC")

  (defvar my/window-leader-key "C-=")
  (defvar my/mod-window-leader-key "M-C-=")

  (define-prefix-command 'my/help-map)
  (define-key my/leader-map (kbd "h") 'my/help-map)

  (define-key my/leader-map (kbd "u") 'undo-tree-visualize)

  (evil-define-key 'normal my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)
  (evil-define-key 'motion my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)
  (evil-define-key 'visual my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)

  ;; Enable leader even if my/keys-mode isn't active
  (define-key evil-motion-state-map (kbd my/leader-map-key) 'my/leader-map)
  (define-key evil-normal-state-map (kbd my/leader-map-key) 'my/leader-map)
#+END_SRC

* Write config map
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/write-config-map)
  (define-key my/leader-map (kbd "C-c") 'my/write-config-map)
#+END_SRC

** Write .gnus.el
Create =.gnus.el=, which gnus reads from 
#+BEGIN_SRC emacs-lisp
  (defun my/write-gnus ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.gnus.el" "
  AddYourEmailHereThenDeleteThis
  (setq mail-host-address \"MyAdress\")
  ")))

  (define-key my/write-config-map (kbd "g") 'my/write-gnus)
#+END_SRC

** Write .Xdefaults
emacs. commands to disable scrollbar, etc before launching emacs, improving startup time
#+BEGIN_SRC emacs-lisp
  (defun my/write-xdefaults ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.Xdefaults" " 
  emacs.toolBar: 0
  emacs.menuBar: 0
  emacs.verticalScrollBars: off" )))

  (define-key my/write-config-map (kbd "d") 'my/write-xdefaults)
#+END_SRC

** Write .xinitrc
=xset s= disables screen saver
setxkbmap to select keyboard layout

#+BEGIN_SRC emacs-lisp
  (defun my/write-xinitrc ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xinitrc" "
  xset s off
  xset s noblank
  xset s off
  xset s off -dpms

  setxkbmap -layout us -variant altgr-intl
  # setxkbmap -layout carpalx -variant qgmlwy

  xmodmap ~./xmodmap

  # Fix java windows in exwm
  export _JAVA_AWT_WM_NONREPARENTING=1

  exec emacs")))

  (define-key my/write-config-map (kbd "i") 'my/write-xinitrc)
#+END_SRC

** Write .xmodmap
This swaps capslock and ctrl
#+BEGIN_SRC emacs-lisp
  (defun my/write-xmodmap ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xmodmap" " 
  ! Swap Caps_Lock and Control_L
  remove Lock = Caps_Lock
  remove Control = Control_L
  keysym Control_L = Caps_Lock
  keysym Caps_Lock = Control_L
  add Lock = Caps_Lock
  add Control = Control_L
  ")))

  (define-key my/write-config-map (kbd "m") 'my/write-xmodmap)
#+END_SRC

** Write mpd
#+BEGIN_SRC emacs-lisp
  (defun my/setup-mpd ()
    (interactive)
    (setq my/config-directory "~/.config/")
    (my/create-dir-if-not-exist my/config-directory)

    (setq my/mpd-directory (concat my/config-directory "mpd/"))
    (my/create-dir-if-not-exist my/mpd-directory)

    (setq my/mpd-conf-file (concat my/mpd-directory "mpd.conf"))
    (my/create-file-with-content-if-not-exist my/mpd-conf-file "
  music_directory \"~/Music\"
  playlist_directory  \"~/.config/mpd/playlists\"
  db_file \"~/.config/mpd/mpd.db\"
  log_file \"~/.config/mpd/mpd.log\"
  bind_to_address \"127.0.0.1\"
  port \"6600\"

  # For pulse audio
  audio_output {
  type \"pulse\"
  name \"pulse audio\"
  }
                   ")

    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.log"))
    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.db"))
    (my/create-dir-if-not-exist (concat my/mpd-directory "playlists/")))

  (define-key my/write-config-map (kbd "m") 'my/setup-mpd)
#+END_SRC

** Write all configs
#+BEGIN_SRC emacs-lisp
  (defun my/write-all-config ()
    (interactive)
    (my/write-xdefaults)
    (my/write-xinitrc)
    (my/write-gnus)
    (my/setup-mpd))

  (define-key my/write-config-map (kbd "a") 'my/write-all-config)
#+END_SRC

* Install software
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/software-install-map)
  (define-key my/leader-map (kbd "I") 'my/software-install-map)
#+END_SRC

** Install eclipse java language server
For use with lsp-java
#+BEGIN_SRC emacs-lisp
  (defun my/install-eclipse-java-language-server()
    (interactive)
    (shell-command "
  rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
  mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
  wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
  tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
  "))

  (define-key my/software-install-map (kbd "j") 'my/install-eclipse-java-language-server)
#+END_SRC

** Install pdf tools
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "p") 'pdf-tools-install)
#+END_SRC

** Install omnisharp
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "o") 'omnisharp-install-server)
#+END_SRC

** Compile config
#+BEGIN_SRC emacs-lisp
  (defun my/compile-config ()
    (interactive)
    (byte-compile-file my/config-exported-location nil))

  (define-key my/software-install-map (kbd "C-c") 'my/compile-config)
#+END_SRC

* Minor
** Startup
Disable startup message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

** Scratch buffer
*** Disable initial scratch buffer message
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

** Encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** Line wrapping
*** Enable truncate lines mode
#+BEGIN_SRC emacs-lisp
  (set-default 'truncate-lines t)
#+END_SRC

*** Visual-line mode
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode t)

  (define-key my/leader-map (kbd "C-v") 'visual-line-mode)
#+END_SRC

** Disable useless functionallity
#+BEGIN_SRC emacs-lisp
  (mouse-wheel-mode -1)
  (tooltip-mode -1)
#+END_SRC

** 1 letter prompts
Convert yes or no prompt to y or n prompt
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
  
** Smooth scroll
Scroll 1 line at a time when cursor goes outside screen
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Bell
Disable bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Subword (camel case movement)
 #+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
 #+END_SRC

** Change max killring size
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** Pixel scroll mode
In org mode when displaying images pixel scroll mode can be useful maybe
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'org-mode-hook 'pixel-scroll-mode)
#+END_SRC

** Increase and decrease brightness
#+BEGIN_SRC emacs-lisp
  (defun my/increase-brightness ()
    (interactive)
    (shell-command "xbacklight +5"))

  (defun my/decrease-brightness ()
    (interactive)
    (shell-command "xbacklight -5"))

  (global-set-key (kbd "<XF86MonBrightnessUp>") 'my/increase-brightness)
  (global-set-key (kbd "<XF86MonBrightnessDown>") 'my/decrease-brightness)
#+END_SRC

** Statistics
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/statistics-map)
  (define-key my/leader-map (kbd "C") 'my/statistics-map)

  (define-key my/statistics-map (kbd "w") 'count-words)
  (define-key my/statistics-map (kbd "r") 'count-words-region)
#+END_SRC

** Update packages
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-u") 'list-packages)
#+END_SRC

** Sudo edit
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :defer t)

  (define-key my/leader-map (kbd "'") 'sudo-edit)
#+END_SRC

** With-editor
#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :defer t)
#+END_SRC

** Disable all colors
#+BEGIN_SRC emacs-lisp
  (defun my/paper-mode()
    (interactive)
    (cl-loop for face in (face-list) do
             (set-face-attribute face nil :foreground nil :background nil))

    (setq my/foreground-color "orange")
    (setq my/background-color "black")

    ;; (setq  my/background-color "#2a1f1f")
    ;; (setq my/foreground-color "#d15120")

    ;; (setq my/foreground-color "black")
    ;; (setq my/background-color "white") 

    ;;; Emacs
    (set-face-attribute 'default nil :foreground my/foreground-color :background my/background-color)
    (set-face-attribute 'cursor nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'link nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'highlight nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'region nil :foreground my/background-color :background my/foreground-color)


    ;;; Isearch
    (set-face-attribute 'isearch nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'lazy-highlight nil :foreground my/background-color :background my/foreground-color)

    ;;; Highlight thing
    (set-face-attribute 'highlight-thing nil :foreground my/background-color :background my/foreground-color)

    ;;; Company
    (set-face-attribute 'company-scrollbar-bg nil :background my/background-color)
    (set-face-attribute 'company-scrollbar-fg nil :background my/foreground-color)

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background my/foreground-color :foreground my/background-color)
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground my/foreground-color :background my/background-color)
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground my/background-color :background my/foreground-color)


    ;;; Ivy
    (set-face-attribute 'ivy-current-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-cursor nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-highlight nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-face-2 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-face-3 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-face-4 nil :foreground my/background-color :background my/foreground-color)

    ;;; Avy
    (set-face-attribute 'avy-lead-face nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'avy-lead-face-0 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'avy-lead-face-1 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'avy-lead-face-2 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'avy-lead-face-2 nil :foreground my/background-color :background my/foreground-color)

    ;;(defvar my/evil-goggles-highlight-color)
    ;;; Evil-goggles
    ;;; 2 color approach
    ;; (set-face-attribute 'evil-goggles-change-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-commentary-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-delete-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-fill-and-move-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-indent-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-join-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-paste-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-record-macro-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-replace-with-register-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-set-marker-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-shift-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-surround-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-yank-face nil :foreground my/background-color :background my/foreground-color)


    (set-face-attribute 'diff-added nil  :background "#335533")
    (set-face-attribute 'diff-changed nil :background "#aaaa22")
    (set-face-attribute 'diff-removed nil :background "#553333")

    ;; (set-face-attribute 'diff-added nil  :background "green")
    ;; (set-face-attribute 'diff-changed nil :background "yellow")
    ;; (set-face-attribute 'diff-removed nil :background "red")

    ;; Diff-hl 
    (set-face-attribute 'diff-hl-change nil :background (face-attribute 'diff-changed :background))

    ;; Paren highlight
    (set-face-attribute 'show-paren-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'show-paren-mismatch nil :background "red"))

  ;; (counsel-faces)

  (define-key my/leader-map (kbd "M-c") 'my/paper-mode)
#+END_SRC

** Enable disabled commands
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
#+END_SRC

** Async
#+BEGIN_SRC emacs-lisp
  (use-package async)

  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1)
#+END_SRC

** Zoom
#+BEGIN_SRC emacs-lisp
  ;; (defun my/increase-volume ()
    ;; (interactive)
    ;; (text-scale-set 0))
  ;; (define-key my/leader-map (kbd "+") ')
  ;; (define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-set 0)))
;; 
  (define-key my/leader-map (kbd "-") '(lambda () (interactive) (text-scale-decrease 1)))
  (define-key my/leader-map (kbd "=") '(lambda () (interactive) (text-scale-increase 1)))
#+END_SRC

* Visit file hotkeys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/open-map)
  (define-key my/leader-map (kbd "o") 'my/open-map)

  (defvar my/open-map-hook nil
    "Hook called after a buffer is visited through my/open-map")
#+END_SRC

** Scratch
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-scratch()
    (interactive)
    (switch-to-buffer "*scratch*")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "s") 'my/switch-to-scratch)
#+END_SRC

** Visit config
#+BEGIN_SRC emacs-lisp
  (defun my/config-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
    (define-key my/open-map (kbd "c") 'my/config-visit)
#+END_SRC
  
** Reload config
#+BEGIN_SRC emacs-lisp
  (defun my/config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "r c") 'my/config-reload)

#+END_SRC

** Open trash
#+BEGIN_SRC emacs-lisp
  (defun my/trash-visit ()
    (interactive)
    (find-file "~/.local/share/Trash/files/")
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "t") 'my/trash-visit)

#+END_SRC

** Open agenda
#+BEGIN_SRC emacs-lisp
  (defun org/org-agenda-show-agenda-and-todo (&optional arg)
    (interactive "P")
    (org-agenda arg "a")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "a") 'org/org-agenda-show-agenda-and-todo)
#+END_SRC

** Visit agenda file
#+BEGIN_SRC emacs-lisp
  (defun my/agenda-file-visit ()
    (interactive)
    (find-file "~/Notes/Agenda.org")
    (run-hooks 'my/open-map-hook))
    (define-key my/open-map (kbd "A") 'my/agenda-file-visit)

#+END_SRC

* Folding
** Narrowing
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/narrow-map)
  (define-key my/leader-map (kbd "t") 'my/narrow-map)

  (define-key my/narrow-map (kbd "w") 'widen)
  (define-key my/narrow-map (kbd "r") 'narrow-to-region)

  (define-key my/narrow-map (kbd "p") 'narrow-to-page)
  (define-key my/narrow-map (kbd "d") 'narrow-to-defun)
#+END_SRC

** Origami
#+BEGIN_SRC emacs-lisp
   (use-package origami)
 
   (global-origami-mode)
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
  (setq origami-fold-replacement my/fold-ellipsis)
#+END_SRC

*** Keys
Vim bindings to change fold
#+BEGIN_SRC emacs-lisp
  (define-key evil-motion-state-map (kbd "z n") 'origami-forward-fold)
  (define-key evil-motion-state-map (kbd "z p") 'origami-previous-fold)

  (define-key evil-motion-state-map (kbd "z C-o") 'origami-open-all-nodes)
  (define-key evil-motion-state-map (kbd "z C-c") 'origami-close-all-nodes)
#+END_SRC

* Completion
** Ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy)

  (ivy-mode 1)

  ;; Buffer history
;;  (setq ivy-use-virtual-buffers t)
  (setq ivy-use-virtual-buffers nil)

  ;; Allows calling new minibuffer commands while in the minibuffer. So for example C-s M-x works
  (setq enable-recursive-minibuffers t)

  ;; Make user intput selectable
  (setq ivy-use-selectable-prompt t)

  ;;Disable fuzzy search for swiper
  ;;(setq ivy-re-builders-alist
  ;;      '((swiper . ivy--regex-plus)
  ;;       (t      . ivy--regex-fuzzy)))
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
  ;; Height of minibuffer
  ;; (setq ivy-height 10)

  ;; Highlight whole row in minibuffer
  (setq ivy-format-function 'ivy-format-function-line)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-/") 'ivy-resume)

  ;; Enable avy movements in ivy buffer
  (define-key ivy-minibuffer-map (kbd "M-p") 'ivy-avy)
  (define-key ivy-minibuffer-map (kbd "M-n") 'ivy-avy)

  (define-key ivy-minibuffer-map (kbd "<escape>") 'minibuffer-keyboard-quit)

  (define-key ivy-minibuffer-map (kbd "C-u") 'ivy-scroll-down-command)
  (define-key ivy-minibuffer-map (kbd "C-w") 'ivy-scroll-up-command)
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel)

  (counsel-mode 1)

  (setq counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-find-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)

  (global-set-key (kbd "M-k") 'counsel-yank-pop)

  (define-key my/leader-map (kbd "m") 'counsel-mark-ring)

  (define-key my/help-map (kbd "C-c") 'counsel-colors-emacs)
  (define-key my/help-map (kbd "C") 'counsel-colors-web)

  (define-key my/leader-map (kbd "i") 'counsel-imenu)
#+END_SRC

** Counsel flycheck
  https://github.com/nathankot/dotemacs/blob/master/init.el
#+BEGIN_SRC emacs-lisp

  (defvar counsel-flycheck-history nil
    "History for `counsel-flycheck'")

  (defun counsel-flycheck ()
    (interactive)
    (if (not (bound-and-true-p flycheck-mode))
        (message "Flycheck mode is not available or enabled")
      (ivy-read "Error: "
                (let ((source-buffer (current-buffer)))
                  (with-current-buffer (or (get-buffer flycheck-error-list-buffer)
                                          (progn
                                            (with-current-buffer
                                                (get-buffer-create flycheck-error-list-buffer)
                                              (flycheck-error-list-mode)
                                              (current-buffer))))
                    (flycheck-error-list-set-source source-buffer)
                    (flycheck-error-list-reset-filter)
                    (revert-buffer t t t)
                    (split-string (buffer-string) "\n" t " *")))
                :action (lambda (s &rest _)
                          (-when-let* ( (error (get-text-property 0 'tabulated-list-id s))
                                        (pos (flycheck-error-pos error)) )
                            (goto-char (flycheck-error-pos error))))
                :history 'counsel-flycheck-history)))


  (define-key my/leader-map (kbd "E") 'counsel-flycheck)
#+END_SRC

** Swiper 
#+BEGIN_SRC emacs-lisp
  (use-package swiper)

  ;;(define-key evil-normal-state-map (kbd "/") 'swiper)
  (global-set-key (kbd "C-s") 'counsel-grep-or-swiper)
  ;;(global-set-key (kbd "C-s") 'counsel-grep)
#+END_SRC

*** Search for thing-at-point
#+BEGIN_SRC emacs-lisp
  (defun my/swiper-thing-at-point ()
    "jump to word under cursor"
    (interactive)
    (counsel-grep-or-swiper (thing-at-point 'word)))
    
  (define-key evil-normal-state-map (kbd "#") 'my/swiper-thing-at-point)
  (define-key evil-normal-state-map (kbd "*") 'my/swiper-thing-at-point)
  (define-key evil-normal-state-map (kbd "M-s") 'my/swiper-thing-at-point)
#+END_SRC

** Ivy rich
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich)

  (ivy-set-display-transformer 'ivy-switch-buffer 'ivy-rich-switch-buffer-transformer)
  (setq ivy-rich-path-style 'abbrev)
  ;; TODO 
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
  (use-package company)

  (setq company-idle-delay 0)
  (setq company-echo-delay 0.1)

  ;; Don't downcase result
  (setq company-dabbbrev-downcase nil)

  ;; Make tooltim margin minimal
  (setq company-tooltip-margin 2)

  ;; Start searching for candidates when 2 letters has been written
  (setq company-minimum-prefix-length 2)

  (add-to-list 'company-transformers 'company-sort-prefer-same-case-prefix)

  (setq company-show-numbers t)

  ;; Make sure only 10 candidates are shown at a time
  (setq company-tooltip-limit 10)

  ;; Align annotations to right side
  (setq company-tooltip-align-annotations t)

  ;; Makes it possible to exit company without a candidate selected
  (setq company-require-match nil)

  ;; Enable scrollbar
  (setq company-tooltip-offset-display 'scrollbar) ;;'line

  (global-company-mode t)

  ;; Remove dabbrev because evil has a better alternative and dabbrev is slow with long files
  (setq company-backends (delete 'company-dabbrev company-backends))
#+END_SRC

*** Company doc buffer
Company doc mode disables visual line mode for whatever reason, enable it inside this redefinition of company-show-doc-buffer
#+BEGIN_SRC emacs-lisp
  (defun my/company-show-doc-buffer ()
    "Temporarily show the documentation buffer for the selection."
    (interactive)
    (let (other-window-scroll-buffer)
      (company--electric-do
        (let* ((selected (nth company-selection company-candidates))
               (doc-buffer (or (company-call-backend 'doc-buffer selected)
                              (user-error "No documentation available")))
               start)
          (with-current-buffer doc-buffer
            (visual-line-mode t))
          (when (consp doc-buffer)
            (setq start (cdr doc-buffer)
                  doc-buffer (car doc-buffer)))
          (setq other-window-scroll-buffer (get-buffer doc-buffer))
          (let ((win (display-buffer doc-buffer t)))
            (set-window-start win (if start start (point-min))))))))

  (define-key company-active-map (kbd "C-h") 'my/company-show-doc-buffer)
#+END_SRC

*** Company-show-numbers but with letters
Need to implement
Letters, etc for autocomplete
line 2769, might also need to change more lines due to "company show numbers" being at a few more places
#+BEGIN_SRC emacs-lisp
;;  (setq right (concat (format " %s" (nth numbered '(a s d f g h j k l i r))) right)))

#+END_SRC

**** Find function that gets hotkey
name "company-complete-number"

*** Disable quickhelp for good
fsharp mode auto-enables quickhelp by default, disable it
#+BEGIN_SRC emacs-lisp
  (setq company-quickhelp-delay nil)
#+END_SRC

*** Visuals
Make company mode inherit colors from theme, change later maybe
#+BEGIN_SRC emacs-lisp
  (require 'color)

  ;; Compatibility with 16 color terminals
  (if (not (string= (face-attribute 'default :background) "unspecified-bg"))
      (let* ((my/background-color (face-attribute 'default :background)))
        (set-face-attribute 'company-scrollbar-bg nil :background (color-lighten-name my/background-color 10))
        (set-face-attribute 'company-scrollbar-fg nil :background (color-lighten-name my/background-color 5))

        ;; Selected entry
        (set-face-attribute 'company-tooltip-selection nil :background (face-attribute 'font-lock-function-name-face :background) :foreground  (face-attribute 'font-lock-function-name-face :foreground))
        ;; All unmatching text
        (set-face-attribute 'company-tooltip nil :foreground (face-attribute 'default :foreground) :background (color-lighten-name my/background-color 2))
        ;; All matching text
        (set-face-attribute 'company-tooltip-common nil :foreground (face-attribute 'font-lock-constant-face :foreground) :background (face-attribute 'font-lock-constant-face :background)))
    (set-face-attribute 'company-scrollbar-bg nil :background "black")
    (set-face-attribute 'company-scrollbar-fg nil :background "white")

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background "black" :foreground "red")
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground "white" :background "black")
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground "orange" :background "black"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)

  (define-key company-active-map (kbd "C-u") 'company-previous-page)
  (define-key company-active-map (kbd "C-w") 'company-next-page)

  ;; using C-h is better in every way 
  (define-key company-active-map (kbd "<f1>") 'nil)


  ;; Show full doc buffer
  (define-key evil-normal-state-map  (kbd "C-,") 'my/company-show-doc-buffer)
  (define-key evil-insert-state-map  (kbd "C-,") 'my/company-show-doc-buffer)

  ;; Force autocomplete
  (define-key evil-normal-state-map  (kbd "C-.") 'company-complete)
  (define-key evil-insert-state-map  (kbd "C-.") 'company-complete)
#+END_SRC

*** Disable persistent binds
#+BEGIN_SRC emacs-lisp
  (add-hook 'company-mode-map 'my/keys-mode-turn-off)
#+END_SRC

** Company-box
Company with icons
Doesn't work with my setup right now
#+BEGIN_SRC emacs-lisp
;;(when window-system
;;  (use-package company-box)
;;
;;  (add-hook 'company-mode-hook 'company-box-mode)
;;
;;  ;;(setq company-box-minimum-width 100)
;;  ;;(setq company-box--height 500)
;;  ;;(setq company-tooltip-minimum 10)
;;
;;  (remove-hook 'company-box-selection-hook 'company-box-doc)
;;  (remove-hook 'company-box-hide-hook 'company-box-doc--hide))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)

  (global-flycheck-mode)
#+END_SRC

** Flycheck-package
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key)

  (which-key-mode)

  (setq which-key-idle-delay 0.5)
#+END_SRC

*** Bind
#+BEGIN_SRC emacs-lisp
  (define-key my/help-map (kbd "m") 'which-key-show-major-mode)
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet)

  (use-package yasnippet-snippets)

  ;;(yas-reload-all)

  (add-hook 'prog-mode-hook 'yas-minor-mode-on)

#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "S") 'yas-insert-snippet)

  (define-key my/help-map (kbd "y") 'yas-describe-tables)
#+END_SRC

* Movement
** Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy)

  (setq avy-keys '(
                   ;; Easy
                   ?a ?n ?e ?t ?o ?s ?h ?d ?i ?r
                   ;; Med
                   ?g ?m ?l ?w ?y ?f ?u ?b ?x ?c ?v ?k ?p ?, ?.
                   ;; Hard
                   ?q ?\; ?j ?\/ ?z

                   ;; Shifted

                   ;; Easy
                   ?A ?N ?E ?T ?O ?S ?H ?D
                   ;; Med
                   ?R ?I ?G ?M ?L ?W ?Y ?F ?U ?B ?X ?C ?V ?K ?P
                   ;; Hard
                   ?Q ?\: ?J ?\? ?Z

                   ;; Digits
                   ?7 ?4 ?8 ?3 ?9 ?2 ?0 ?1
                   ))

  ;; Disable highlighting when avy is used. Doesn't work on 16 color terminals
  (if window-system (setq avy-background t))
#+END_SRC

*** Avy-goto-line
**** Above
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-above-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-above 2 t)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

**** Below
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-below-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-below 2)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

*** Avy-goto-word
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-word-0-in-line(&optional arg)
    (interactive "p")

    (if (not (eq evil-state 'visual))
        (my/evil-normal-state arg))

    (avy-goto-subword-0 t nil (line-beginning-position) (line-end-position)))
#+END_SRC

** Avy flycheck
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :defer t)

  (define-key my/leader-map (kbd "e") 'avy-flycheck-goto-error)
#+END_SRC

** Link-hint
#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :defer t)
#+END_SRC

** View
#+BEGIN_SRC emacs-lisp
(require 'view)

(evil-define-key 'motion my/keys-mode-map (kbd "C-u") 'View-scroll-half-page-backward)
(evil-define-key 'motion my/keys-mode-map (kbd "C-w") 'View-scroll-half-page-forward)

(evil-define-key 'insert my/keys-mode-map (kbd "C-u") '(lambda () (interactive) (evil-normal-state) (View-scroll-half-page-backward)))
(evil-define-key 'insert my/keys-mode-map (kbd "C-w") '(lambda () (interactive) (evil-normal-state) (View-scroll-half-page-forward)))
#+END_SRC

** Jammer
#+BEGIN_SRC emacs-lisp
  (use-package jammer)

  (setq jammer-repeat-delay 1)
  (setq jammer-repeat-window 1)

  (setq jammer-type 'repeat)
  (setq jammer-block-type 'blacklist)
  (setq jammer-block-list '(
                            ;; Backward/forward
                            evil-backward-char evil-forward-char evil-previous-line evil-next-line previous-line next-line
                                               ;; Dired
                                               dired-next-line dired-previous-line



                                               ;; WORD movements
                                               evil-forward-word evil-forward-word-begin evil-forward-word-end
                                               evil-backward-word-begin evil-backward-word-end))
  (jammer-mode)
#+END_SRC

** goto change
g-; and g-,
#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :defer t)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "f") 'avy-goto-char-in-line)
  (define-key my/leader-map (kbd "w") 'my/avy-goto-word-0-in-line)
  (define-key my/leader-map (kbd "g") 'avy-goto-char-2)

  (define-key my/leader-map (kbd "n") 'my/avy-goto-line-below-keep-horizontal-position)
  (define-key my/leader-map (kbd "p") 'my/avy-goto-line-above-keep-horizontal-position)

  ;;(define-key my/keys-mode-map (kbd "M-l") 'link-hint-open-link)
  (define-key my/leader-map (kbd "l") 'link-hint-open-link)
  ;;(define-key my/keys-mode-map (kbd "M-???") 'link-hint-copy-link)
#+END_SRC

* Bookmark management 
#+BEGIN_SRC emacs-lisp
  (defun my/select-bookmark (message)
    (ivy-read message (bookmark-all-names)))

  (defun my/add-bookmark ()
    (interactive)
    (bookmark-set (my/select-bookmark "Add bookmark ")))

  (defun my/delete-bookmark ()
    (interactive)
    (bookmark-delete (my/select-bookmark "Delete bookmark ")))

  ;; doesn't work
  ;; (defun my/load-bookmark-file ()
  ;; (interactive)
  ;; (bookmark-load (ivy-read "load bookmark file " nil)))
#+END_SRC

* Window management
#+BEGIN_SRC emacs-lisp
  (defvar my/window-config-name-changed-hook nil
    "Hook called after user has loaded a window configuration")

  (defvar my/window-configurations nil)
  (defvar my/current-window-configuration "None")

  (defun my/get-window-config-names ()
    (mapcar #'car my/window-configurations))

  (defun my/select-window-config (message)
    (ivy-read message (my/get-window-config-names)))

  (defun my/get-selected-window-config-position (selected-config)
    (cl-position selected-config (my/get-window-config-names) :test 'string=))

  (defun my/update-current-window-config ()
    (setq my/current-window-configuration my/selected-window-config)
    (run-hooks 'my/window-config-name-changed-hook))

  (defun my/add-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Add window config "))

    (setq my/selected-window-config-position (my/get-selected-window-config-position my/selected-window-config))

    (if (eq my/selected-window-config-position nil)
        (push (list my/selected-window-config (current-window-configuration)) my/window-configurations)
      (setf (nth my/selected-window-config-position my/window-configurations) (list my/selected-window-config (current-window-configuration))))

    (my/update-current-window-config))

  (defun my/load-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Load window config "))
    (set-window-configuration (nth 1 (nth (my/get-selected-window-config-position my/selected-window-config) my/window-configurations)))

    (my/update-current-window-config))

  (defun my/delete-window-config ()
    (interactive)
    (setq my/window-configurations (delete (nth (my/get-selected-window-config-position (my/select-window-config "Delete window config ")) my/window-configurations) my/window-configurations)))
#+END_SRC

* Window and buffer settings
** Switch window hook
#+BEGIN_SRC emacs-lisp
  (defvar my/switch-window-hook nil
    "Hook called after user has switched window")

  (defun my/evil-window-up ()
    (interactive)
    (evil-window-up 1)
    (run-hooks 'my/switch-window-hook))

  (defun my/evil-window-down ()
    (interactive)
    (evil-window-down 1)
    (run-hooks 'my/switch-window-hook))

  (defun my/evil-window-left ()
    (interactive)
    (evil-window-left 1)
    (run-hooks 'my/switch-window-hook))

  (defun my/evil-window-right ()
    (interactive)
    (evil-window-right 1)
    (run-hooks 'my/switch-window-hook))

  (defun my/delete-window()
    (interactive)
    (delete-window)
    (run-hooks 'my/switch-window-hook))

  (defun my/delete-other-windows()
    (interactive)
    (delete-other-windows)
    (run-hooks 'my/switch-window-hook))
#+END_SRC

** Switch buffer hook
#+BEGIN_SRC emacs-lisp
  (defvar my/switch-buffer-hook nil
    "Hook called after user has switched buffer")
  (add-hook 'window-configuration-change-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))
  (add-hook 'minibuffer-exit-hook (lambda () (interactive) (run-with-timer 0.1 nil (lambda () (interactive) (run-hooks 'my/switch-buffer-hook)))))
#+END_SRC

** Window settings 
*** Make cursor auto move to new split window
#+BEGIN_SRC emacs-lisp
  (defun my/split-and-follow-horozontally ()
    (interactive)
    (split-window-below)
    ;;(balance-windows)
    (other-window 1))

  (defun my/split-and-follow-vertically()
    (interactive)
    (split-window-right)
    ;;(balance-windows)
    (other-window 1))
#+END_SRC

*** Don't ask for confirmation when killing window
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Buffer settings
Just unbind C-x b
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") nil)
#+END_SRC

*** Kill all buffers
#+BEGIN_SRC emacs-lisp
  (defun my/kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+END_SRC

*** Unique names for identical buffer names
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'nil)
;;(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

* Dired
#+BEGIN_SRC emacs-lisp
  (require 'dired)
#+END_SRC

** Human readable file sizes
Make file sizes human readable
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

** Put deleted files into trash folder
#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Dired async
*** Better async confirmation messages
#+BEGIN_SRC emacs-lisp
  (setq dired-async-message-function
        (lambda (text face &rest args)
          (shell-command (format "echo '%s'" (apply #'format text args)))))
#+END_SRC

** Dired atool
#+BEGIN_SRC emacs-lisp
  (use-package dired-atool)

  (dired-atool-setup)

  (define-key dired-mode-map "c" 'dired-atool-do-pack)
  (define-key dired-mode-map "Z" 'dired-atool-do-unpack-with-subdirectory)
#+END_SRC

** Wdired
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/wdired-mode-map)
  (evil-define-key 'normal wdired-mode-map (kbd (concat my/leader-map-key " a")) 'my/wdired-mode-map)

  (define-key my/wdired-mode-map (kbd "e") 'wdired-finish-edit)
  (define-key my/wdired-mode-map (kbd "u") 'wdired-abort-changes)
#+END_SRC

** Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

** Sorting
Sort dired dir listing in different ways. Modified to work with ivy
URL `http://ergoemacs.org/emacs/dired_sort.html'
Version 2015-07-30"
#+BEGIN_SRC emacs-lisp
  (defun my/dired-sort-menu ()
    (interactive)
    (let ($sort-by $arg)
      (setq $sort-by (completing-read "Sort by:" '( "date" "size" "name" "dir")))
      (cond
       ((equal $sort-by "name") (setq $arg "-Al --si --time-style long-iso "))
       ((equal $sort-by "date") (setq $arg "-Al --si --time-style long-iso -t"))
       ((equal $sort-by "size") (setq $arg "-Al --si --time-style long-iso -S"))
       ((equal $sort-by "dir") (setq $arg "-Al --si --time-style long-iso --group-directories-first"))
       (t (error "logic error 09535" )))
      (dired-sort-other $arg )))

  (define-key dired-mode-map (kbd "s") 'my/dired-sort-menu)

#+END_SRC

*** Bind
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Recursive folder size
#+BEGIN_SRC emacs-lisp
  (use-package dired-du
    :defer t)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-delete-to-trash ()
    (interactive)
    (if (eq delete-by-moving-to-trash nil)
        (progn
          (setq delete-by-moving-to-trash t)
          (message "Delete to trash enabled"))
      (progn
        (setq delete-by-moving-to-trash nil)
        (message "Delete to trash disabled"))))

  (define-prefix-command 'my/dired-mode-map)
  (evil-define-key 'normal dired-mode-map (kbd (concat my/leader-map-key " a")) 'my/dired-mode-map)

  (define-key my/dired-mode-map (kbd "t") 'my/toggle-delete-to-trash)
  (define-key my/dired-mode-map (kbd "w") 'dired-toggle-read-only)
  (defun my/image-dired ()
    (interactive)
    (image-dired default-directory))
  (define-key my/dired-mode-map (kbd "i") 'my/image-dired)

  ;; Make dired work good with evil normal mode
  (evil-define-key 'normal dired-mode-map (kbd "i") 'evil-insert)
  (evil-define-key 'normal dired-mode-map (kbd "RET") 'dired-find-file)
  (evil-define-key 'normal dired-mode-map (kbd "a") 'evil-append)
  (evil-define-key 'normal dired-mode-map (kbd "0") 'evil-digit-argument-or-evil-beginning-of-line)
  (evil-define-key 'normal dired-mode-map (kbd "$") 'evil-end-of-line)
  (evil-define-key 'normal dired-mode-map (kbd "G") 'evil-goto-line)
  (evil-define-key 'normal dired-mode-map (kbd "gg") 'evil-goto-first-line)
  (evil-define-key 'normal dired-mode-map (kbd "y") 'evil-yank)
  (evil-define-key 'normal dired-mode-map (kbd "v") 'evil-visual-char)
  (evil-define-key 'normal dired-mode-map (kbd "V") 'evil-visual-line)
  (evil-define-key 'normal dired-mode-map (kbd "C-v") 'evil-visual-block)

  ;; Bind =Backspace= to go up one directory
  (define-key dired-mode-map [?\d] 'dired-up-directory)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-mode-map)
  (evil-define-key 'normal org-mode-map (kbd (concat my/leader-map-key " a")) 'my/org-mode-map)
  
  (use-package org)
#+END_SRC

** Babel
*** Supported runnable languages
  ;; (org-babel-do-load-languages
   ;; 'org-babel-load-languages
   ;; '((R . t)
     ;; (ditaa . t)
     ;; (dot . t)
     ;; (emacs-lisp . t)
     ;; (gnuplot . t)
     ;; (haskell . nil)
     ;; (ocaml . nil)
     ;; (python . t)
     ;; (ruby . t)
     ;; (screen . nil)
     ;; (sh . t)
     ;; (sql . nil)
     ;; (sqlite . t)))

** Bullets
#+BEGIN_SRC emacs-lisp
  (when window-system
    (use-package org-bullets)

    (add-hook 'org-mode-hook (lambda () (interactive) (org-bullets-mode))))
#+END_SRC

** Visuals
*** Change face of levels
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-level-1 nil :inherit 'outline-1 :height 1.9)
  (set-face-attribute 'org-level-2 nil :inherit 'outline-2 :height 1.6)
  (set-face-attribute 'org-level-3 nil :inherit 'outline-3 :height 1.4)
  (set-face-attribute 'org-level-4 nil :inherit 'outline-4 :height 1.3)
  (set-face-attribute 'org-level-5 nil :inherit 'outline-5 :height 1.25)
  (set-face-attribute 'org-level-6 nil :inherit 'outline-6 :height 1.2)
  (set-face-attribute 'org-level-7 nil :inherit 'outline-7 :height 1.15)
  (set-face-attribute 'org-level-8 nil :inherit 'outline-8 :height 1.10)
#+END_SRC

*** Ellipsis face
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis my/fold-ellipsis)
#+END_SRC

** Indent mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Org SRC
*** Make c-' open in current window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
   
*** SRC region templates
**** Emacs lisp
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

**** R export to image
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("ri" "#+BEGIN_SRC R :results output graphics :file test.png\n?\n#+END_SRC"))
#+END_SRC

** Export
TODO
ox-html5slide
org-html-themes
*** Syntax highlighting for HTML export
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :defer t)
#+END_SRC

*** Twitter bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :defer t)
#+END_SRC

** Agenda
Give agenda file to use
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/Notes/Agenda.org")
      (setq org-agenda-files (quote ("~/Notes/Agenda.org"))))
#+END_SRC
*** Stop agenda from messing with windows
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

*** Display at startup
Spawn agenda buffer
#+BEGIN_SRC emacs-lisp
  (org-agenda-list)
#+END_SRC

**** Declare switch function
Because just giving "*Org Agenda*" to "initial-buffer-choice" doesn't work
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-agenda()
    (interactive)
    (switch-to-buffer "*Org Agenda*"))
#+END_SRC

**** Run switch function as initial buffer choice
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice 'my/switch-to-agenda)
#+END_SRC

**** Close all other open windows at start
#+BEGIN_SRC emacs-lisp
  (delete-other-windows)
#+END_SRC

** Clock
#+BEGIN_SRC emacs-lisp
;;(setq org-clock-mode-line-total today)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/clock-map)
  (define-key my/leader-map (kbd "c") 'my/clock-map)

  (define-key my/clock-map (kbd "s") 'org-clock-in)
  (define-key my/clock-map (kbd "S") 'org-clock-out)
  (define-key my/clock-map (kbd "C-s") 'org-clock-in-last)

  (define-key my/clock-map (kbd "e") 'org-clock-modify-effort-estimate)
#+END_SRC

** Export
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-map)
  (define-key my/org-mode-map (kbd "E") 'my/org-export-map)
#+END_SRC

*** ASCII
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-ascii-map)
  (define-key my/org-export-map (kbd "a") 'my/org-export-ascii-map)

  (define-key my/org-export-ascii-map (kbd "a") 'org-ascii-export-to-ascii)
#+END_SRC

*** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-html-map)
  (define-key my/org-export-map (kbd "h") 'my/org-export-html-map)

  (define-key my/org-export-html-map (kbd "h") 'org-html-export-to-html)
  (define-key my/org-export-html-map (kbd "t") 'org-twbs-export-to-html)
#+END_SRC

*** PDF
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-pdf-map)
  (define-key my/org-export-map (kbd "p") 'my/org-export-pdf-map)

  (define-key my/org-export-pdf-map (kbd "p") 'org-latex-export-to-pdf)
#+END_SRC

*** Beamer presentation
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-slides-map)
  (define-key my/org-export-map (kbd "s") 'my/org-export-slides-map)

  (define-key my/org-export-slides-map (kbd "b") 'org-beamer-export-to-pdf)
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-markdown-map)
  (define-key my/org-export-map (kbd "m") 'my/org-export-markdown-map)

  (define-key my/org-export-markdown-map (kbd "m") 'org-md-export-to-markdown)
#+END_SRC

*** ODT
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-odt-map)
  (define-key my/org-export-map (kbd "o") 'my/org-export-odt-map)

  (define-key my/org-export-odt-map (kbd "o") 'org-odt-export-to-odt)
#+END_SRC

*** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-latex-map)
  (define-key my/org-export-map (kbd "l") 'my/org-export-latex-map)

  (define-key my/org-export-latex-map (kbd "l") 'org-latex-export-to-latex)
#+END_SRC

** Key
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
  (evil-define-key 'normal org-mode-map (kbd "C-TAB") 'org-global-cycle)
  (evil-define-key 'normal org-mode-map (kbd "C-s") 'swiper)

  (define-key my/org-mode-map (kbd "i") 'org-toggle-inline-images)
  (define-key my/org-mode-map (kbd "f") 'org-insert-link)
  (define-key my/org-mode-map (kbd "e") 'org-babel-execute-src-block)

  (define-key my/org-mode-map (kbd "p") 'org-shiftup)
  (define-key my/org-mode-map (kbd "n") 'org-shiftdown)
  (define-key my/org-mode-map (kbd "l") 'org-shiftright)
  (define-key my/org-mode-map (kbd "h") 'org-shiftleft)

  (define-key my/org-mode-map (kbd "P") 'org-metaup)
  (define-key my/org-mode-map (kbd "N") 'org-metadown)
  (define-key my/org-mode-map (kbd "L") 'org-metaright)
  (define-key my/org-mode-map (kbd "H") 'org-metaleft)

  (define-key my/org-mode-map (kbd "|") 'org-table-create-or-convert-from-region)

  (define-key my/org-mode-map (kbd "z") 'org-shifttab)
#+END_SRC

*** Macros
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-macros-map)
  (define-key my/org-mode-map (kbd "m") 'my/org-macros-map)
#+END_SRC

**** Org
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-org-macros-map)
  (define-key my/org-macros-map (kbd "o") 'my/org-org-macros-map)

  ;; Center text, doesn't work for all exports
  (define-key my/org-org-macros-map (kbd "c") (lambda () (interactive) (insert "#+BEGIN_CENTER") (newline) (newline) (insert "#+END_CENTER")))

  ;; Comment
  (define-key my/org-org-macros-map (kbd "C") (lambda () (interactive) (insert "#+BEGIN_COMMENT") (newline) (newline) (insert "#+END_COMMENT")))
#+END_SRC

**** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-latex-macros-map)
  (define-key my/org-macros-map (kbd "l") 'my/org-latex-macros-map)

  ;;Literal latex code for export
  (define-key my/org-latex-macros-map (kbd "i") (lambda () (interactive) (insert "#+LATEX: ")))

  ;; Header
  (define-key my/org-latex-macros-map (kbd "h") (lambda () (interactive) (insert "#+LATEX_HEADER: ")))

  ;; Newline
  (define-key my/org-latex-macros-map (kbd "RET") (lambda () (interactive) (insert "#+LATEX: \\newpage")))

  ;; Fix huge margins
  (define-key my/org-latex-macros-map (kbd "4") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage[a4paper, total={6in, 8in}]{geometry}")))

  ;; Make lists compact
  (define-key my/org-latex-macros-map (kbd "C-l") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage{enumitem}") (newline) (insert "#+LATEX_HEADER: \\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}")))
#+END_SRC

**** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-html-macros-map)
  (define-key my/org-macros-map (kbd "h") 'my/org-html-macros-map)

  ;;Literal HTML code for export
  (define-key my/org-html-macros-map (kbd "i") (lambda () (interactive) (insert "#+HTML: ")))

  ;;HTML break line
  (define-key my/org-html-macros-map (kbd "RET") (lambda () (interactive) (insert "#+HTML: <br><br />")))
#+END_SRC

* Code
** Generic
*** Smartparens
#+BEGIN_SRC emacs-lisp
  ;; (use-package smartparens)
;; 
  ;; (smartparens-global-mode)
#+END_SRC
    
*** Aggressive indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent)

  (global-aggressive-indent-mode)
  ;;(add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
    
*** Whitespace cleanup
#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode)

  (global-whitespace-cleanup-mode)
#+END_SRC

*** indent guide
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides)

  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)

  (setq highlight-indent-guides-method 'column)

  (setq highlight-indent-guides-responsive 'top)
  (setq highlight-indent-guides-delay 0)
#+END_SRC

** Documentation
#+BEGIN_SRC emacs-lisp
  (use-package zeal-at-point
    :defer t)

  (define-key my/leader-map (kbd "d") 'zeal-at-point)
#+END_SRC

** LSP mode
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode)
#+END_SRC

*** Company LSP
#+BEGIN_SRC emacs-lisp
  (use-package company-lsp)

  ;; Requested by lsp java
  (setq company-lsp-enable-snippe t)
  (setq company-lsp-cache-candidates t)
  ;;(push 'java-mode company-global-modes)
  (add-hook 'java-mode-hook (lambda () (push 'company-lsp company-backends)))
#+END_SRC

*** LSP-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui)
#+END_SRC

** Common lisp
*** Slime
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :defer t)

  (setq inferior-lisp-program "/usr/bin/sbcl")
  (setq slime-contribs '(slime-fancy))
#+END_SRC

**** Slime comany
#+BEGIN_SRC emacs-lisp
  (use-package slime-company
    :defer t)

  (slime-setup '(slime-fancy slime-company))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/common-lisp-mode-map)
  (evil-define-key 'normal lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/common-lisp-mode-map)

  (define-key my/common-lisp-mode-map (kbd "d") 'slime-inspect-definition)

#+END_SRC

** Emacs-lisp
*** Eldoc
Shows information in echo area
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

*** Enable debugging on error
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
#+END_SRC

*** Suggest
#+BEGIN_SRC emacs-lisp
  (use-package suggest)
#+END_SRC


*** Formatting
#+BEGIN_SRC emacs-lisp
  (use-package elisp-format)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/emacs-lisp-mode-map)
  (evil-define-key 'normal emacs-lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/emacs-lisp-mode-map)

  (define-key my/emacs-lisp-mode-map (kbd "d") 'find-function)
  (define-key my/emacs-lisp-mode-map (kbd "D") 'find-variable)

  (define-key my/emacs-lisp-mode-map (kbd "c") 'emacs-lisp-byte-compile)

  (define-key my/emacs-lisp-mode-map (kbd "s") 'suggest)

  (define-prefix-command 'my/emacs-lisp-formatting-map)
  (define-key my/emacs-lisp-mode-map (kbd "f") 'my/emacs-lisp-formatting-map)

  (define-key my/emacs-lisp-formatting-map (kbd "b") 'elisp-format-buffer)
  (define-key my/emacs-lisp-formatting-map (kbd "r") 'elisp-format-region)
  (define-key my/emacs-lisp-formatting-map (kbd "f") 'elisp-format-file)
  (define-key my/emacs-lisp-formatting-map (kbd "C-d") 'elisp-format-directory)
  ;; Format marked files in dired
  ;;elisp-format-dired-mark-files
#+END_SRC

** Java
#+BEGIN_SRC emacs-lisp
  (use-package lsp-java)

  (add-hook 'java-mode-hook 'lsp-java-enable)
  (add-hook 'java-mode-hook (lambda () (lsp-ui-flycheck-enable t)))
  (add-hook 'java-mode-hook 'lsp-ui-sideline-mode)

  ;; set the projects that are going to be imported into the workspace.
  (setq lsp-java--workspace-folders 
        (list 
         "~/eclipse-workspace/"
         "~/workspace"))

  (defun my/java-mode ()
    (aggressive-indent-mode 0)

    ;; TODO right now these are permanently set if you start lsp-java mode
    ;; Taken from lsp-java readme
    (setq lsp-inhibit-message t)
    (setq lsp-eldoc-render-all nil)
    (setq lsp-highlight-symbol-at-point nil)

    (setq lsp-ui-sideline-enable t)
    (setq lsp-ui-sideline-show-symbol t)
    (setq lsp-ui-sideline-show-hover t)
    (setq lsp-ui-sideline-show-code-actions t)
    (setq lsp-ui-sideline-update-mode 'point))

  (add-hook 'java-mode-hook 'my/java-mode)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/java-mode-map)
  (evil-define-key 'normal java-mode-map (kbd (concat my/leader-map-key " a")) 'my/java-mode-map)

  (define-key my/java-mode-map (kbd "r") 'lsp-rename)
  (define-key my/java-mode-map (kbd "C-r") 'lsp-workspace-restart)
  (define-key my/java-mode-map (kbd "f") 'lsp-format-buffer)
  (define-key my/java-mode-map (kbd "i") 'lsp-java-organize-imports)
  (define-key my/java-mode-map (kbd "C-b") 'lsp-java-build-project)

  (define-key my/java-mode-map (kbd "d") 'xref-find-definitions)
  (define-key my/java-mode-map (kbd "f") 'xref-find-references)
  (define-key my/java-mode-map (kbd "a") 'xref-find-apropos)

  (define-prefix-command 'my/java-refractor-map)
  (define-key my/java-mode-map (kbd "R") 'my/java-refractor-map)

  (define-key my/java-refractor-map (kbd "c") 'lsp-java-extract-to-constant)
  (define-key my/java-refractor-map (kbd "u") 'lsp-java-add-unimplemented-methods)
  (define-key my/java-refractor-map (kbd "p") 'lsp-java-create-parameter)
  (define-key my/java-refractor-map (kbd "f") 'lsp-java-create-field)
  (define-key my/java-refractor-map (kbd "l") 'lsp-java-create-local)
  (define-key my/java-refractor-map (kbd "m") 'lsp-java-extract-method)
  (define-key my/java-refractor-map (kbd "i") 'lsp-java-add-import)
#+END_SRC

** Python
*** Jedi
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :defer t)

  (add-to-list 'company-backends 'company-jedi)
#+END_SRC

** C#
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :defer t)

#+END_SRC

*** Omnisharp-emacs
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
    :defer t)

  (add-hook 'csharp-mode-hook 'omnisharp-mode)
  (add-to-list 'company-backends 'company-omnisharp)
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/csharp-mode-map)
  (evil-define-key 'normal csharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/csharp-mode-map)

  (define-key my/csharp-mode-map (kbd "r") 'omnisharp-run-code-action-refactoring)
  (define-key my/csharp-mode-map (kbd "f") 'omnisharp-code-format-entire-file)
  (define-key my/csharp-mode-map (kbd "R") 'omnisharp-rename-interactively)
  (define-key my/csharp-mode-map (kbd "s") 'omnisharp-reload-solution)
  (define-key my/csharp-mode-map (kbd "d") 'omnisharp-go-to-definition-other-window)
  (define-key my/csharp-mode-map (kbd "u") 'omnisharp-find-usages)
  (define-key my/csharp-mode-map (kbd "i") 'omnisharp-find-implementations)
  (define-key my/csharp-mode-map (kbd "p") 'omnisharp-navigate-to-solution-file)
  (define-key my/csharp-mode-map (kbd "a") 'omnisharp-solution-actions)
  (define-key my/csharp-mode-map (kbd "e") 'omnisharp-solution-errors)
#+END_SRC

**** Write formatting settings to omnisharp server config
omnisharp.json should be in ~/.omnisharp on all OSs
#+BEGIN_SRC emacs-lisp
;; if(not(file-directory-p "~/.omnisharp")
;;     (make-directory "~/.omnisharp"))
;;
;; (if(not(file-exists-p "~/.omnisharp/omnisharp.json"))
;;     (progn
;;       (write-region "
;;         {
;;             \"formattingOptions\": {
;;                 PUT OPTIONS HERE
;;             }
;;         }
;;        " nil "~/.omnisharp/omnisharp.json")
;;
;;       (message "~/.omnisharp/omnisharp.json created")
;;       )
;;   )
#+END_SRC

** F#
#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode)

  (setq fsharp-doc-idle-delay 0.1)

  ;;(setq-default fsharp-indent-offset 2)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/fsharp-mode-map)
  (evil-define-key 'normal fsharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/fsharp-mode-map)

  (define-key my/fsharp-mode-map (kbd "d") 'fsharp-ac/gotodefn-at-point)
  (define-key my/fsharp-mode-map (kbd "v") 'fsharp-mark-phrase)
  (define-key my/fsharp-mode-map (kbd "b") 'fsharp-goto-block-up)
  (define-key my/fsharp-mode-map (kbd "C-r") 'fsharp-ac-status)
  (define-key my/fsharp-mode-map (kbd "C-k") 'fsharp-ac/stop-process)
  (define-key my/fsharp-mode-map (kbd "C-s") 'fsharp-ac/start-process)

  (define-key fsharp-mode-map (kbd "C-x C-e") 'fsharp-eval-region)
#+END_SRC

*** Settings
#+BEGIN_SRC emacs-lisp
  (defun my/fsharp-mode()
    ;; Disable not so helpful modes
    ;; (pretty-mode 0)
    (aggressive-indent-mode 0)
    ;; Fsharp has built in intellisense highlight thing at point
    (highlight-thing-mode -1)
    (pretty-mode -1)
    ;; Visual line mode in fsharp mode is broken, makes swiper take years to start, use truncate lines mode instead
    (visual-line-mode 0)
    (toggle-truncate-lines nil))

  ;; Autostart
  (add-hook 'fsharp-mode-hook 'my/fsharp-mode)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :defer t)
#+END_SRC

*** Cider
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :defer t)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal clojure-mode-map (kbd (concat my/leader-map-key " a e")) 'cider-eval-defun-at-point)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :defer t)
#+END_SRC

** Web mode
TODO: Fix settings, grab them from package site 
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :defer t)

  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.xml?\\'" . web-mode))
#+END_SRC

* Pass
Required by ivy-pass
#+BEGIN_SRC emacs-lisp
  (use-package password-store)
#+END_SRC

** Ivy pass
#+BEGIN_SRC emacs-lisp
  (use-package ivy-pass)
#+END_SRC

** Auto-clean kill ring
#+BEGIN_SRC emacs-lisp
  ;;(defvar my/pass-in-killring nil)

  ;; (defun my/ivy-pass ()
    ;; (interactive)
    ;; (setq my/pass-in-killring t)
    ;; (ivy-pass))
  ;; 
  ;; (defun my/pass-pop-killring ()
    ;; (if (eq my/pass-in-killring t)
        ;; (progn
          ;; (pop kill-ring)
          ;; (setq my/pass-in-killring nil))))


  (defun my/pop-killring ()
    (pop kill-ring)
    (setq my/pass-in-killring nil))

  (define-key my/leader-map (kbd "C-k") 'my/pop-killring)
  ;;(advice-add 'evil-goggles--paste-advice :before (lambda () (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-goggles--paste-advice :before 
  ;;(advice-add 'evil-paste-after :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-paste-before :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
#+END_SRC

* Shell
#+BEGIN_SRC emacs-lisp
  (setq eshell-buffer-name "s")
  (defun my/eshell ()
    (interactive)
    (eshell)
    (my/give-buffer-unique-name "*eshell*"))

  (define-key my/leader-map (kbd "[") 'my/eshell)
#+END_SRC

** Term
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "{") 'ansi-term)
#+END_SRC

** Disable minor modes
Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

** Use ansi term for certain applications
#+BEGIN_SRC emacs-lisp
  (require 'em-term)
  (add-to-list 'eshell-visual-commands "vim")
#+END_SRC

* Keys
** Key rebinds
#+BEGIN_SRC emacs-lisp
  (require 'evil-maps)
#+END_SRC

*** General
More rebind options and more reliable
#+BEGIN_SRC emacs-lisp
  (use-package general)

  (general-evil-setup)
#+END_SRC

*** k(Move up) <--> p(Paste)
**** k
#+BEGIN_SRC emacs-lisp
   (define-key evil-normal-state-map "k" 'evil-paste-after)
   (define-key evil-normal-state-map "K" 'evil-paste-before)

  (define-key evil-visual-state-map "k" 'evil-visual-paste)

  ;; Universal paste key
  (global-set-key (kbd "C-k") 'evil-paste-after)
  (global-set-key (kbd "C-K") 'evil-paste-before)
  (define-key evil-insert-state-map (kbd "C-k") 'evil-paste-after)
  (define-key evil-insert-state-map (kbd "C-K") 'evil-paste-before)

  (define-key evil-window-map "k" 'evil-window-mru)
#+END_SRC

**** p
#+BEGIN_SRC emacs-lisp
(define-key evil-window-map "p" 'evil-window-up)
(define-key evil-window-map "P" 'evil-window-move-very-top)

(define-key evil-normal-state-map "p" 'evil-previous-line)
(define-key evil-motion-state-map "p" 'evil-previous-line)

(define-key evil-normal-state-map "P" 'evil-lookup)
(define-key evil-motion-state-map "P" 'evil-lookup)

(define-key evil-window-map (kbd "C-S-p") 'evil-window-move-very-top)

(define-key evil-normal-state-map "gp" 'evil-previous-visual-line)
(define-key evil-motion-state-map "gp" 'evil-previous-visual-line)
#+END_SRC

*** n(Move up) <--> j(search-next)
**** n
#+BEGIN_SRC emacs-lisp
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "N" 'evil-window-move-very-bottom)

  (define-key evil-normal-state-map "n" 'evil-next-line)
  (define-key evil-motion-state-map "n" 'evil-next-line)

  (define-key evil-normal-state-map "N" 'evil-join)


  ;; ex
  ;;  (evil-ex-define-cmd "j[oin]" 'evil-ex-join)
  ;;  (evil-ex-define-cmd "ju[mps]" 'evil-show-jumps)

  (define-key evil-normal-state-map "gN" 'evil-join-whitespace)

  (define-key evil-normal-state-map "gn" 'evil-next-visual-line)
  (define-key evil-motion-state-map "gn" 'evil-next-visual-line)

  (define-key evil-window-map (kbd "C-S-n") 'evil-window-move-very-bottom)
#+END_SRC

**** j 
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map "j" 'evil-search-next)
  (define-key evil-motion-state-map "j" 'evil-search-next)

  (define-key evil-normal-state-map "J" 'evil-search-previous)
  (define-key evil-motion-state-map "J" 'evil-search-previous)

  ;; ex
  ;;(evil-ex-define-cmd "new" 'evil-window-new)
  ;;(evil-ex-define-cmd "norm[al]" 'evil-ex-normal)
  ;;(evil-ex-define-cmd "noh[lsearch]" 'evil-ex-nohighlight)

  (define-key evil-motion-state-map "gj" 'evil-next-match)
  (define-key evil-motion-state-map "gJ" 'evil-previous-match)
#+END_SRC

*** Rebind save key
#+BEGIN_SRC emacs-lisp
  (general-simulate-key "C-x C-s")

  (defun my/save-and-backup-session()
    (interactive)
    (my/force-backup-of-buffer)
    (general-simulate-C-x_C-s))

  (define-key my/leader-map (kbd "s") 'my/save-and-backup-session)
#+END_SRC

*** Rebind C-d
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-d") nil)
  (define-key evil-motion-state-map (kbd "C-d") nil)
#+END_SRC

*** Rebind esc
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "<escape>") (kbd "C-e"))
  (define-key key-translation-map (kbd "C-e") (kbd "<escape>"))
#+END_SRC

*** Rebind enter
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "RET") (kbd "C-a"))
  (define-key key-translation-map (kbd "C-a") (kbd "RET"))
#+END_SRC

*** Rebind tab
Use C-i instead
#+BEGIN_SRC emacs-lisp
  ;;(define-key my/keys-mode-map (kbd "C-e") 'my/simulate-esc)
  ;;(define-key key-translation-map (kbd "?\\t") (kbd "C-="))
  (define-key key-translation-map (kbd "TAB") (kbd "C-="))
  (define-key key-translation-map (kbd "<tab>") (kbd "C-="))
  (define-key key-translation-map (kbd "C-t") (kbd "TAB"))
  (define-key key-translation-map (kbd "M-C-t") (kbd "C-TAB"))
#+END_SRC

*** Rebind backspace
#+BEGIN_SRC emacs-lisp
  ;; (define-key key-translation-map (kbd "C-e") (kbd "TAB"))
  ;; (define-key key-translation-map (kbd "M-C-i") (kbd "C-TAB"))


#+END_SRC

*** Add eval to leader
#+BEGIN_SRC emacs-lisp
  (general-simulate-key "C-x C-e")

  (defun my/simulate-C-x_C-e ()
    (interactive)
    (general-simulate-C-x_C-e))

  (define-key my/leader-map (kbd "x") 'my/simulate-C-x_C-e)
  (define-key my/leader-map (kbd "X") 'eval-buffer)
#+END_SRC

* exwm
#+BEGIN_SRC emacs-lisp
  (use-package exwm)

  (require 'exwm)
  ;; necessary to configure exwm manually
  (require 'exwm-config)
  ;;(exwm-config-ido)

  ;; Fix magit ediff
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; enable exwm
  (exwm-enable)
#+END_SRC

** Name buffers after window name
We use class names for all windows expect for Java applications and GIMP (because of problems with those).
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                         (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (not exwm-instance-name)
                       (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                       (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC

** Launch programs with hotkeys
#+BEGIN_SRC emacs-lisp
  ;; (define-prefix-command 'my/x-launch-map)
  ;; (define-key my/leader-map (kbd "l") 'my/x-launch-map)
#+END_SRC

*** Define functions
Define main function
#+BEGIN_SRC emacs-lisp
  ;; (defun my/async-run (name)
    ;; (interactive)
    ;; (start-process name nil name))
#+END_SRC

*** Run programs functions
#+BEGIN_SRC emacs-lisp
  ;; (defun my/launch-virt-manager ()
    ;; (interactive)
    ;; (my/async-run "virt-manager"))
  ;; 
  ;; ;;(global-set-key (kbd "s-z") 'my/launch-virt-manager)
  ;; (define-key my/x-launch-map (kbd "z") 'my/launch-virt-manager)
  ;; 
  ;; (defun my/launch-lock-screen ()
    ;; (interactive)
    ;; (my/async-run "slock"))
  ;; 
  ;; (global-set-key (kbd "<XF86ScreenSaver>") 'my/launch-lock-screen)
  ;; (define-key my/x-launch-map (kbd "l") 'my/launch-lock-screen)
#+END_SRC

** Multi-screen
#+BEGIN_SRC emacs-lisp
  (defvar my/monitor-amount 1)

  (if (file-exists-p (concat user-emacs-directory "randr-home"))
      (progn
        ;; We need 3 frames to fill up monitors
        (setq exwm-workspace-number 3)
        (setq my/monitor-amount 3)
        (setq exwm-randr-workspace-output-plist '(1 "DVI-D-1" 0 "DP-1" 2 "DVI-I-1"))))

  (if (> my/monitor-amount 1)
      (progn
        (require 'exwm-randr)
        (exwm-randr-enable)))
#+END_SRC

*** Switch monitor (workspace) functions
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'focus-out-hook 'exwm-layout--refresh)
  (defun my/switch-monitor-left ()
    (interactive)
    (if (>= exwm-workspace-current-index (- my/monitor-amount 1))
        (exwm-workspace-switch-create 0)
      (exwm-workspace-switch-create (+ exwm-workspace-current-index 1))))

  (defun my/switch-monitor-right ()
    (interactive)
    (if (= exwm-workspace-current-index 0)
        (exwm-workspace-switch-create (- my/monitor-amount 1))
      (exwm-workspace-switch-create (- exwm-workspace-current-index 1))))

  ;;(define-key my/keys-mode-map (kbd "M-l") 'my/switch-monitor-right)
  ;;(define-key my/keys-mode-map (kbd "M-h") 'my/switch-monitor-left)
#+END_SRC

** Settings
#+BEGIN_SRC emacs-lisp
  ;; Garbage collect when entering x window (because x is not in sync with emacs)
  ;;(add-hook 'exwm-mode-hook 'garbage-collect)

  (setq exwm-workspace-show-all-buffers t)

  (setq exwm-workspace-minibuffer-position 'top)

  (add-hook 'exwm-init-hook (lambda () (interactive) (exwm-workspace-attach-minibuffer)))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  ;; Rebind keys in exwm bufffers
  (setq exwm-input-simulation-keys
        '(
          ;; movement
          ([?\C-h] . [left])
          ([?\M-h] . [C-left])
          ([?\C-l] . [right])
          ([?\M-l] . [C-right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ([?\C-u] . [prior])
          ([?\C-w] . [next])

          ;; cut/paste.
          ([?\C-y] . [?\C-c])
          ([?\C-k] . [?\C-v])

          ;; enter
          ([?\C-a] . [return])

          ;; tab
          ;;([?\C-t] . [tab])
          ;; ([?\t] . [?\C-=])
          ;; ([tab] . [?\C-=])

          ;; escape
          ([?\C-e] . [escape])

          ;; search
          ([?\C-s] . [?\C-f])))

  ;; Exwm don't send back these keys
  (dolist (k '(XF86AudioLowerVolume
               XF86AudioRaiseVolume
               XF86PowerOff
               XF86AudioMute
               XF86AudioPlay
               XF86AudioStop
               XF86AudioPrev
               XF86AudioNext
               XF86ScreenSaver
               XF68Back
               XF86Forward
               Scroll_Lock
               print
               C-x
               C-g
               C-h
               C-SPC
               ;;TAB
               ;;C-TAB
               ;; Exwm grab and release keyboard
               M-j
               M-k
               ))
    (cl-pushnew k exwm-input-prefix-keys))

  ;; Some keys have to be defined using "exwm-input-set-key" in order to be usable if they are in "exwm-input-prefix-keys"

  (exwm-input-set-key (kbd my/mod-leader-map-key) 'my/leader-map)

  (exwm-input-set-key (kbd "TAB") 'my/window-hydra/body)
  (exwm-input-set-key (kbd "<tab>") 'my/window-hydra/body)
  ;; (exwm-input-set-key (kbd "TAB") 'my/window-hydra/body)
  ;; (exwm-input-set-key (kbd "C-TAB") 'my/window-hydra/body)
  ;; (exwm-input-set-key (kbd "<tab>") 'my/window-hydra/body)
  ;; (exwm-input-set-key (kbd "C-<tab>") 'my/window-hydra/body)

  (exwm-input-set-key (kbd my/mod-window-leader-key) 'my/window-hydra/body)

  (exwm-input-set-key (kbd "C-h") help-map)

  ;; Enter and exit char mode
  (exwm-input-set-key (kbd "M-a") 'exwm-input-grab-keyboard)
  (exwm-input-set-key (kbd "M-i") 'exwm-input-release-keyboard)
#+END_SRC

* Version control
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/vc-map)
  (define-key my/leader-map (kbd "v") 'my/vc-map)
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile)

  ;; Disable projectile mode so that CPU isn't taken by projectile wating to refresh git project directory all the time
  (projectile-mode 0)
#+END_SRC

** Counsel projectile
If enabled it auto enables projectile, which has high CPU usage

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t)

  (setq git-commit-summary-max-length 50)
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl)

  (global-diff-hl-mode)

  ;; If there is no fringe (terminal), use margin instead
  (unless (display-graphic-p) (diff-hl-margin-mode))

  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)

  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

  ;;(diff-hl-flydiff-mode)
#+END_SRC

** Keys 
#+BEGIN_SRC emacs-lisp
  (define-key my/vc-map (kbd "o") 'counsel-projectile)
  (define-key my/vc-map (kbd "a") 'counsel-projectile-ag)
  (define-key my/vc-map (kbd "d") 'projectile-dired)
  (define-key my/vc-map (kbd "D") 'counsel-projectile-find-dir)
  (define-key my/vc-map (kbd "l") 'counsel-projectile-find-file)

  (define-key my/vc-map (kbd "K") 'projectile-kill-buffers)
  (define-key my/vc-map (kbd "f") 'counsel-projectile-switch-to-buffer)
  (define-key my/vc-map (kbd "F") 'projectile-ibuffer)

  (define-key my/vc-map (kbd "S") 'projectile-save-project-buffers)
  (define-key my/vc-map (kbd "C") 'projectile-compile-project)

  (define-key my/vc-map (kbd "!") 'projectile-run-shell-command-in-root)
  (define-key my/vc-map (kbd "&") 'projectile-run-async-shell-command-in-root)

  (define-key my/vc-map (kbd "s") 'magit-status)
#+END_SRC

* Media
** Volume keys
#+BEGIN_SRC emacs-lisp
  (defun my/amixer-mute ()
    (interactive)
    (shell-command "amixer -q -D pulse set Master toggle"))

  (global-set-key (kbd "<XF86AudioMute>") 'my/amixer-mute)
  (global-set-key (kbd "s-`") 'my/amixer-mute)

  (defun my/amixer-raise-volume ()
    (interactive)
    (shell-command "amixer -q -D pulse set Master 4%+ unmute"))

  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'my/amixer-raise-volume)
  (global-set-key (kbd "s-=") 'my/amixer-raise-volume)

  (defun my/amixer-lower-volume ()
    (interactive)
    (shell-command "amixer -q -D pulse set Master 4%- unmute"))

  (global-set-key (kbd "<XF86AudioLowerVolume>") 'my/amixer-lower-volume)
  (global-set-key (kbd "s--") 'my/amixer-lower-volume)
#+END_SRC

** Music
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/music-map)
  (define-key my/leader-map (kbd "M") 'my/music-map)
#+END_SRC

*** EMMS
Setup emms
#+BEGIN_SRC emacs-lisp
  (defvar my/emms-has-init nil)

  (defvar my/emms-init-hook nil
    "Hook called when emms has to init fully")

  (use-package emms)


  (add-hook 'my/emms-init-hook (lambda () (interactive)
                                 (unless my/emms-has-init
                                   (setq my/emms-has-init t)
                                   (require 'emms-setup)
                                   (require 'emms-player-mpd)

                                   (emms-all) 
                                   ;; Disable name of playing track in modeline (time is kept though)
                                   (emms-mode-line-disable))))

  (setq emms-mode-line-format nil)

  (setq emms-seek-seconds 5)
  (setq emms-player-list '(emms-player-mpd))
  (setq emms-info-functions '(emms-info-mpd))

  (setq emms-player-mpd-server-name "localhost")
  (setq emms-player-mpd-server-port "6600")

  ;;(setq mpc-host "localhost:6600")
#+END_SRC

**** Sort by directory name instead of metadata
#+BEGIN_SRC emacs-lisp
  (setq emms-browser-get-track-field-function 'emms-browser-get-track-field-use-directory-name)
#+END_SRC

**** Open playlist
emms doesn't automatically connect to mpd when loading playlist, results in empty playlist
#+BEGIN_SRC emacs-lisp
  (defun my/open-emms-and-connect()
    "Reconnect to MPD and open emms playlist"
    (interactive)
    (run-hooks 'my/emms-init-hook)
    (emms-player-mpd-connect)
    (emms-smart-browse))
#+END_SRC

**** Sync MPD and emms
#+BEGIN_SRC emacs-lisp
  (defun my/sync-mpd-and-emms ()
    "Updates the MPD and emms database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (emms-player-mpd-update-all-reset-cache)
    (emms-cache-set-from-mpd-all)
    (emms-player-mpd-connect)
    (message "MPD database and emms updated!"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (require 'emms-browser)
  (define-key my/music-map (kbd "u") 'my/sync-mpd-and-emms) 

  (define-key my/music-map (kbd "o") 'my/open-emms-and-connect)
  (define-key my/music-map (kbd "g") 'emms-seek-to)
  (define-key my/music-map (kbd "s") 'emms-pause)

  (define-key emms-browser-mode-map (kbd "s") 'emms-pause)

  (evil-define-key 'normal emms-browser-mode-map (kbd "RET") 'emms-browser-add-tracks)

  (evil-define-key 'normal emms-playlist-mode-map (kbd "RET") 'emms-playlist-mode-play-smart)

  (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause)
  (global-set-key (kbd "<XF86AudioStop>") 'emms-stop)
#+END_SRC

*** MPD
**** Start MPD
#+BEGIN_SRC emacs-lisp
  (defun my/start-mpd ()
    "Start MPD, connect to it and sync the metadata cache."
    (interactive)
    (start-process "mpd" nil "mpd")
    (message "MPD started and synced!"))
#+END_SRC

**** Kill daemon
#+BEGIN_SRC emacs-lisp
 (defun my/kill-music-daemon ()
   "Stops playback and kill the music daemon."
   (interactive)
   (emms-stop)
   (call-process "killall" nil nil nil "mpd")
   (message "MPD killed!"))
#+END_SRC

**** View MPD info
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-info ()
    "Runs mpc, showing info in message field"
    (interactive)
    (shell-command "mpc"))
#+END_SRC

**** Shuffle playlist random
***** Random on
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-on ()
    "Turns on MPD random play"
    (interactive)
    (shell-command "mpc random on"))
#+END_SRC

***** Random off
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-off ()
    "Turns off MPD random play"
    (interactive)
    (shell-command "mpc random off"))
#+END_SRC

**** Volume control
***** Raise volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-raise-volume()
  (interactive)
  (shell-command "mpc volume +4"))
#+END_SRC

***** Lower volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-lower-volume ()
  (interactive)
  (shell-command "mpc volume -4"))
#+END_SRC

**** Change song
***** Next song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-next-song()
  (interactive)
  (shell-command "mpc next"))
#+END_SRC

***** Previous song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-previous-song()
  (interactive)
  (shell-command "mpc prev"))
#+END_SRC

**** Change time on track
***** Forward
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-forward()
    (interactive)
    (shell-command "mpc seek +10"))
#+END_SRC

***** Forward far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-forward()
    (interactive)
    (shell-command "mpc seek +60"))
#+END_SRC

***** Backwards
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-backward()
    (interactive)
    (shell-command "mpc seek -10"))
#+END_SRC

***** Backwards far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-backward()
    (interactive)
    (shell-command "mpc seek -60"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/music-map (kbd "C-s") 'my/start-mpd)
  (define-key my/music-map (kbd "C-k") 'my/kill-music-daemon)
  (define-key my/music-map (kbd "i") 'my/mpd-info)

  (define-key my/music-map (kbd "r") 'my/mpd-random-on)
  (define-key my/music-map (kbd "C-r") 'my/mpd-random-off)

  (define-key my/music-map (kbd "=") 'my/mpd-raise-volume)
  (define-key my/music-map (kbd "-") 'my/mpd-lower-volume)

  (define-key my/music-map (kbd "n") 'my/mpd-next-song)
  (define-key my/music-map (kbd "p") 'my/mpd-previous-song)

  (define-key my/music-map (kbd "l") 'my/mpd-wind-forward)
  (define-key my/music-map (kbd "h") 'my/mpd-wind-backward)
  (define-key my/music-map (kbd "L") 'my/mpd-wind-far-forward)
  (define-key my/music-map (kbd "H") 'my/mpd-wind-far-backward)

  (global-set-key (kbd "<XF86AudioNext>") 'my/mpd-next-song)
  (global-set-key (kbd "<XF86AudioPrev>") 'my/mpd-previous-song)
#+END_SRC

* Screenshots
** Functions
*** Entire screen
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
      (sit-for 1)
      (start-process "screenshot" nil "import" "-window" "root" 
                     (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))))
#+END_SRC

*** Region
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC 

*** Region ask for name
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region-and-ask-for-name ()
    "Takes a screenshot of a region selected by the user and asks for file path"
    (interactive)
    (when window-system

      ;; Check if there is a directory called "images" in current dir, if so start read-file-name inside that directory
      (if(file-exists-p (concat default-directory "images/"))
          (setq screenshot-base-path (concat default-directory "images/"))
        (setq screenshot-base-path default-directory))

      ;; If screenshot path is not empty
      (call-process "import" nil nil nil ".newScreen.png")

      ;; Ask for path
      (setq screenshot-path (read-file-name "Screenshot file (.png already added) " screenshot-base-path))

      (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1" (concat screenshot-path ".png"))
      (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<print>") 'my/take-screenshot-region-and-ask-for-name)

  ;;  (define-key my/leader-map (kbd "p r") 'my/take-screenshot-region)
  ;;  (define-key my/leader-map (kbd "p w") 'my/take-screenshot)
#+END_SRC

* Gnus
.gnus.el is written in =write config map=
#+BEGIN_SRC emacs-lisp
  (require 'gnus)
  (define-key my/open-map (kbd "g") 'gnus)
#+END_SRC

** Agent
#+BEGIN_SRC emacs-lisp
  (setq gnus-agent-cache t)

  ;; auto go online????
  ;;(setq gnus-agent-go-online t)

  ;; ???
  ;;(setq gnus-agent-consider-all-articles nil)


  ;; Topic prompts
  ;;(setq gnus-server-unopen-status VALUE)
  ;; Message prompts
  ;;(setq gnus-auto-goto-ignores VALUE)

  ;; never que mail if sent when offline, change later
  (setq gnus-agent-queue-mail nil)

  (require 'gnus-agent)
  (add-to-list 'gnus-category-alist '(gmail (agent-predicate . short)))
#+END_SRC

** Global
#+BEGIN_SRC emacs-lisp
  ;;Fix bug in gnus, Replace [ and ] with _ in ADAPT file names
  (setq nnheader-file-name-translation-alist '((?[ . ?_) (?] . ?_)) )
#+END_SRC

** Minor settings
#+BEGIN_SRC emacs-lisp

  ;; Maybe disable later
  ;;(setq gnus-save-killed-list nil)

  (setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))

  ;; '(gnus-always-force-window-configuration t)

  ;; Disable signatures
  (setq message-signature nil)

  ;; never split messages
  (setq message-send-mail-partially-limit nil)

  ;; Disable gnus expiration
  (setq gnus-agent-enable-expiration 'DISABLE)

  ;; Create two connections to the server for faster fetching
  (setq gnus-asynchronous t)

  ;; Disable .newsrc file (file can be read by other newsreaders)
  (setq gnus-read-newsrc-file nil)
  (setq gnus-save-newsrc-file nil)

  ;; Replace with ivy later. Default value: "gnus-emacs-completing-read"
  (setq gnus-completing-read-function (quote gnus-ido-completing-read))

  ;; Don't mark unread after download
  (setq gnus-agent-mark-unread-after-downloaded nil)

  ;; Maybe need to enable again
  ;; '(gnus-article-date-lapsed-new-header t)
#+END_SRC

** Group mode
Mode for choosing server
#+BEGIN_SRC emacs-lisp
(defun my/gnus-group-mode ()
  ;; Tree view for groups.
  (gnus-topic-mode)
  ;; List all groups over level 5
  (gnus-group-list-all-groups 5))

(add-hook 'gnus-group-mode-hook 'my/gnus-group-mode)

;; Always show inbox
;; (setq gnus-permanently-visible-groups "INBOX")

;; Apparently only some servers support using 'some
;;(setq gnus-read-active-file 't)
 (setq gnus-read-active-file 'some)
 (setq gnus-check-new-newsgroups 'ask-server)
#+END_SRC

*** Methods
#+BEGIN_SRC emacs-lisp
(setq gnus-select-method '(nntp "news.gmane.org"))

(add-to-list 'gnus-secondary-select-methods
             '(nnimap "Gmail"
                      (nnimap-address "imap.gmail.com")
                      (nnimap-server-port "imaps")
                      (nnimap-stream ssl)
                      ;; Don't want to delete mails on server
                      ;; (nnmail-expiry-target "nnimap+gmail:[Gmail]/Trash")  ;; Move expired messages to Gmail's trash.
                      (nnmail-expiry-wait 90)))
                      
(setq smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      ;; Make Gnus NOT ignore [Gmail] mailboxes
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
#+END_SRC

*** Topic mode
Adds headers to each server, tree view
#+BEGIN_SRC emacs-lisp
      (defun my/gnus-topic-mode ()
        ;; Tree view for groups.
        ;; List all groups over level 5
        (my/gnus-topic-setup))

  (add-hook 'gnus-topic-mode-hook 'my/gnus-topic-mode)


  (defun my/gnus-topic-setup ()
    "Hides non-relevant servers and puts them into categories. To show all servers, disable my/gnus-topic-mode"

    ;; "Gnus" is the root folder, and there are three mail accounts, "misc", "hotmail", "gmail"
    (setq gnus-topic-topology '(("Gnus" visible)
                                (("hotmail" visible nil nil))
                                (("gmail" visible nil nil))))

    (setq gnus-topic-alist '(("hotmail"
                              "nnimap+hotmail:Inbox"
                              "nnimap+hotmail:Drafts"
                              "nnimap+hotmail:Sent"
                              "nnimap+hotmail:Junk"
                              "nnimap+hotmail:Deleted")
                             ("gmail"
                              "nnimap+Gmail:INBOX"
                              "nnimap+Gmail:[Gmail]/Sent Mail"
                              "nnimap+Gmail:[Gmail]/Spam"
                              "nnimap+Gmail:[Gmail]/Trash"
                              "nnimap+Gmail:[Gmail]/Drafts"
                              )
                             ("Gnus"))))

  ;; (eval-after-load 'gnus-topic
    ;; '(progn
       ;; (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
       ;; (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/Mail/archive")
                                  ;; (nnfolder-active-file "~/Mail/archive/active")
                                  ;; (nnfolder-get-new-mail nil)
                                  ;; (nnfolder-inhibit-expiry t))
                                 ;; ))))

#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal gnus-group-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-group-mode-map (kbd "RET") 'gnus-topic-select-group)

  (define-prefix-command 'my/gnus-group-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-group-map)

  (defun my/gnus-group-list-all-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key 'my/gnus-group-map (kbd "a") 'my/gnus-group-list-all-subscribed-groups)
#+END_SRC

** Summary mode
Mode for choosing which mail to open
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-summary-mode ()
    (visual-line-mode 0))

   ;; '(gnus-summary-mode-line-format "U%U %S" )
  (setq-default gnus-summary-line-format "%U%R%d %-5,5L %-20,20n %B%-80,80S\n")
  (add-hook 'gnus-summary-mode-hook 'my/gnus-summary-mode)

  (setq-default gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)

  (setq-default gnus-sum-thread-tree-false-root "")
  (setq-default gnus-sum-thread-tree-indent " ")
  (setq-default gnus-sum-thread-tree-leaf-with-other "├► ")
  (setq-default gnus-sum-thread-tree-root "")
  (setq-default gnus-sum-thread-tree-single-leaf "╰► ")
  (setq-default gnus-sum-thread-tree-vertical "│")


   ;; '(gnus-summary-thread-gathering-function (quote gnus-gather-threads-by-references))

   ;; '(gnus-thread-hide-subtree t)
   ;; '(gnus-thread-sort-functions (quote gnus-thread-sort-by-most-recent-date))
   ;; '(gnus-treat-hide-citation t)
   ;; '(gnus-unread-mark 42)
   ;; '(gnus-ancient-mark 32)
#+END_SRC

*** Thread sorting
#+BEGIN_SRC emacs-lisp
;; Sort by date
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-most-recent-date
        (not gnus-thread-sort-by-number)))
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
 ;; '(gnus-summary-high-unread ((t (:foreground "green"))))
 ;; '(gnus-summary-low-read ((t (:foreground "magenta"))))
 ;; '(gnus-summary-normal-read ((t (:foreground "red"))))
 ;; '(gnus-summary-selected ((t (:background "yellow"))))
 ;; '(gnus-summary-normal-unread ((t (:foreground "white"))))
#+END_SRC

*** Scoring
#+BEGIN_SRC emacs-lisp
(setq gnus-parameters
      '(("nnimap.*"
         (gnus-use-scoring nil)) ;scoring is annoying when I check latest email
        ))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-summary-map)
  (evil-define-key 'normal gnus-summary-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-summary-map)

  (evil-define-key 'normal gnus-summary-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-summary-mode-map (kbd "RET") (lambda () (interactive) (gnus-summary-scroll-up 1)))

  (defun my/gnus-summary-show-all-mail ()
    "Show all mail"
    (interactive)
    (gnus-summary-rescan-group 1))

  (define-key 'my/gnus-summary-map (kbd "a") 'my/gnus-summary-show-all-mail)
#+END_SRC

** Article mode
Mode for reading contents of mail
#+BEGIN_SRC emacs-lisp
(defun my/gnus-article-mode ()
  ;; Font lock mode disables colors in html mail for whatever reason
  (font-lock-mode -1))

(add-hook 'gnus-article-mode-hook 'my/gnus-article-mode)

(defun my/gnus-article-display-mode ()
  ;;  (gnus-article-de-quoted-unreadable)
  ;;  (gnus-article-emphasize)
  ;;  (gnus-article-hide-boring-headers)
  ;;  (gnus-article-hide-headers-if-wanted)
  ;;  (gnus-article-hide-pgp)
  ;;  (gnus-article-highlight)
  ;;  (gnus-article-highlight-citation)
  ;;  (gnus-article-date-local)
  )

(add-hook 'gnus-article-display-hook 'my/gnus-article-display-mode)

 ;; '(gnus-article-mode-line-format "U%U %S" )
#+END_SRC

*** Date headers
Make date headers better with timezone calculation and time passed
#+BEGIN_SRC emacs-lisp

(setq gnus-article-date-headers '(user-defined)
      gnus-article-time-format
      (lambda (time)
        (let* ((date (format-time-string "%a, %d %b %Y %T %z" time))
               (local (article-make-date-line date 'local))
               (combined-lapsed (article-make-date-line date
                                                        'combined-lapsed))
               (lapsed (progn
                         (string-match " (.+" combined-lapsed)
                         (match-string 0 combined-lapsed))))
          (concat local lapsed))))
#+END_SRC

*** Mail renderers, etc
#+BEGIN_SRC emacs-lisp
;; html renderer
(setq mm-text-html-renderer 'shr)
;; Inline images?
(setq mm-attachment-override-types '("image/.*"))
;; No HTML mail
(setq mm-discouraged-alternatives '("text/html" "text/richtext"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-article-map)
  (evil-define-key 'normal gnus-article-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-article-map)
#+END_SRC

** Message mode
Mode for writing mail

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-message-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-message-map)
#+END_SRC

** Misc
*** Random color gnus logo
#+BEGIN_SRC emacs-lisp
(random t) ; Randomize sequence of random numbers
(defun my/random-hex (&optional num)
  (interactive "P")
  (let (($n (if (numberp num) (abs num) 6 )))
    (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n))))))

(setq gnus-logo-colors (list (concat "#" (my/random-hex 6)) (concat "#" (my/random-hex 6))))
#+END_SRC

* System
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-commands-map)
  (define-key my/leader-map (kbd "`") 'my/system-commands-map)
#+END_SRC

** Suspend
  #+BEGIN_SRC emacs-lisp
    (define-prefix-command 'my/system-suspend-map)
    (define-key my/system-commands-map (kbd "s") 'my/system-suspend-map)

    (defun my/systemd-suspend-PC()
      (interactive)
      (shell-command "systemctl suspend"))
    (define-key my/system-suspend-map (kbd "C-s") 'my/systemd-suspend-PC)

    (defun my/systemd-hibernate-PC()
      (interactive)
      (shell-command "systemctl hibernate"))
    (define-key my/system-suspend-map (kbd "C-h") 'my/systemd-hibernate-PC)
#+END_SRC

** Multi-monitor
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-monitor-map)
  (define-key my/system-commands-map (kbd "m") 'my/system-monitor-map)

  (defun my/x-suspend-monitor()
    (interactive)
    (shell-command "xset dpms force suspend"))
  (define-key my/system-monitor-map (kbd "s") 'my/x-suspend-monitor)

  (defun my/print-monitors ()
    (interactive)
    (shell-command "xrandr"))
  (define-key my/system-monitor-map (kbd "p") 'my/print-monitors)

  (defun my/monitor-home-setup ()
    (interactive)
    (shell-command "xrandr --output DP-1 --mode 2560x1440 --rate 60 --left-of DVI-I-1 --output DVI-D-1 --mode 1280x800 --rate 59.81 --left-of DP-1 --output DVI-I-1 --mode 1280x800 --rate 59.81"))
  (define-key my/system-monitor-map (kbd "h") 'my/monitor-home-setup)

  (defun my/auto-connect-screen ()
    (interactive)
    (with-temp-buffer
      (call-process "xrandr" nil t nil)
      (beginning-of-buffer)
      (if (search-forward "VGA1 connected" nil 'noerror)
          (start-process-shell-command
           "xrandr" nil "xrandr --output VGA1 --primary --auto --output LVDS1 --off")
        (start-process-shell-command
         "xrandr" nil "xrandr --output LVDS1 --auto"))))
  (define-key my/system-monitor-map (kbd "a") 'my/auto-connect-screen)
#+END_SRC

** Process monitors
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/processes-map)
  (define-key my/system-commands-map (kbd "p") 'my/processes-map)
#+END_SRC

*** Top - proced
#+BEGIN_SRC emacs-lisp
  (define-key my/processes-map (kbd "t") 'proced)
#+END_SRC

**** Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'proced-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

**** Disable line wrapping
#+BEGIN_SRC emacs-lisp
  (defun my/proced-mode ()
    (interactive)
    (visual-line-mode 0))

  ;;(add-hook 'proced-post-display-hook 'my/proced-mode)
  (add-hook 'proced-mode-hook 'my/proced-mode)
#+END_SRC

*** Profiler
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/profiler-map)
  (define-key my/processes-map (kbd "p") 'my/profiler-map)

  (define-key my/profiler-map (kbd "s") 'profiler-start)
  (define-key my/profiler-map (kbd "e") 'profiler-stop)
  (define-key my/profiler-map (kbd "r") 'profiler-report)
#+END_SRC

* Networking
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/net-utils-map)
  (define-key my/system-commands-map (kbd "n") 'my/net-utils-map)
#+END_SRC

** Tramp
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC

** Netstat
#+BEGIN_SRC emacs-lisp
  (defun my/net-utils-mode ()
    (interactive)
    (visual-line-mode 0))

  (add-hook 'net-utils-mode-hook 'my/net-utils-mode)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/net-utils-map (kbd "s") 'netstat)
  (define-key my/net-utils-map (kbd "p") 'ping)
  (define-key my/net-utils-map (kbd "i") 'ifconfig)
#+END_SRC

* Hardware
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/hardware-info-map)
  (define-key my/system-commands-map (kbd "h") 'my/hardware-info-map)

  ;; Memory
  (defun my/unix-get-memory-available()
    (interactive)
    (shell-command "grep \"MemAvailable\" /proc/meminfo"))
  (define-key my/hardware-info-map (kbd "m") 'my/unix-get-memory-available)

  ;; GPU
  (defun my/unix-get-gpu()
    (interactive)
    (shell-command "lspci | grep ' VGA ' | cut -d\" \" -f 1 | xargs -i lspci -v -s {}"))
  (define-key my/hardware-info-map (kbd "g") 'my/unix-get-gpu)

  ;; Blocked devices
  (defun my/rfkill-get-blocked-devices()
    (interactive)
    (shell-command "rfkill list"))
  (define-key my/hardware-info-map (kbd "b") 'my/rfkill-get-blocked-devices)

  ;; Get devices
  (defun my/rfkill-get-devices()
    (interactive)
    (shell-command "cat /proc/devices"))
  (define-key my/hardware-info-map (kbd "d") 'my/rfkill-get-devices)
#+END_SRC

** CPU
#+BEGIN_SRC emacs-lisp
  ;; Linux temps
  (if (file-exists-p "/proc/cpuinfo") (progn
                                        (define-prefix-command 'my/cpu-info-map)
                                        (define-key my/hardware-info-map (kbd "c") 'my/cpu-info-map)

                                        (defun my/unix-cpu-get-clock()
                                          (interactive)
                                          (shell-command "grep \"cpu MHz\" /proc/cpuinfo"))
                                        ;; Clock speed
                                        (define-key my/cpu-info-map (kbd "f") 'my/unix-cpu-get-clock)
                                        ;; Model name
                                        (defun my/unix-cpu-get-name()
                                          (interactive)
                                          (shell-command "grep \"model name\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "n") 'my/unix-cpu-get-name)
                                        ;; Core count
                                        (defun my/unix-cpu-get-core-count()
                                          (interactive)
                                          (shell-command "grep \"cores\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "c") 'my/unix-cpu-get-core-count)
                                        ;; Flags
                                        (defun my/unix-cpu-get-flags()
                                          (interactive)
                                          (shell-command "grep \"flags\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "F") 'my/unix-cpu-get-flags)
                                        ;; Vendor
                                        (defun my/unix-cpu-get-vendor-id()
                                          (interactive)
                                          (shell-command "grep \"vendor_id\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "v") 'my/unix-cpu-get-vendor-id)
                                        ;; Bugs (Bugs that has affected CPU model)
                                        (defun my/unix-cpu-get-bugs()
                                          (interactive)
                                          (shell-command "grep \"bugs\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "b") 'my/unix-cpu-get-bugs)
                                        ;; Cache size
                                        (defun my/unix-cpu-get-cache-size()
                                          (interactive)
                                          (shell-command "grep \"cache size\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "C") 'my/unix-cpu-get-cache-size))
    ;; Windows
    (if (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
        (let ((number-of-processors (getenv "NUMBER_OF_PROCESSORS")))
          (when number-of-processors
            (string-to-number number-of-processors)))))
#+END_SRC

* Browser
** Webjump
#+BEGIN_SRC emacs-lisp
  (require 'webjump)
  (setq webjump-sites
        (append '(
                  (">" .
                   [simple-query "" "" ""])

                  ("Discord" . "www.discordapp.com/channels/@me")
                  ("Github" . "www.github.com/")
                  ("Steam chat" . "www.steamcommunity.com/chat")

                  ("Reddit Search" .
                   [simple-query "www.reddit.com" "www.reddit.com/search?q=" ""])
                  ("Reddit Sub" .
                   [simple-query "www.reddit.com" "www.reddit.com/r/" ""])
                  ("Wikipedia" .
                   [simple-query "www.wikipedia.org" "www.wikipedia.org/wiki/" ""])
                  ("Emacs Wiki" .
                   [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])

                  ("Youtube" .
                   [simple-query "www.youtube.com" "www.youtube.com/results?search_query=" ""])
                  ("-Startpage search" .
                   [simple-query "www.startpage.com" "www.startpage.com/do/search?q=" ""])
                  ("Startpage Image" .
                   [simple-query "www.startpage.com" "www.startpage.com/do/search?q=" "&nj=0&cat=pics"]))))
#+END_SRC

*** Temporarily switch browser to open webjump result in
#+BEGIN_SRC emacs-lisp
  (defun my/webjump-use-browser (browser)
    (interactive)

    (setq old-browser browse-url-browser-function)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program browser)

    (unwind-protect
        (webjump)
      (setq browse-url-browser-function old-browser)))
#+END_SRC

** Eww
#+BEGIN_SRC emacs-lisp
  (require 'eww)
  (defun my/eww-browse-url (URL &optional NEW-WINDOW)
    (interactive)
    (eww-browse-url URL NEW-WINDOW)
    (my/give-buffer-unique-name "eww"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key eww-mode-map [?\d] 'eww-back-url)
  (evil-define-key 'normal eww-mode-map [?\d] 'eww-back-url)
  (evil-define-key 'visual eww-mode-map [?\d] 'eww-back-url)

  (define-prefix-command 'my/eww-mode-map)
  (evil-define-key 'normal eww-mode-map (kbd (concat my/leader-map-key " a")) 'my/eww-mode-map)

  (define-key my/eww-mode-map (kbd "d") 'eww-download)
  (define-key my/eww-mode-map (kbd "h") 'eww-history-browse)
  (define-key my/eww-mode-map (kbd "o") 'eww-open-in-new-buffer)
  (define-key my/eww-mode-map (kbd "l") 'eww-open-file)
#+END_SRC

** Set default browser
#+BEGIN_SRC emacs-lisp
  ;;  (setq browse-url-browser-function 'browse-url-generic
  ;;        browse-url-generic-program "firefox")
  (setq-default browse-url-browser-function 'my/eww-browse-url)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  ;; Webjump
  (define-key my/leader-map (kbd "W") 'webjump)
  (define-key my/leader-map (kbd "C-w") (lambda () (interactive) (my/webjump-use-browser "firefox")))
#+END_SRC

* Find
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/find-map)
  (define-key my/leader-map (kbd "F") 'my/find-map)

  (define-key my/find-map (kbd "l") 'counsel-locate)

  (define-key my/find-map (kbd "g") 'counsel-ag)
#+END_SRC

* Spelling
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/spell-map)
  (define-key my/leader-map (kbd "C-l") 'my/spell-map)

  (defun my/toggle-company-ispell ()
    (interactive)
    (cond
     ((memq 'company-ispell company-backends)
      (setq company-backends (delete 'company-ispell company-backends))
      (message "company-ispell disabled"))
     (t
      (add-to-list 'company-backends 'company-ispell)
      (message "company-ispell enabled!"))))

  (define-key my/spell-map (kbd "l") 'ispell-change-dictionary)
  (define-key my/spell-map (kbd "s") 'flyspell-mode)
  (define-key my/spell-map (kbd "c") 'my/toggle-company-ispell)
#+END_SRC

* Artist mode
https://www.emacswiki.org/emacs/FacesPerBuffer
#+BEGIN_SRC emacs-lisp
  (defvar my/artist-mode-highlight-thing-restore nil)
  (defvar my/artist-mode-aggressive-indent-restore nil)
  (defvar my/artist-mode-highlight-indent-restore nil)

  (defun my/artist-mode ()
    (if (eq major-mode 'picture-mode)
        (progn
          (if highlight-thing-mode
              (progn
                (highlight-thing-mode -1)
                (setq my/artist-mode-highlight-thing-restore t))
            (setq my/artist-mode-highlight-thing-restore nil))

          (if aggressive-indent-mode
              (progn
                (aggressive-indent-mode -1)
                (setq my/artist-mode-aggressive-indent-restore t))
            (setq my/artist-mode-aggressive-indent-restore nil))

          (if highlight-indent-guides-mode
              (progn
                (highlight-indent-guides-mode -1)
                (setq my/artist-mode-highlight-indent-restore t))
            (setq my/artist-mode-highlight-indent-restore nil))

          (evil-emacs-state)

          (if (not my/is-font-mono)
              (set-face-attribute 'default nil
                                  :family my/mono-font)))

      ;; Turn everything back on
      (if my/artist-mode-highlight-thing-restore
          (progn
            (setq my/artist-mode-highlight-thing-restore nil)
            (highlight-thing-mode 1)))

      (if my/artist-mode-aggressive-indent-restore
          (progn
            (setq my/artist-mode-aggressive-indent-restore nil)
            (aggressive-indent-mode 1)))

      (if my/artist-mode-highlight-indent-restore
          (progn
            (setq my/artist-mode-highlight-indent-restore nil)
            (highlight-indent-guides-mode 1)))

      (evil-exit-emacs-state)
      (if (not my/is-font-mono)
          (set-face-attribute 'default nil
                              :family my/font))))

  (add-hook 'artist-mode-hook 'my/artist-mode)
#+END_SRC

** Completing read
https://www.emacswiki.org/emacs/ArtistMode
#+BEGIN_SRC emacs-lisp
  (defun my/artist-select-operation (type)
    "Use ido to select a drawing operation in artist-mode"
    (interactive (list (completing-read "Drawing operation: " 
                                        (list "Pen" "Pen Line" "line" "straight line" "rectangle" 
                                              "square" "poly-line" "straight poly-line" "ellipse" 
                                              "circle" "text see-thru" "text-overwrite" "spray-can" 
                                              "erase char" "erase rectangle" "vaporize line" "vaporize lines" 
                                              "cut rectangle" "cut square" "copy rectangle" "copy square" 
                                              "paste" "flood-fill"))))
    (artist-select-operation type))

  (defun my/artist-select-settings (type)
    "Use ido to select a setting to change in artist-mode"
    (interactive (list (completing-read "Setting: " 
                                        (list "Set Fill" "Set Line" "Set Erase" "Spray-size" "Spray-chars" 
                                              "Rubber-banding" "Trimming" "Borders"))))
    (if (equal type "Spray-size") 
        (artist-select-operation "spray set size")
      (call-interactively (artist-fc-get-fn-from-symbol 
                           (cdr (assoc type '(("Set Fill" . set-fill)
                                              ("Set Line" . set-line)
                                              ("Set Erase" . set-erase)
                                              ("Rubber-banding" . rubber-band)
                                              ("Trimming" . trimming)
                                              ("Borders" . borders)
                                              ("Spray-chars" . spray-chars))))))))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "A") 'artist-mode)

  (define-prefix-command 'my/artist-mode-map)
  (evil-define-key 'normal artist-mode-map (kbd (concat my/leader-map-key " a")) 'my/artist-mode-map)

  (define-key my/artist-mode-map (kbd "o") 'my/artist-select-operation)
  (define-key my/artist-mode-map (kbd "s") 'my/artist-select-settings)
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra)

  ;; Hydra lv generates a lot of garbage, disable it
  (setq hydra-lv nil)
#+END_SRC

** Window and buffer management
#+BEGIN_SRC emacs-lisp
  (defhydra my/window-hydra (:hint nil
                                   :color red
                                   :pre (setq exwm-input-line-mode-passthrough t)
                                   :post (setq exwm-input-line-mode-passthrough nil))
    "movement" 

    ;; Move focus
    ("p" my/evil-window-up nil)
    ("n" my/evil-window-down nil)
    ("l" my/evil-window-right nil)
    ("h" my/evil-window-left nil)

    ;; Move focus to edge window
    ;; Frame border window
    ("|" evil-window-mru nil)

    ;; Move window
    ;; Move up
    ("P" evil-move-very-top nil)
    ;; Move down
    ("N" evil-move-very-bottom nil)
    ;; Move right
    ("L" evil-move-far-right nil)
    ;; Move left
    ("H" evil-move-far-left nil)

    ;; Switch monitor right
    ("M-l" my/switch-monitor-right nil)
    ;; Switch monitor left
    ("M-h" my/switch-monitor-left nil)

    ;; Resize window
    ;; Resize up
    ("C-p" (evil-window-increase-height 10) nil)
    ;; Resize down
    ("C-n" (evil-window-decrease-height 10) nil)
    ;; Resize right
    ("C-l" (evil-window-decrease-width 10) nil)
    ;; Resize left
    ("C-h" (evil-window-increase-width 10) nil)

    ;; Split
    ("o" split-window-horizontally nil)
    ("v" split-window-vertically nil)

    ;; Close window
    ("s" my/delete-window nil)
    ;; Focus on window
    ("d" my/delete-other-windows nil)

    ;; minimize window
    ("S" (lambda () (interactive) (evil-window-increase-height 1000) (evil-window-increase-width 1000)) nil)
    ;; maximize window
    ("D" (lambda () (interactive) (evil-window-decrease-height 1000) (evil-window-decrease-width 1000)) nil)

    ;; Buffer management
    ;; Find file
    ("e" counsel-find-file nil)

    ;; Switch buffer
    ("A" next-buffer nil)
    ("C-a" previous-buffer nil)

    ;; Switch buffer
    ("a" ivy-switch-buffer nil)
    ;; Kill buffer
    ("k" kill-current-buffer nil)

    ;; Move around in buffer
    ("C-u" View-scroll-half-page-backward nil)
    ("C-w" View-scroll-half-page-forward nil)

    ("f" counsel-M-x nil)
    ("y" counsel-linux-app nil)

    ("u" revert-buffer nil)

    ;; Switch window configuration
    ("t" my/load-window-config nil)
    ("T" my/add-window-config nil)
    ("C-t" my/delete-window-config nil)

    ("b" counsel-bookmark nil)
    ("B" my/add-bookmark nil)
    ("C-b" my/delete-bookmark nil)

    ;;  ("SPC" my/leader-map nil)

    ;; Add this to not auto exit insert mode after closing the hydra
    ;;("<escape>" nil)
    )
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'motion my/keys-mode-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (evil-define-key 'normal my/keys-mode-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (evil-define-key 'insert my/keys-mode-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (define-key my/keys-mode-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (define-key my/keys-mode-map (kbd my/mod-window-leader-key) 'my/window-hydra/body)

  (define-key evil-motion-state-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (define-key evil-normal-state-map (kbd my/window-leader-key) 'my/window-hydra/body)
  (define-key evil-insert-state-map (kbd my/window-leader-key) 'my/window-hydra/body)
#+END_SRC

* Image modes
** PDF tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools)
  (pdf-tools-install-noverify)

  ;; Enable pdf-links
  (add-hook 'pdf-view-mode-hook 'pdf-links-minor-mode)

  ;; Remove default keys
  (setq pdf-view-mode-map (make-sparse-keymap))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; Scroll half page
  (define-key pdf-view-mode-map [remap View-scroll-half-page-backward] 'pdf-view-scroll-down-or-previous-page)
  (define-key pdf-view-mode-map [remap View-scroll-half-page-forward] 'pdf-view-scroll-up-or-next-page)
  ;; goto
  (define-key pdf-view-mode-map [remap evil-goto-first-line] 'pdf-view-first-page)
  ;; (kbd "G") = (evil-goto-line LAST-LINE)
  (define-key pdf-view-mode-map [remap evil-goto-line] 'pdf-view-last-page)
  ;; search
  (define-key pdf-view-mode-map [remap counsel-grep-or-swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap counsel-grep] 'isearch-forward)

  ;; Movement
  (define-key pdf-view-mode-map [remap evil-next-line] '(lambda () (interactive) (image-next-line 8)))
  (define-key pdf-view-mode-map [remap evil-previous-line] '(lambda () (interactive) (image-previous-line 8)))

  (define-key pdf-view-mode-map [remap evil-forward-char] '(lambda () (interactive) (image-forward-hscroll 8)))
  (define-key pdf-view-mode-map [remap evil-backward-char] '(lambda () (interactive) (image-backward-hscroll 8)))

  ;; Disable other modes
  (evil-define-key 'normal pdf-view-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "v") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "R") 'nil)

  ;; Zoom
  (evil-define-key 'normal pdf-view-mode-map (kbd "-") 'pdf-view-shrink)
  (evil-define-key 'normal pdf-view-mode-map (kbd "=") 'pdf-view-enlarge)
  (evil-define-key 'normal pdf-view-mode-map (kbd "_") 'pdf-view-scale-reset)
  (evil-define-key 'normal pdf-view-mode-map (kbd "+") 'pdf-view-scale-reset)

  ;; Add to leader map
  (define-prefix-command 'my/pdf-view-mode-map)
  (evil-define-key 'normal pdf-view-mode-map (kbd (concat my/leader-map-key " a")) 'my/pdf-view-mode-map)

  (define-key my/pdf-view-mode-map (kbd "o") 'pdf-occur)
  (define-key my/pdf-view-mode-map (kbd "t") 'doc-view-open-text)
  (define-key my/pdf-view-mode-map (kbd "n") 'pdf-view-midnight-minor-mode)
  (define-key my/pdf-view-mode-map (kbd "g") 'pdf-view-goto-label)
  (define-key my/pdf-view-mode-map (kbd "i") 'pdf-view-extract-region-image)
#+END_SRC

** Image mode
#+BEGIN_SRC emacs-lisp
  (require 'image-mode)

  (evil-define-key 'normal image-mode-map (kbd "-") 'image-decrease-size)
  (evil-define-key 'normal image-mode-map (kbd "=") 'image-increase-size)
  (evil-define-key 'normal image-mode-map (kbd "_") 'image-transform-fit-to-height)
  (evil-define-key 'normal image-mode-map (kbd "+") 'image-transform-fit-to-width)

  (evil-define-key 'normal image-mode-map (kbd "C-u") 'image-scroll-down)
  (evil-define-key 'normal image-mode-map (kbd "C-w") 'image-scroll-up)

  (evil-define-key 'normal image-mode-map (kbd "n") '(lambda () (interactive) (image-next-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "p") '(lambda () (interactive) (image-previous-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "h") '(lambda () (interactive) (image-backward-hscroll 8)))
  (evil-define-key 'normal image-mode-map (kbd "l") '(lambda () (interactive) (image-forward-hscroll 8)))
#+END_SRC

* Visuals
** Indicate empty lines
#+BEGIN_SRC emacs-lisp
  (setq-default indicate-empty-lines t)
#+END_SRC

** Fringe size
Used by diff-hl and flycheck
Fringe only on the left side
#+BEGIN_SRC emacs-lisp
  (fringe-mode '(6 . 0))
#+END_SRC

** Beacon
#+BEGIN_SRC emacs-lisp
  ;; (use-package beacon)
;; 
  ;; (beacon-mode 1)
#+END_SRC
  
** Rainbow
Changes background of eg. #FF00FF to represent color
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode)

  (define-key my/help-map (kbd "c") 'rainbow-mode)
#+END_SRC

** Rainbow delimiters
Changes colors of delimiters eg. {()}
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters)

  (define-key my/help-map (kbd "d") 'rainbow-delimiters-mode)
  ;;(add-hook 'prog-mode 'rainbow-delimiters-mode)
#+END_SRC

** Minimap
#+BEGIN_SRC emacs-lisp
  (use-package minimap)

  (define-key my/leader-map (kbd "]") 'my/toggle-window-config-minimap)

  (setq minimap-window-location 'right)
#+END_SRC

*** Toggle minimap by window config
#+BEGIN_SRC emacs-lisp
  (defvar my/minimap-exists nil)

  (defun my/kill-minimap()
    (if my/minimap-exists
        (progn
          (minimap-kill)
          (setf my/minimap-exists nil))))

  (defun my/start-minimap()
    (if (not my/minimap-exists)
        (progn
          (minimap-create)
          (setf my/minimap-exists t))))

  (defvar my/window-configs-with-minimap (list))

  (defun my/has-current-window-config-minimap ()
    (cl-position my/current-window-configuration my/window-configs-with-minimap :test 'string=))

  (defun my/toggle-window-config-minimap()
    (interactive)
    (if (my/has-current-window-config-minimap)
        (setq my/window-configs-with-minimap (delete my/current-window-configuration my/window-configs-with-minimap))
      (push my/current-window-configuration my/window-configs-with-minimap))
    (my/window-config-minimap-refresh))

  (defun my/window-config-minimap-refresh()
    (if (my/has-current-window-config-minimap)
        (my/start-minimap)
      (my/kill-minimap)))
  (setq my/window-configs-with-minimap nil)

  (add-hook 'my/window-config-name-changed-hook 'my/window-config-minimap-refresh t)
#+END_SRC

** Highlight matching delimiters
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

** Highlight current line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

** Pretty mode (converts text into symbols)
Only enable when using GUI. Transforms ASCII to symbols depending on mode
#+BEGIN_SRC emacs-lisp
  ;; TODO Global pretty mode is buggy when using swiper, generates tons of garbage, normal pretty-mode works
  ;; When the function (global-pretty-mode t) is run, it generates a TON of garbage since it searches the newly created swiper buffer
  ;; Look at turn-on-pretty-if-desired
  ;; (when window-system
  ;; (use-package pretty-mode)
  ;; (global-pretty-mode t))
#+END_SRC

** Highlight thing
Highlight thing under cursor and all other occurrences
#+BEGIN_SRC emacs-lisp
  (use-package highlight-thing)

  ;; Don't highlight the word true or false
  ;;(setq highlight-thing-ignore-list '("False" "True"))

  ;; Don't highlight thing under cursor, only matches
  (setq highlight-thing-exclude-thing-under-point 1)

  (setq highlight-thing-case-sensitive-p 1) 
  (global-highlight-thing-mode)
#+END_SRC

** Disable blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** Disable GUI
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** Auto dim inactive buffers
#+BEGIN_SRC emacs-lisp
  (defun my/highlight-selected-window ()
    "Highlight selected window with a different background color."
    (walk-windows (lambda (w)
                    (unless (eq w (selected-window))
                      (with-current-buffer (window-buffer w)
                        (buffer-face-set '(:background "#111"))))))
    (buffer-face-set 'default))

  ;; (add-hook 'buffer-list-update-hook 'my/highlight-selected-window)
#+END_SRC

** Modeline
Make mode line appear in echo area instead of in the mode line area. This saves space and makes it so that the mode line can't be split
#+BEGIN_SRC emacs-lisp
  ;; Disable normal mode line
  (setq mode-line-format nil)
  (setq-default mode-line-format nil)
#+END_SRC

*** Minibuffer-line
#+BEGIN_SRC emacs-lisp
  ;; From minibuffer-line package
  (defconst minibuffer-line--buffer " *Minibuf-0*")
  (defvar minibuffer-line-format "")

  (defface minibuffer-line
    '((t :inherit mode-line-inactive))
    "Face to use for the minibuffer-line.")
    
  (defun my/minibuffer-line-mode ()
    (visual-line-mode 0))

  ;; Disable visual line mode in minibuffer
  (add-hook 'minibuffer-inactive-mode-hook 'my/minibuffer-line-mode)

    
  ;; This works by overwriting whatever is at minibuf-0. minibuf-0 is always displayed in echo buffer
  (defun minibuffer-line--update ()
    (with-current-buffer minibuffer-line--buffer
      (erase-buffer)
      (insert (format-mode-line minibuffer-line-format 'minibuffer-line))))
#+END_SRC

*** LV-line (top modeline)
Use lv-line to create a mode line on the top of the screen
#+BEGIN_SRC emacs-lisp
  (defvar lv-line-format "")
  (defconst lv-line--buffer " *LV-line*")


  ;; (lv-delete-window)
  ;; (lv
  ;; (lv-line-create)
  ;; (setq testBuffer (get-buffer-create "testBuffer"))
  ;; (bufferp testBuffer)
#+END_SRC

**** LV-line update
#+BEGIN_SRC emacs-lisp
  (defun lv-line--update ()
    (if (get-buffer lv-line--buffer)
        (with-current-buffer lv-line--buffer
          (erase-buffer)
          (insert (format-mode-line lv-line-format 'mode-line)))
      (lv-line-create)))
#+END_SRC

**** Create LV-line at top
#+BEGIN_SRC emacs-lisp
  (defun lv-line-create-buffer ()
    (let* ((buf (get-buffer lv-line--buffer)))
      (if buf
          (progn
            (message "Buffer already exists")
            (kill-buffer lv-line--buffer)))
      (switch-to-buffer lv-line--buffer)
      (set-window-hscroll lv-wnd 0)
      (setq window-size-fixed t)
      (setq mode-line-format nil)
      (setq cursor-type nil)
      (set-window-dedicated-p lv-wnd t)
      (set-window-parameter lv-wnd 'no-other-window t)))

    (defun lv-line-create ()
      "Ensure that LV window is live and return it."
      (if (window-live-p lv-wnd)
          lv-wnd
        (let ((ori (selected-window))
              buf)
          (prog1 (setq lv-wnd
                       (select-window
                        (let ((ignore-window-parameters t))
                          (split-window
                           ;; This is the only modification, changed 'below to 'above
                           (frame-root-window) -1 'above))))
            (lv-line-create-buffer)
            (select-window ori)))))
    ;; (lv-delete-window)
    ;; (lv-line-create)
    ;; (lv-line-create-buffer)

    ;;ignore-window-parameters
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/mode-line-map)
  (define-key my/leader-map (kbd "M-m") 'my/mode-line-map)
#+END_SRC

**** Garbage Collection
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-show-GC-stats nil)
  (defun my/mode-line-toggle-show-GC-stats ()
    (interactive)
    (setq my/mode-line-show-GC-stats (not my/mode-line-show-GC-stats)))

  (define-key my/mode-line-map (kbd "G") 'my/mode-line-toggle-show-GC-stats)
#+END_SRC

*** Mode line modules
**** Buffer name
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-name "")
  (defvar my/max-buffer-name-length 10)

  (defun my/update-max-buffer-name-length()
    (interactive)
    (setq my/max-buffer-name-length (floor (/ (frame-width) 10))))

  (defun my/update-buffer-name-string (BUFFER)
    (interactive)
    (setq my/buffer-name
          (if (> (string-width BUFFER) my/max-buffer-name-length)
              (concat (string-trim-right (substring BUFFER 0 my/max-buffer-name-length)) "...")
            BUFFER)))

  (if window-system
      ;; At this point in the code, exwm hasn't had time to maximize the emacs frame
      (add-hook 'exwm-init-hook 'my/update-max-buffer-name-length)
    ;; If on terminal, just run it now since it's always maximized
    (my/update-max-buffer-name-length))

  (add-hook 'window-configuration-change-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t))
#+END_SRC

**** CPU heat
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-cpu-temp t)

  (if (and
       ;; If lm_sensors is not installed
       (my/run-and-is-external-package-installed "sensors")
       ;; If there aren't any cpu heat sensors (eg. virtual machine)
       (= 0 (string-match-p ""
                            (shell-command-to-string "sensors | grep \"Core 0:\""))))
      (setq my/mode-line-enable-cpu-temp nil))

  (defvar my/cpu-temp "")

  (defun my/update-cpu-temp ()
    (interactive)
    ;;(if my/mode-line-enable-cpu-temp))

    ;; FIXME emacs regexes are wierd, use position of temp in print insead
    (string-match "\+.*C\s" (shell-command-to-string "sensors | grep \"Core 0:\""))
    (setq my/cpu-temp (substring (match-string 0 (shell-command-to-string "sensors | grep \"Core 0:\"")) 0 -3)))

  (if my/mode-line-enable-cpu-temp
      (run-with-timer 0 60 'my/update-cpu-temp))
#+END_SRC

**** Disk space
#+BEGIN_SRC emacs-lisp
  (defvar my/disk-space nil)
  (defun my/update-disk-space ()
    (interactive)
    (setq my/disk-space (my/file-size-human-readable (floor (* 1000 (string-to-number (get-free-disk-space user-emacs-directory)))))))
#+END_SRC

**** Network traffic
***** Linux
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-network-traffic nil)

  (if (file-exists-p "/proc/net/dev")
      (setq my/mode-line-enable-network-traffic t))
#+END_SRC

****** RX
Received
#+BEGIN_SRC emacs-lisp
  (defvar my/rx 0)
  (defvar my/rx-delta-formatted "0")

  (defun my/linux-get-network-rx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((rx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (setq rx (+ rx (read (current-buffer)))))) rx)))

  (defun my/linux-update-network-rx-delta ()
    (interactive)
    (setq my/rx-new (my/linux-get-network-rx))
    (setq my/rx-delta-formatted (my/file-size-human-readable (- my/rx-new my/rx)))
    (setq my/rx my/rx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 1 60 'my/linux-update-network-rx-delta))

  (my/linux-update-network-rx-delta)
#+END_SRC

****** TX
Transmitted
#+BEGIN_SRC emacs-lisp
  (setq my/tx 0)
  (defvar my/tx-delta-formatted "0")

  (defun my/linux-get-network-tx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((tx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (forward-word 8)
            (setq tx (+ tx (read (current-buffer)))))) tx)))

  (defun my/linux-update-network-tx-delta ()
    (interactive)
    (setq my/tx-new (my/linux-get-network-tx))
    (setq my/tx-delta-formatted  (my/file-size-human-readable (- my/tx-new my/tx)))
    (setq my/tx my/tx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 2 60 'my/linux-update-network-tx-delta))

  (my/linux-update-network-tx-delta)
#+END_SRC

**** Display total line numbers
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-total-lines nil)

   (defun my/update-total-lines ()
      (save-excursion
        (setq my/buffer-total-lines (format-mode-line "%l" (goto-char (point-max))))))

   (add-hook 'my/switch-buffer-hook 'my/update-total-lines)
  (add-hook 'before-save-hook 'my/update-total-lines)
#+END_SRC

**** Mail
#+BEGIN_SRC emacs-lisp
  ;;  (display-time-use-mail-icon 1)
  ;;  (setq display-time-mail-directory t)
#+END_SRC

**** Battery
If there is a battery, display it in the mode line
#+BEGIN_SRC emacs-lisp
  (require 'battery)

  (display-battery-mode 1)
  (setq battery-mode-line-format "%th - %p")
#+END_SRC

**** Date and time
Display time and date in good format (also displays CPU load)
#+BEGIN_SRC emacs-lisp
  (defvar my/date "")
  (defvar my/time "")

  (defun my/update-date ()
    (interactive)
    (setq my/date (format-time-string "%d-%m-%Y")))

  (defun my/update-time ()
    (interactive)
    (setq my/time (format-time-string "%H:%M")))

  (run-with-timer 3 60 'my/update-time)
  (run-with-timer 0 3600 'my/update-date)

  ;; Update date now
  (my/update-time)
  (my/update-date)
#+END_SRC

**** Git branch name
#+BEGIN_SRC emacs-lisp
  (require 'vc-git)

  (defvar my/buffer-git-branch "")

  (defun my/update-buffer-git-branch ()
    (interactive)
    (setq my/buffer-git-branch (car (vc-git-branches))))

  (add-hook 'my/switch-buffer-hook 'my/update-buffer-git-branch)
#+END_SRC

**** Git project name
When projectile-mode is on, project name is updated on every keypress, here it is fixed
#+BEGIN_SRC emacs-lisp
  (defvar my/projectile-project-name "")

  (defun my/update-projectile-project-name()
    (interactive)
    (setq my/projectile-project-name (projectile-project-name)))

  (add-hook 'my/switch-buffer-hook 'my/update-projectile-project-name)
#+END_SRC

**** Load average
#+BEGIN_SRC emacs-lisp
  (defvar my/load-average 0)
  (defvar my/high-load-average 2)

  (defun my/update-load-average ()
    (interactive)
    (setq my/load-average (/ (nth 0 (load-average)) 100.0)))

  (run-with-timer 4 60 'my/update-load-average)

  (my/update-load-average)
#+END_SRC

**** Ram usage
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-available-mem nil)

  (if (file-exists-p "/proc/meminfo")
      (setq my/mode-line-enable-available-mem t))

  (defvar my/available-mem-formatted "nil")

  (defun my/linux-update-available-mem ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents "/proc/meminfo")
      (setq my/mem-string (buffer-string))

      (string-match "MemAvailable:.*\s" my/mem-string)
      (setq my/mem-string (match-string 0 my/mem-string))

      (let* (( my/available-mem (string-to-number (substring my/mem-string (string-match "[0-9]" my/mem-string) -1))))
        (setq my/available-mem-formatted (my/file-size-human-readable (* 1000 my/available-mem) nil t)))))

  (if my/mode-line-enable-available-mem
      (run-with-timer 5 60 'my/linux-update-available-mem))

  ;; Update available mem on startup
  (my/linux-update-available-mem)
#+END_SRC

**** Work timer
#+BEGIN_SRC emacs-lisp
  (defvar my/work-timer-last-add-to-total-time nil)
  (defvar my/work-timer-total-time 0)
  (defvar my/work-timer-total-time-formated "0M")

  (defvar my/work-log-name "work-log")

  (defun my/start-work-timer ()
    (interactive)
    (setq my/work-timer-last-add-to-total-time (float-time)))

  (defun my/stop-work-timer ()
    (interactive)
    (setq my/work-timer-last-add-to-total-time nil))

  (defun my/work-timer-task-done ()
    (interactive)
    (with-current-buffer (find-file (expand-file-name (concat user-emacs-directory my/work-log-name)))
      (end-of-buffer)
      (newline)
      (insert  (concat my/date " - " my/time ": "my/work-timer-total-time-formated " - " (completing-read "Work done: " nil))))
    (setq my/work-timer-last-add-to-total-time nil)
    (setq my/work-timer-total-time 0)
    (setq my/work-timer-total-time-formated "0M"))

  (defun my/work-timer-get-formated-time ()
    (interactive)
    (if (> my/work-timer-total-time (* 60 60))
        (concat (format "%0.1f"(/ my/work-timer-total-time 3600.0)) "H")
      (concat (int-to-string (/ (floor my/work-timer-total-time) 60)) "M")))

  (defun my/update-work-timer ()
    (interactive)
    (if my/work-timer-last-add-to-total-time
        (progn
          (setq my/work-timer-total-time (+ my/work-timer-total-time (- (float-time) my/work-timer-last-add-to-total-time)))
          (setq my/work-timer-last-add-to-total-time (float-time))
          (setq my/work-timer-total-time-formated (my/work-timer-get-formated-time)))))

  (run-with-timer 0 60 'my/update-work-timer)
#+END_SRC

***** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/work-timer-map)
  (define-key my/leader-map (kbd "b") 'my/work-timer-map)

  (define-key my/work-timer-map (kbd "s") 'my/start-work-timer)
  (define-key my/work-timer-map (kbd "e") 'my/stop-work-timer)
  (define-key my/work-timer-map (kbd "d") 'my/work-timer-task-done)
#+END_SRC

**** Uptime
#+BEGIN_SRC emacs-lisp
  (defvar my/uptime-start-time (float-time))
  (defvar my/uptime-total-time-formated "0M")

  (defun my/get-uptime-formated-time ()
    (let* ((total-time  (- (float-time) my/uptime-start-time)))
      (if (> total-time (* 60 60))
          (concat (format "%0.1f"(/ total-time 3600.0)) "H")
        (concat (int-to-string (/ (floor total-time) 60)) "M"))))

  (defun my/update-uptime-timer ()
    (interactive)
    (setq my/uptime-total-time-formated (my/get-uptime-formated-time)))

  (run-with-timer 0 60 'my/update-uptime-timer)
#+END_SRC

**** Eye timer
#+BEGIN_SRC emacs-lisp
  (defvar my/eye-timer-last-break (float-time))

  (defvar my/eye-timer-que 0)
  (defvar my/eye-timer-que-formated "")
  ;; In seconds
  (defvar my/eye-timer-break-every (* 21 60))

  (defun my/reset-eye-timer ()
    (interactive)
    (setq my/eye-timer-que 0)
    (setq my/eye-timer-que-formated (my/eye-timer-get-formated-time)))

  (defun my/eye-timer-get-formated-time ()
    (setq my/eye-timer-que-formated (number-to-string my/eye-timer-que)))

  (defun my/update-eye-timer ()
    (interactive)
    (if (> (- (float-time) my/eye-timer-last-break) my/eye-timer-break-every)
        (progn
          (setq my/eye-timer-que (+ 1 my/eye-timer-que))
          (setq my/eye-timer-que-formated (my/eye-timer-get-formated-time))
          (setq my/eye-timer-last-break (float-time)))))

  (run-with-timer 0 60 'my/update-eye-timer)
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/timer-map)
  (define-key my/leader-map (kbd "b") 'my/timer-map)

  (define-key my/timer-map (kbd "s") 'my/start-work-timer)
  (define-key my/timer-map (kbd "e") 'my/stop-work-timer)

  (define-key my/timer-map (kbd "r") 'my/reset-eye-timer)
#+END_SRC

*** Mode line format
#+BEGIN_SRC emacs-lisp
  ;; (defvar my/frame-width (frame-width))
  ;; 
  ;; (defun my/frame-width-update()
  ;; (setq my/frame-width (frame-width)))
  ;; 
  ;; (add-hook 'exwm-workspace-switch-hook 'my/frame-width-update)
  ;; (add-hook 'exwm-init-hook 'my/frame-width-update)
  ;; 
  ;; (defun my/mode-line-align (left right)
  ;; "Return a string of `window-width' length containing LEFT, and RIGHT aligned respectively."
  ;; (let* ((available-width (- my/frame-width (length left) 2)))
  ;; (format (format "%%s %%%ds" available-width) left right)))

  ;;mode-line-format
  (setq-default minibuffer-line-format 
                (quote
                 (
                  ;; Print error if any
                  "%e"

                  ;; Print if recursive editing
                  "%["

                  ;; Information bar
                  mode-line-mule-info
                  mode-line-client

                  ;; If buffer is modified
                  mode-line-modified

                  ;; Turns into @ when remote
                  mode-line-remote

                  " "

                  ;; Print current line number
                  ;;"%l"
                  ;;"%p"
                  (:eval (format "%d" (/ (window-start) 0.01 (point-max))))

                  "~"
                  ;;"@" 
                  ;; Print total line number
                  (:eval my/buffer-total-lines)
                  ;;"%I"

                  ;; is narrowed
                  "%n"

                  " | "

                  ;; Print mode
                  "%m > " 
                  ;; Print buffer name

                  ;;(:eval (buffer-name))

                  (:eval my/buffer-name)

                  ;;"%b"

                  ;; Git branch and project name
                  (:eval (if (not (string= my/projectile-project-name "-"))
                             (progn
                               (concat
                                " > " 
                                my/buffer-git-branch
                                "@"
                                "["
                                my/projectile-project-name
                                "]"))))

                  (:eval (if memory-full
                             "GC FULL! JUMP SHIP!")))))

  (setq-default lv-line-format
                (quote
                 (
                  (:eval my/date)

                  " - "

                  (:eval my/time)

                  " | "

                  (:eval (concat "Up: " my/uptime-total-time-formated))
                  (:eval (if (not (= my/eye-timer-que 0))
                             (propertize (concat " - E: " my/eye-timer-que-formated) 'face '(:foreground "red"))))


                  " | "

                  "W: "
                  (:eval (if my/work-timer-last-add-to-total-time
                             ;;(propertize my/work-timer-total-time-formated 'face '(:foreground "green"))
                             my/work-timer-total-time-formated
                           (propertize my/work-timer-total-time-formated 'face '(:foreground "red"))))

                  " | "

                  "C: "
                  (:eval (number-to-string my/load-average))
                  (:eval (if my/mode-line-enable-cpu-temp
                             (concat " - " my/cpu-temp)))
                  " | "

                  (:eval (if (not (eq battery-mode-line-string ""))
                             (concat "BAT: " battery-mode-line-string "%%%  | ")))


                  ;;(:eval (concat "Org:" org-mode-line-string))
                  (:eval (if (boundp 'org-mode-line-string)
                             (concat "Org:" org-mode-line-string " | ")))

                  (:eval (if my/mode-line-enable-available-mem
                             (concat "MEM: "
                                     my/available-mem-formatted
                                     " | ")))

                  (:eval (if my/mode-line-enable-network-traffic
                             (concat
                              my/rx-delta-formatted " rx "
                              my/tx-delta-formatted " tx | ")))

                  (:eval (if my/mode-line-show-GC-stats
                             (concat
                              "GC: " (number-to-string (truncate gc-elapsed))
                              "(" (number-to-string gcs-done) ")"
                              " | "
                              )))
                  )))
#+END_SRC

*** Keep mode line updated
t as last parameter because the mode line should always be updated last, after any changes to its components (such as projectile project name, vc mode, etc)
#+BEGIN_SRC emacs-lisp
  (add-hook 'post-command-hook 'minibuffer-line--update t)
  (add-hook 'my/switch-buffer-hook 'minibuffer-line--update t)

  (add-hook 'exwm-init-hook (lambda () (interactive)
                              (lv-line-create)
                              (lv-line--update)
                              (run-with-timer 6 60 'lv-line--update)))
                              ;; (add-hook 'post-command-hook 'lv-line--update t)
                              ;; (add-hook 'my/switch-buffer-hook 'lv-line--update t)


  ;; (lv-line-create)
  ;; (add-hook 'post-command-hook 'lv-line--update t)
  ;; (add-hook 'my/switch-buffer-hook 'lv-line--update t)
  ;; 
  ;; (add-hook 'exwm-init-hook (lambda () (interactive) (run-with-timer 1 nil (lambda () (interactive)
  ;; (lv-line-create)
  ;; (add-hook 'post-command-hook 'lv-line--update t)
  ;; (add-hook 'my/switch-buffer-hook 'lv-line--update t)))))

  ;;(setq minibuffer-line-refresh-interval 1)
#+END_SRC

*** Visuals
Set mode line font
#+BEGIN_SRC emacs-lisp
  ;; (set-face-attribute 'minibuffer-line nil
                      ;; :background "#000000"
                      ;; :family my/mono-font))
#+END_SRC

**** Modeline colering
#+BEGIN_SRC emacs-lisp
  ;; (defvar my/mode-line-background (face-attribute 'default :background))
  ;; (defvar my/mode-line-foreground (face-attribute 'default :foreground))
  ;; First in list is for GUI, second for CLI
  (defvar my/mode-line-background (list "#2a1f1f" "#FFFFFF"))
  (defvar my/mode-line-foreground (list "#d15120" "#000000"))

  (defvar my/mode-line-work-timer-off-background (list "#272122" "#FFFFFF"))
  (defvar my/mode-line-work-timer-off-foreground (list "#d97a35" "#000000"))

  (defvar my/mode-line-warning-background (list "#555500" "#555500"))
  (defvar my/mode-line-warning-foreground (list "#D3D3D3" "#000000"))

  (defvar my/mode-line-caution-background (list "#330000" "#330000"))
  (defvar my/mode-line-caution-foreground (list "#D3D3D3" "#000000"))

  ;;(deftype my/mode-line-alert-states () '(member normal warning caution))

  (defvar my/mode-line-alert-status nil)

  (defun my/set-mode-line-color (foreground background)
    (if window-system
        (progn
          (set-face-background 'minibuffer-line (nth 0 background))
          (set-face-foreground 'minibuffer-line (nth 0 foreground)))
      (set-face-background 'minibuffer-line (nth 1 background))
      (set-face-foreground 'minibuffer-line (nth 1 foreground))))

  ;; (set-face-background 'mode-line nil)
  ;; (set-face-foreground 'mode-line nil)

  ;; (my/set-mode-line-color nil nil)

   (defun my/set-mode-line-normal ()
     (interactive)
     (if (not (eq my/mode-line-alert-status 'normal))
         (progn
           (setq my/mode-line-alert-status 'normal)
           (my/set-mode-line-color my/mode-line-foreground my/mode-line-background))))

  (defun my/set-mode-line-work-off ()
    (interactive)
    (if (not (eq my/mode-line-alert-status 'work-off))
        (progn
          (setq my/mode-line-alert-status 'work-off)
          (my/set-mode-line-color my/mode-line-work-timer-off-foreground my/mode-line-work-timer-off-background))))


  (defun my/set-mode-line-warning ()
    (interactive)
    (if (not (eq my/mode-line-alert-status 'warning))
        (progn
          (setq my/mode-line-alert-status 'warning)
          (my/set-mode-line-color my/mode-line-warning-foreground my/mode-line-warning-background))))

  (defun my/set-mode-line-caution ()
    (interactive)
    (if (not (eq my/mode-line-alert-status 'caution))
        (progn
          (setq my/mode-line-alert-status 'caution)
          (my/set-mode-line-color my/mode-line-caution-foreground my/mode-line-caution-background))))

  (my/set-mode-line-normal)

  ;; Disable border
  (set-face-attribute 'mode-line-highlight nil :box nil)
  (set-face-attribute 'mode-line-inactive nil :box nil)

  ;; Some themes make the text weight of inactive mode lines light
  (set-face-attribute 'mode-line-inactive nil :weight 'medium)
#+END_SRC

***** Update mode line color
#+BEGIN_SRC emacs-lisp
  (defun my/update-mode-line-color ()
    ;; Battery
    (if (and (not (eq battery-mode-line-string "")) (< (length battery-mode-line-string) 10))
        (my/set-mode-line-caution)
      (progn
        (if (> my/load-average my/high-load-average)
            (my/set-mode-line-warning)
          (if (not my/work-timer-last-add-to-total-time)
              (my/set-mode-line-work-off)
            (my/set-mode-line-normal))))))

  (run-with-timer 1 1 'my/update-mode-line-color)
#+END_SRC

* Private config
** Function
#+BEGIN_SRC emacs-lisp
(defun my/load-if-exists (f)
  "load the elisp file only if it exists and is readable"
  (if (file-readable-p f)
      (load-file f)))
#+END_SRC

** Load
#+BEGIN_SRC emacs-lisp
;;(my/load-if-exists "~/.emacs.d/spotify.el")
#+END_SRC

