* Docs
** Requirements
*** All
=xorg-server xorg-xrandr xorg-xinit xorg-setxkbmap mlocate atool unzip mono pulseaudio pavucontrol icecat/firefox the_silver_searcher imagemagick ttf-inconsolata ttf-opensans ttf-dejavu aspell aspell-en aspell-sv mpd mpc poppler poppler-glib=
*** All optional
=msbuild dotnet-sdk godot-mono guile fsharp=

*** UTF-8 support
=ttf-dejavu= fills in the gaps where opensans doesn't have the character

*** Music
=mpd= =mpc= 
=pulse audio= if alsa, etc, edit "MPD/Create config".

*** Search
=the silver searcher/ ag=
=grep=

*** Code
**** Documentation
=zeal=

**** C#
=mono= 
=M-x omnisharp-install-server=

**** F#
=mono= (3.10.X or higher) =F#= (3.0 or higher) 
To create solution file, check github
On windows, you may need to manually point to server path, see github

**** Clojure
=leiningen= =clojure=

*** Screenshots
=imagemagick=

*** Overtone
=jack2= =leiningen= =cider=

To start =leiningen= in emacs do =cider-jack-in=

Input =(use 'overtone.live)= into leiningen to install

**** To use with pulse audio
=cadence= and =pulseaudio-jack=

*** Spelling
=aspell-en= etc

*** Gnus
Set adress in gnus.el

*** Laptop
=xorg-xbacklight=
=wpa_supplicant=

*** Switch Ctrl and Caps
=xmodmap= =xsession=

*** PDF tools
=poppler= =poppler-glib=
M-x =pdf-tools-install=

*** GPG pinentry
=gpg2= =pinentry=

*** Misc
=redshift= 

** Firefox vimium
*** Config
#+BEGIN_SRC
# Rebind up/down
unbind n
unbind N
map n scrollDown
map N previousTab
unbind p
unbind P
map p scrollUp
map P nextTab

unbind k
unbind K
map k openCopiedUrlInCurrentTab
map K openCopiedUrlInNewTab

# Rebind scroll
unbind <c-u>
unbind <c-d>
map <c-u> scrollPageUp
map <c-d> scrollPageDown

# Rebind tab close
unbind s
map s removeTab
#+END_SRC

*** Hint characters
#+BEGIN_SRC
anetoshdirgmlwyfubxcvkp,.q;j/z
#+END_SRC

** FSharp
*** File is not part of the loaded projects
Try having the =fsproj= file open in a buffer or try moving the project folder directly to the home folder

** Overtone
*** Pulse-jack
**** How to configure jack2 to work with pulse
https://wiki.archlinux.org/index.php/PulseAudio/Examples#PulseAudio_through_JACK
(The KXStudio method)

1. get =cadence= and =pulseaudio-jack=
   
2. Bridge alsa -> pulse -> jack

3. Autostart maybe???

4. Configure -> Alsa -> Good settings

**** Pauvcontrol measures sound but can't hear anything
Unmute the sound device in pauvcontrol

**** How should jack be started???
Let overtone (actually it's supercollider, since overtone is just a wrapper for using supercollider in clojure) do it (it does it automatically when inputting =(use 'overtone.live)= in leiningen)

*** Jack only
1. add =autospawn = no= in =~/.config/pulse/client.conf= 
2. kill pulseaudio with =pulseaudio -k= 
3. get =jack2= (NOT jack2-dbus, does't work)
4. start overtone

**** Still doesn't work
Get =qjackctl= and start =jack2= from there

*** Sounds only play in one ear??
https://github.com/overtone/overtone/wiki/Multi-channel-expansion,-stereo-and-panning
You have to specify sound channel in the code when using certain sounds

*** Overtone errors out all the time
Execute script up to down, put =(use 'overtone.live)= on top of file, and in leiningen

*** Shit doesn't work
just fiddle around with cadence (check if bridge type is correct, then force restart until it works)

** Dired
*** Archives in dired
Press c to compress, Z to extract
To stop dired from creating new folder when unpacking, change in section "Dired atool"

** Can't find package error
run
=package-refresh-contents=
or restart emacs
** Gnus 
*** How to setup name and password
Create authinfo.pgp file. It is auto encrypted/decrypted

Format for gmail is currently
#+BEGIN_SRC
machine imap.gmail.com login <USER> password <APP-PASSWORD> port imaps
machine smtp.gmail.com login <USER> password <APP-PASSWORD> port 587
machine imap-mail.outlook.com login my-username@hotmail.com password my-secret-password port 993
#+END_SRC

*** gnus mails are not updating
Try doing C-u M-g twice inside that inbox

*** Where are my servers/passwords stored?
=~/.authinfo.gpg=

*** How to download articles using gnus?
use =M-x gnus-agent-add-server=

*** Mail server mails aren't marked as read when marking as read in gnus, and gnus isn't marking them as read either after exit
You have to press =q= in order to save changes

** wpa supplicant
https://wiki.archlinux.org/index.php/WPA_supplicant#Connecting_with_wpa_cli

** MPD
*** "no mpd daemon running" 
Disable daemon if using systemctl with =systemctl disable mpd.service mpd.socket=

** Eww
*** Opening local file results in raw page
This is because the file isn't named =FILE.html=, when eww saves pages, it doesn't add =.html= at the end

** Keyboard setup
*** Change keyboard layout
To list keymaps, do =localectl list-keymaps=

=carpalx= is example layout
To load keymaps, in terminal do: =loadkeys carpalx=

To make permanent:
in =/etc/vconsole.conf=
#+BEGIN_SRC
KEYMAP=carpalx
FONT=lat9w-16
#+END_SRC

*** Swap Ctrl and Caps_Lock
Load correct keymap
1. Do =sudo dumpkeys | head -1 > ~/Keys.map=
2. Add this under the one line long Keys.map
#+BEGIN_SRC maps
keycode 58 = Control # Makes Caps Lock act as ctrl
keycode 29 = Caps_Lock # Makes ctrl act as caps
# alt_is_meta # Fix the alt key?
#+END_SRC
3. Do =sudo loadkeys ~/Keys.map=

** Color picking
Get =gpick=

** Todo
https://potassco.org/doc/start/

** C libraries not imported
Add compile libraries to =irony--compile-options=. For gtk set =irony--compile-options= like this
#+BEGIN_SRC emacs-lisp
#+END_SRC
 
** GDB doesn't work properly
make sure you compiled with the =-g= flag

** Compatibility
*** Mesa 3d software rendering
Makes godot work with old computers
#+BEGIN_SRC command
LIBGL_ALWAYS_SOFTWARE=1 godot-mono 
#+END_SRC

* Security
#+BEGIN_SRC emacs-lisp
  (setq network-security-level 'high)
#+END_SRC

** Make authinfo gpg file
#+BEGIN_SRC emacs-lisp
  (setq netrc-file "~/.authinfo.gpg")
  (setq auth-sources '("~/.authinfo.gpg"))
#+END_SRC

* Package management
Bootstrap straight.el
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

* Private config
#+BEGIN_SRC emacs-lisp
(defun my/load-if-exists (f)
  "load the elisp file only if it exists and is readable"
  (if (file-readable-p f)
      (load-file f)))
#+END_SRC

** Private config
#+BEGIN_SRC emacs-lisp
  (my/load-if-exists (concat user-emacs-directory "private.el"))
#+END_SRC

** Device config
#+BEGIN_SRC emacs-lisp
  ;; If a device config is not made, load the default one
  (if (not (my/load-if-exists (concat user-emacs-directory "device.el")))
      (load-file (concat user-emacs-directory "device-template.el")))
#+END_SRC

* Libraries
#+BEGIN_SRC emacs-lisp
  (straight-use-package 's)
  (straight-use-package 'dash)
  (require 's)
  (require 'dash)
#+END_SRC

* Persistent keys
#+BEGIN_SRC emacs-lisp
  (defvar my/keys-mode-map (make-sparse-keymap))

  ;; Emacs 27 doesn't support :init-value, :keymap, etc
  (if (string< emacs-version "27")
      (define-minor-mode my/keys-mode
        ;; init value t to enable it in fundamental mode
        ;; More info: http://emacs.stackexchange.com/q/16693/115
        :init-value t
        :keymap my/keys-mode-map)
    (define-minor-mode my/keys-mode nil t nil my/keys-mode-map))

  (add-to-list 'emulation-mode-map-alists `((my/keys-mode . ,my/keys-mode-map)))
#+END_SRC

** Mode specific settings
#+BEGIN_SRC emacs-lisp
  ;; Disable keys in minibuffers such as ivy, etc
  ;; (add-hook 'minibuffer-setup-hook 'my/keys-mode-turn-off)
  ;;(add-hook 'messages-buffer-mode-hook 'my/keys-mode-turn-on)
#+END_SRC

* Global setting
Define my mode for setting global settings in all buffers
#+BEGIN_SRC emacs-lisp
  ;; (define-minor-mode my/mode nil t nil nil)
  ;; 
  ;; (define-globalized-minor-mode my/global-mode my/mode
    ;; (lambda ()
      ;; (setq my/truncate-lines nil)))
      ;; ;;(toggle-truncate-lines -1)))
  ;; 
  ;; (my/global-mode 1)
#+END_SRC

* Generic functions and variables
** File management
*** Create directory if directory doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-dir-if-not-exist (dir)
    (if (not (file-directory-p dir))
        (progn
          (make-directory dir)
          (message (concat "dir: " dir " created!")))))
#+END_SRC

*** Create file if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-if-not-exist (file)
    (if (not (file-exists-p file))
        (progn
          (write-region "" nil file)
          (message (concat "Wrote file: " file " created!")))))
#+END_SRC

*** Create file with content if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-with-content-if-not-exist (file content)
    (if (not (file-exists-p file))
        (progn
          (write-region content nil file)
          (message (concat "Wrote file: " file " with contents")))))
;;" created with content: " content
#+END_SRC

*** Add to content to file or create file with content if file doesn't exist 
#+BEGIN_SRC emacs-lisp
  (defun my/add-to-or-create-file-with-content (file content)
          (write-region (concat "\n" content) nil file t)
          (message (concat "Wrote file: " file " with contents")))
#+END_SRC

** Is external package installed
Checks variable =exec-path= for package
#+BEGIN_SRC emacs-lisp
  (defun my/is-system-package-installed (package)
    (if (executable-find (symbol-name package))
        (symbol-name package)
      (message (concat "Package: " (symbol-name package) " not installed"))
      ()))
#+END_SRC

*** Set exec-path by system
#+BEGIN_SRC emacs-lisp
  ;;(if (string-match-p "guixsd" (system-name))
      ;;(add-to-list 'exec-path "/bin/" ))
#+END_SRC

** Give buffer unique name
#+BEGIN_SRC emacs-lisp
  (defun my/give-buffer-unique-name(base-name)
    (rename-buffer base-name t))
#+END_SRC

** Is font installed
#+BEGIN_SRC emacs-lisp
  (defvar my/font-family-list (font-family-list))
  (defun my/font-installed (font)
    (if (member font my/font-family-list)
      t
      nil))
#+END_SRC

** Fake key
#+BEGIN_SRC emacs-lisp
  (defun my/fake-key (key key-symbol)
    (interactive)
    (let ((command (key-binding key)))
      (setq last-command-event key-symbol)
      (setq this-command command)
      (call-interactively command)))

  (defun my/fake-open-keymap (key)
    (setq unread-command-events
          (mapcar (lambda (e) `(t . ,e))
                  (listify-key-sequence (kbd key)))))
#+END_SRC

** Fold ellipsis 
#+BEGIN_SRC emacs-lisp
  (defvar my/fold-ellipsis)
  (defvar my/fold-ellipsis-char)

  (if window-system
      (progn
        (setq my/fold-ellipsis "↴")
        (setq my/fold-ellipsis-char ?↴))
    ;; The terminal probably doesn't support unicode
    (setq my/fold-ellipsis "↓")
    (setq my/fold-ellipsis-char ?↓))
#+END_SRC

** File size human readable
Default file-size-human-readable returns decimal values
#+BEGIN_SRC emacs-lisp
  (require 'files)

  (defun my/file-size-human-readable (file-size &optional flavor decimal)
    "Produce a string showing FILE-SIZE in human-readable form.

  Optional second argument FLAVOR controls the units and the display format:

   If FLAVOR is nil or omitted, each kilobyte is 1024 bytes and the produced
      suffixes are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `si', each kilobyte is 1000 bytes and the produced suffixes
      are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `iec', each kilobyte is 1024 bytes and the produced suffixes
      are \"KiB\", \"MiB\", \"GiB\", \"TiB\", etc.
   If DECIMAL is true, a decimal number is returned"
    (setq 1024Decimal (if decimal 1024.0 1024))
    (setq 1000Decimal (if decimal 1000.0 1000))

    (let ((power (if (or (null flavor) (eq flavor 'iec))
                     1024Decimal
                   1000Decimal))
          (post-fixes
           ;; none, kilo, mega, giga, tera, peta, exa, zetta, yotta
           (list "" "k" "M" "G" "T" "P" "E" "Z" "Y")))
      (while (and (>= file-size power) (cdr post-fixes))
        (setq file-size (/ file-size power)
              post-fixes (cdr post-fixes)))
      (format (if (> (mod file-size 1.0) 0.05)
                  "%.1f%s%s"
                "%.0f%s%s")
              file-size
              (if (and (eq flavor 'iec) (string= (car post-fixes) "k"))
                  "K"
                (car post-fixes))
              (if (eq flavor 'iec) "iB" ""))))
#+END_SRC

** Set font
#+BEGIN_SRC emacs-lisp
  (defvar my/default-face-height 120)
  (defun my/set-default-font(font)
    (if window-system
        (set-face-attribute 'default nil
                            :family font
                            :height my/default-face-height)))
#+END_SRC

** Overlay
#+BEGIN_SRC emacs-lisp
(defun my/inline-overlay-print (string)
  (let ((inline-overlay (make-overlay (point) (line-end-position))))
    ;; Put overlay
    (overlay-put inline-overlay 'after-string
		 (propertize
		  (concat
		   " ;=>"
		   string
		   )
		  'face '(:foreground "light blue")
		  ))
    ;; Just sit for 100 seconds
    (sit-for 100)
    ;; Then delete overlay
    (delete-overlay inline-overlay)))

;; (my/inline-overlay-print "test")
#+END_SRC

* Fonts
** Normal fonts
#+BEGIN_SRC emacs-lisp  
  (defvar my/is-font-mono nil)
  (defvar my/font nil)
  (defvar my/font-raw nil)

  (if (my/font-installed "FreeSans")
      (progn
        (setq my/font-raw "FreeSans")
        (setq my/font "FreeSans"))
    (if (my/font-installed "Open Sans")
        (progn
          (setq my/font-raw "Open Sans")
          (setq my/font "opensans"))
      (if (my/font-installed "dejavu sans")
          (progn
            (setq my/font-raw "dejavu sans")
            (setq my/font "DejaVuSans")))))

  (if my/font
      (my/set-default-font my/font))
#+END_SRC

** Mono font
#+BEGIN_SRC emacs-lisp
  (defun my/get-best-mono-font ()
    (if my/is-font-mono
        my/font
      (if (my/font-installed "Inconsolata")
          "Inconsolata"
        (if (my/font-installed "dejavu sans mono")
            "DejaVuSansMono"
          (if (my/font-installed "Noto Sans Mono")
              "NotoSansMono"
            (if (my/font-installed "Perfect DOS VGA 437")
                "Perfect DOS VGA 437"))))))

  (defvar my/mono-font (my/get-best-mono-font))
#+END_SRC

* Startup processes
** Make sure mode line is disabled before any windows are created
#+BEGIN_SRC emacs-lisp
  (if window-system
      (progn
        (setq mode-line-format "")
        (setq-default mode-line-format ""))
    (setq mode-line-format nil)
    (setq-default mode-line-format nil))
#+END_SRC

** Prevent async command from opening new window
#+BEGIN_SRC emacs-lisp
  ;; Buffers that I don't want popping up by default
  (add-to-list 'display-buffer-alist
               '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+END_SRC

** Check if OS is fully compatible
#+BEGIN_SRC emacs-lisp
  (defvar fully-compatible-system (or (eq system-type 'gnu/linux)(eq system-type 'gnu)(eq system-type 'gnu/kfreebsd)))
#+END_SRC

** Redshift 
#+BEGIN_SRC emacs-lisp
  (if (my/is-system-package-installed 'redshift)
      (start-process "redshift" nil "redshift"))
#+END_SRC

** Garbage collection
#+BEGIN_SRC emacs-lisp
  (setq garbage-collection-messages t)

  ;; Get 80% of memory
  ;; (defvar my/emacs-max-ram-usage (floor (* (* (car (memory-info)) 0.8) 1024))
    ;; "Max ram emacs can use before having to jump ship
  ;; Is in bytes")
  ;; 
  ;; (if my/emacs-max-ram-usage
      ;; (setq gc-cons-threshold 800000))
  (setq gc-cons-threshold 80000000)

  (setq my/final-gc-mem 800000)

  ;; (defun garbage-collect (&rest args) 
  ;; (message "Emacs is trying to garbage collect, it's time to jump ship"))
#+END_SRC

** Disable custom
Stop custom from editing init.el
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory ".emacs-custom.el"))
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
  (setq evil-search-module 'evil-search)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)

  ;; Makes swiper A LOT faster
  (setq evil-ex-interactive-search-highlight t)
  (setq evil-ex-search-persistent-highlight nil)

  (straight-use-package 'evil)
  (require 'evil)

  ;;(fset 'evil-visual-update-x-selection 'ignore)
  (evil-mode)
#+END_SRC

** Minibuffer
#+BEGIN_SRC emacs-lisp
  ;; Enable evil in minibuffer
  (setq evil-want-minibuffer t)

  ;; This fixes evil minibuffer binds
  (add-hook 'minibuffer-setup-hook 'evil-insert-state)
#+END_SRC

** Bind evil key
#+BEGIN_SRC emacs-lisp
  (defun my/evil-normal-define-key (key command)
    (interactive)
    (define-key evil-normal-state-map (kbd key) command)
    (define-key evil-motion-state-map (kbd key) command))

  (defun my/evil-universal-define-key (key command)
    (interactive)
    (my/evil-normal-define-key key command)
    (define-key evil-insert-state-map (kbd key) command)
    (define-key evil-visual-state-map (kbd key) command))
#+END_SRC

** Settings
*** Disable messages in echo area
Evil spams message area
#+BEGIN_SRC emacs-lisp
(setq
    evil-emacs-state-message nil
    evil-operator-state-message nil
    evil-insert-state-message nil
    evil-replace-state-message nil
    evil-motion-state-message nil
    evil-normal-state-message nil
    evil-visual-state-message nil)
#+END_SRC

*** Cursor states
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-cursor '("purple" box))
  (setq evil-normal-state-cursor '("white" box))
  (setq evil-visual-state-cursor '("yellow" box))
  (setq evil-insert-state-cursor '("orange" box))
  (setq evil-replace-state-cursor '("green" box))
  (setq evil-operator-state-cursor '("white" hollow))
#+END_SRC

*** Disable emacs mode 
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-modes nil)
#+END_SRC

*** Set which modes use which evil state by default
Example
#+BEGIN_SRC emacs-lisp
  (setq evil-insert-state-modes nil)

  (if (string< emacs-version "24.3")
      (error "Since emacs version is under 24.3, you need to remove cl-... in this section, and add (require 'cl) (not recommended to do in later versions)"))

  (cl-loop for (mode . state) in '(
                                   ;; So i C-leader works for exwm windows
                                   (exwm-mode . emacs)
                                   ;;(eshell-mode . insert)
                                   (term-mode . insert)
                                   ;;(org-agenda-mode . insert)
                                   (magit-popup-mode . insert)
                                   (proced-mode . insert)
                                   (emms-playlist-mode . insert))
           do (evil-set-initial-state mode state))
#+END_SRC

*** Switching to normal state without moving cursor
#+BEGIN_SRC emacs-lisp
  (defun my/evil-normal-state (&optional arg)
    (if (not(eq evil-state 'normal))
        (progn
          (evil-normal-state arg)
          (move-to-column (+ 1 (current-column))))))
#+END_SRC

*** Make one space enough to end work for use with evil sentence motion
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Make dd and cc act on lines
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "D" 'evil-delete-whole-line)
  (my/evil-normal-define-key "C" 'evil-change-whole-line)
#+END_SRC

** Text objects
*** Evil-entire-buffer
Modify entire buffer - for example: "d a e"
https://github.com/supermomonga/evil-textobj-entire
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-entire-entire-buffer (count &optional beg end type)
    "Select entire buffer"
    (evil-range (point-min) (point-max)))

  (define-key evil-outer-text-objects-map "e" 'evil-entire-entire-buffer)
  (define-key evil-inner-text-objects-map "e" 'evil-entire-entire-buffer)
#+END_SRC

*** Evil-line
https://github.com/syohex/evil-textobj-line
#+BEGIN_SRC emacs-lisp
  (defun evil-line-range (count beg end type &optional inclusive)
    (if inclusive
        (evil-range (line-beginning-position) (line-end-position))
      (let ((start (save-excursion
                     (back-to-indentation)
                     (point)))
            (end (save-excursion
                   (goto-char (line-end-position))
                   (skip-syntax-backward " " (line-beginning-position))
                   (point))))
        (evil-range start end))))

  (evil-define-text-object evil-a-line (count &optional beg end type)
    "Select range between a character by which the command is followed."
    (evil-line-range count beg end type t))
  (evil-define-text-object evil-inner-line (count &optional beg end type)
    "Select inner range between a character by which the command is followed."
    (evil-line-range count beg end type))

  (define-key evil-outer-text-objects-map "l" 'evil-a-line)
  (define-key evil-inner-text-objects-map "l" 'evil-inner-line)
#+END_SRC

*** Evil-indent-plus
Allows for using indention as text objects
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-indent-plus)

  (define-key evil-inner-text-objects-map "i" 'evil-indent-plus-i-indent)
  (define-key evil-outer-text-objects-map "i" 'evil-indent-plus-a-indent)
  (define-key evil-inner-text-objects-map "I" 'evil-indent-plus-i-indent-up)
  (define-key evil-outer-text-objects-map "I" 'evil-indent-plus-a-indent-up)
  (define-key evil-inner-text-objects-map "C-i" 'evil-indent-plus-i-indent-up-down)
  (define-key evil-outer-text-objects-map "C-i" 'evil-indent-plus-a-indent-up-down)
#+END_SRC

*** Evil textobject block
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-textobj-anyblock)

  (define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
  (define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block)

  ;;(define-key evil-motion-state-map "!" 'evil-textobj-anyblock-forward-open-block-start)

  (setq evil-textobj-anyblock-blocks
        '(("(" . ")")
          ("{" . "}")
          ("\\[" . "\\]")
          ("<" . ">")
          ("\"" . "\"")
          ("“" . "”")))
#+END_SRC

*** Evil-surround
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

*** Evil-args
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-args)

  ;; bind evil-args text objects
  (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
  (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
#+END_SRC

** Evil-lion
#+BEGIN_SRC emacs-lisp
  ;;(straight-use-package 'evil-lion)

  ;;(evil-lion-mode)
#+END_SRC

** Evil-goggles
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-goggles)
  (evil-goggles-mode)
  ;; Disable pulse which both fixes so that you can set foreground color on the pulse font and saves on performance
  (setq evil-goggles-pulse nil)
  (setq evil-goggles-duration 60)

  (evil-goggles-use-diff-faces)
#+END_SRC

** Evil-matchit
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'evil-matchit)
  (global-evil-matchit-mode 1)
#+END_SRC

** Evil-multiple cursors
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'evil-mc)
  ;; 
  ;; (global-evil-mc-mode 1)
  ;; 
  ;; (define-prefix-command 'my/evil-mc-map)
  ;;(define-key my/leader-map (kbd "q") 'my/evil-mc-map)
  ;; (define-key evil-normal-state-map (kbd "m") 'my/evil-mc-map)
  ;; (define-key evil-visual-state-map (kbd "m") 'my/evil-mc-map)
  ;; 
  ;; (define-key my/evil-mc-map (kbd "d") 'evil-mc-undo-all-cursors)
  ;; (define-key my/evil-mc-map (kbd "v") 'evil-mc-make-cursor-here)
  ;; (define-key my/evil-mc-map (kbd "V") 'evil-mc-make-all-cursors)
  ;; (define-key my/evil-mc-map (kbd "s") 'evil-mc-pause-cursors)
  ;; (define-key my/evil-mc-map (kbd "S") 'evil-mc-resume-cursors)
  ;; (define-key my/evil-mc-map (kbd "n") 'evil-mc-make-and-goto-next-cursor)
  ;; (define-key my/evil-mc-map (kbd "p") 'evil-mc-make-and-goto-prev-cursor)
  ;; 
  ;; (define-key my/evil-mc-map (kbd "g g") 'evil-mc-make-and-goto-first-cursor)
  ;; (define-key my/evil-mc-map (kbd "G") 'evil-mc-make-and-goto-last-cursor)

  ;; (define-key evil-visual-state-map "A" 'evil-append)
  ;; (define-key evil-visual-state-map "I" 'evil-insert)
  ;; 
  ;; (define-key evil-visual-state-map "R" 'evil-change)
  ;; 
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  ;; Prevent emacs state from being exited with esc, fixes exwm since it uses emacs state and to exit hydra you have to do esc
  (define-key evil-emacs-state-map (kbd "<escape>") 'keyboard-quit)

  ;; Couldn't bother to create custom evil-join
  ;; P is normally bound to manual, make this key useful
  (my/evil-normal-define-key "P" 'delete-indentation)
#+END_SRC

*** Rebind evil case change
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "g u" 'evil-downcase)
  (my/evil-normal-define-key "g U" 'evil-upcase)
#+END_SRC

*** Add perspective movement to g
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "gb" 'evil-scroll-line-to-bottom)
  (my/evil-normal-define-key "gf" 'evil-scroll-line-to-top)
  (my/evil-normal-define-key "ge" 'evil-scroll-line-to-center)
#+END_SRC

*** Don't complete from all buffers
#+BEGIN_SRC emacs-lisp
(setq evil-complete-all-buffers nil)
#+END_SRC

*** Don't add pasted over thing to killring
#+BEGIN_SRC emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+END_SRC

* Backups
Stop emacs from creating backup files on every save
#+BEGIN_SRC emacs-lisp
  ;;(setq make-backup-files nil)
  ;;(setq auto-save-default nil)
  ;; Make multiple backups
  (setq version-control t)

  ;; Backup even if file is under version control
  (setq vc-make-backup-files t)

  (setq backup-by-copying t)      ; don't clobber symlinks
  (setq delete-old-versions t)
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)

  (defvar my/backup-directory (concat user-emacs-directory "backups/"))
  (defvar my/auto-saves-directory (concat user-emacs-directory "auto-saves/"))

  (my/create-dir-if-not-exist my/backup-directory)

  (my/create-dir-if-not-exist my/auto-saves-directory)

  (setq backup-directory-alist `(("." . ,my/backup-directory)))
  (setq auto-save-file-name-transforms `((".*" ,my/auto-saves-directory t)))
#+END_SRC

** Make backup on every save
https://www.emacswiki.org/emacs/ForceBackups
#+BEGIN_SRC emacs-lisp
  (defvar my/create-per-session-backups t)
  ;; Max amount of characters, 200 000 ~200kb
  (defvar my/per-session-backup-limit 200000)

  (defvar my/backup-per-session-directory (concat my/backup-directory "per-session/"))

  (my/create-dir-if-not-exist my/backup-per-session-directory)

  (defun my/force-backup-of-buffer ()
    (interactive)
    (if (and my/create-per-session-backups (< (point-max) my/per-session-backup-limit) (buffer-modified-p))
        (save-restriction (widen) (write-region (point-min) (point-max) (concat my/backup-per-session-directory (number-to-string (time-to-seconds)) (buffer-name)) nil nil nil))))
#+END_SRC

** Delete old backups
#+BEGIN_SRC emacs-lisp
  ;; Automatically delete old backup files older than a week
  (message "Deleting old backup files...")
  (let ((week (* 60 60 24 7))
        (current (float-time (current-time))))
    (dolist (file (directory-files my/backup-directory t))
      (when (and (backup-file-name-p file)
               (> (- current (float-time (nth 5 (file-attributes file))))
                  week))
        (message "%s" file)
        (delete-file file))))
#+END_SRC

** Delete per-session backups on startup
#+BEGIN_SRC emacs-lisp
  (shell-command (concat "rm " my/backup-per-session-directory "*" ))
#+END_SRC

** Disble backups for certain files
#+BEGIN_SRC emacs-lisp
  (define-minor-mode my/no-backups-mode
    "http://anirudhsasikumar.net/blog/2005.01.21.html
  For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    "no-backups"
    ;; The minor mode bindings.
    nil
    (if (symbol-value my/no-backups-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t) 
          ;; disable auto-save
          (if auto-save-default
              (progn
                (setq my/create-per-session-backups nil)
                (auto-save-mode -1))))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (progn
            (setq my/create-per-session-backups t)
            (auto-save-mode 1)))))
#+END_SRC

*** File types to not backup
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.gpg$" . my/no-backups-mode))

  (add-hook 'image-mode-hook 'my/no-backups-mode)
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'undo-tree)

  (setq global-undo-tree-mode t)

  ;; Fixes errors
  (setq undo-tree-enable-undo-in-region nil)
  (setq-default undo-tree-enable-undo-in-region nil)

  ;; (setq undo-tree-auto-save-history t)
  ;; (setq-default undo-tree-auto-save-history t)

  (setq undo-tree-visualizer-lazy-drawing nil)
  (setq-default undo-tree-visualizer-lazy-drawing nil)

  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)

  ;;(setq undo-tree-auto-save-history t)

  ;;(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/saves")))
  ;;(make-directory (concat spacemacs-cache-directory "undo"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (add-hook 'undo-tree-visualizer-mode-hook '(lambda () (interactive) (run-with-timer 0.1 nil 'evil-force-normal-state)))

  (setq undo-tree-visualizer-mode-map (make-sparse-keymap))

  (evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "p") 'undo-tree-visualize-undo)
  (evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "n") 'undo-tree-visualize-redo)
  (evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "l") 'undo-tree-visualize-switch-branch-right)
  (evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "h") 'undo-tree-visualize-switch-branch-left)
  (evil-define-key 'insert undo-tree-visualizer-mode-map (kbd "d") 'undo-tree-visualizer-toggle-diff)
#+END_SRC

* Leader
When changing leader, change =my/leader-map-key=
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/leader-map)

  (defvar my/leader-map-key "SPC")
  (defvar my/mod-leader-map-key "C-SPC")

  (defvar my/window-leader-key "C-=")
  (defvar my/mod-window-leader-key "M-C-=")

  (define-prefix-command 'my/help-map)
  (define-key my/leader-map (kbd "H") 'my/help-map)

  (my/evil-normal-define-key "U" 'undo-tree-visualize)

  (my/evil-normal-define-key my/leader-map-key my/leader-map)
  (define-key evil-visual-state-map (kbd my/leader-map-key) my/leader-map)
#+END_SRC

* Alert
#+BEGIN_SRC emacs-lisp
  (defvar my/past-alerts (list))

  (defun my/alert (&optional str severity)
    (let ((color
           (pcase severity
             ('low "green")
             ('med  "yellow")
             ('high  "red")
             (_   "blue"))))
      (my/alert-blink-fringe color)

      (if str
          (progn
            (push " " my/past-alerts)
            (push (propertize (concat "[" str "]") 'face `(:background ,color)) my/past-alerts)
            (message str)))))

  (defvar my/alert-blink-fringe-color "red")

  (defun my/alert-blink-fringe (color)
    (setq my/alert-blink-fringe-color color)
    (run-with-timer 0.25 nil 'my/alert-fringe-set-color)
    (run-with-timer 0.5 nil 'my/alert-fringe-restore)
    (run-with-timer 0.75 nil 'my/alert-fringe-set-color)
    (run-with-timer 1 nil 'my/alert-fringe-restore)
    (run-with-timer 1.25 nil 'my/alert-fringe-set-color)
    (run-with-timer 1.5 nil 'my/alert-fringe-restore))

  (defun my/alert-fringe-set-color ()
    (set-face-attribute 'fringe nil :foreground my/alert-blink-fringe-color :background my/alert-blink-fringe-color))

  (defun my/alert-fringe-restore ()
    (set-face-attribute 'fringe nil :foreground nil :background nil))

  (defun my/alert-reset ()
    (interactive)
    (setq my/past-alerts (list)))

  (define-key my/leader-map (kbd "R") 'my/alert-reset)
#+END_SRC

* Package management
** Guix
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'guix)
#+END_SRC
  
*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/guix-map)
  (define-key my/leader-map (kbd "G") 'my/guix-map)

  (define-key my/guix-map (kbd "v") 'guix)
  (define-key my/guix-map (kbd "P") 'guix-profiles)
  (define-key my/guix-map (kbd "g") 'guix-generation)
  (define-key my/guix-map (kbd "G") 'guix-system-generations)
  (define-key my/guix-map (kbd "i") 'guix-installed-user-packages)
  (define-key my/guix-map (kbd "I") 'guix-installed-system-packages)

  (define-prefix-command 'my/guix-services-map)
  (define-key my/guix-map (kbd "s") 'my/guix-services-map)

  (define-key my/guix-services-map (kbd "a") 'guix-all-services)
  (define-key my/guix-services-map (kbd "n") 'guix-services-by-name)
  (define-key my/guix-services-map (kbd "l") 'guix-services-by-location)
  (define-key my/guix-services-map (kbd "d") 'guix-find-service-definition)

  (define-prefix-command 'my/guix-package-map)
  (define-key my/guix-map (kbd "p") 'my/guix-package-map)

  (define-key my/guix-package-map (kbd "a") 'guix-all-packages)
  (define-key my/guix-package-map (kbd "n") 'guix-packages-by-name)
  (define-key my/guix-package-map (kbd "l") 'guix-packages-by-location)
  (define-key my/guix-package-map (kbd "c") 'guix-packages-from-system-config-file)
  (define-key my/guix-package-map (kbd "d") 'guix-find-package-definition)

  (define-prefix-command 'my/guix-store-map)
  (define-key my/guix-map (kbd "S") 'my/guix-store-map)

  (define-key my/guix-store-map (kbd "l") 'guix-store-live-items)
  (define-key my/guix-store-map (kbd "d") 'guix-store-dead-items)
  (define-key my/guix-store-map (kbd "D") 'guix-store-item-derivers)
  (define-key my/guix-store-map (kbd "f") 'guix-store-failures)
  (define-key my/guix-store-map (kbd "r") 'guix-store-item-references)
  (define-key my/guix-store-map (kbd "R") 'guix-store-item-referrers)
  (define-key my/guix-store-map (kbd "C-r") 'guix-store-item-requisites)
#+END_SRC

** Local packages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name (concat user-emacs-directory "local-packages")))
#+END_SRC

* Write config map
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/write-config-map)
  (define-key my/leader-map (kbd "C-c") 'my/write-config-map)
#+END_SRC

** Write .gnus.el
Create =.gnus.el=, which gnus reads from 
#+BEGIN_SRC emacs-lisp
  (defun my/write-gnus ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.gnus.el" "
  AddYourEmailHereThenDeleteThis
  (setq mail-host-address \"MyAdress\")
  ")))

  (define-key my/write-config-map (kbd "g") 'my/write-gnus)
#+END_SRC

** Write .Xdefaults
emacs. commands to disable scrollbar, etc before launching emacs, improving startup time
#+BEGIN_SRC emacs-lisp
  (defun my/write-xdefaults ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.Xdefaults" " 
  emacs.toolBar: 0
  emacs.menuBar: 0
  emacs.verticalScrollBars: off" )))

  (define-key my/write-config-map (kbd "d") 'my/write-xdefaults)
#+END_SRC

** Write .xinitrc
=xset s= disables screen saver
setxkbmap to select keyboard layout

#+BEGIN_SRC emacs-lisp
  (defun my/write-xinitrc ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xinitrc" "
  xset s off
  xset s noblank
  xset s off
  xset s off -dpms

  setxkbmap -layout us -variant altgr-intl
  # setxkbmap -layout carpalx -variant qgmlwy

  xmodmap ~./xmodmap

  # Fix java windows in exwm
  export _JAVA_AWT_WM_NONREPARENTING=1

  exec emacs")))

  (define-key my/write-config-map (kbd "i") 'my/write-xinitrc)
#+END_SRC

** Write .xmodmap
This swaps capslock and ctrl
#+BEGIN_SRC emacs-lisp
  (defun my/write-xmodmap ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xmodmap" " 
  ! Swap Caps_Lock and Control_L
  remove Lock = Caps_Lock
  remove Control = Control_L
  keysym Control_L = Caps_Lock
  keysym Caps_Lock = Control_L
  add Lock = Caps_Lock
  add Control = Control_L
  ")))

  (define-key my/write-config-map (kbd "m") 'my/write-xmodmap)
#+END_SRC

** Write mpd
#+BEGIN_SRC emacs-lisp
  (defun my/setup-mpd ()
    (interactive)
    (setq my/config-directory "~/.config/")
    (my/create-dir-if-not-exist my/config-directory)

    (setq my/mpd-directory (concat my/config-directory "mpd/"))
    (my/create-dir-if-not-exist my/mpd-directory)

    (setq my/mpd-conf-file (concat my/mpd-directory "mpd.conf"))
    (my/create-file-with-content-if-not-exist my/mpd-conf-file "
  music_directory \"~/Music\"
  playlist_directory  \"~/.config/mpd/playlists\"
  db_file \"~/.config/mpd/mpd.db\"
  log_file \"~/.config/mpd/mpd.log\"
  bind_to_address \"127.0.0.1\"
  port \"6600\"

  # For pulse audio
  audio_output {
  type \"pulse\"
  name \"pulse audio\"
  }
                   ")

    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.log"))
    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.db"))
    (my/create-dir-if-not-exist (concat my/mpd-directory "playlists/")))

  (define-key my/write-config-map (kbd "m") 'my/setup-mpd)
#+END_SRC

** Write GPG pinentry
#+BEGIN_SRC emacs-lisp
  (defun my/setup-gpg-agent ()
    (interactive)
    (setq my/gpg-directory "~/.gnupg/")
    (my/create-dir-if-not-exist my/gpg-directory)

    (setq my/gpg-agent-conf-file (concat my/gpg-directory "gpg-agent.conf"))
    (my/create-file-with-content-if-not-exist my/gpg-agent-conf-file "allow-emacs-pinentry")
    (shell-command "gpgconf --reload gpg-agent"))

  (define-key my/write-config-map (kbd "G") 'my/setup-gpg-agent)
#+END_SRC

** Write all configs
#+BEGIN_SRC emacs-lisp
  (defun my/write-all-config ()
    (interactive)
    (my/write-xdefaults)
    (my/write-xinitrc)
    (my/write-gnus)
    (my/setup-mpd))

  (define-key my/write-config-map (kbd "a") 'my/write-all-config)
#+END_SRC

* Install software
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/software-install-map)
  (define-key my/leader-map (kbd "I") 'my/software-install-map)
#+END_SRC

** Install eclipse java language server
For use with lsp-java
#+BEGIN_SRC emacs-lisp
  (defun my/install-eclipse-java-language-server()
    (interactive)
    (shell-command "
  cd ~
  rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
  mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
  wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
  tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
  "))

  (define-key my/software-install-map (kbd "j") 'my/install-eclipse-java-language-server)
#+END_SRC

** Install pdf tools
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "p") 'pdf-tools-install)
#+END_SRC

** Install omnisharp
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "o") 'omnisharp-install-server)
#+END_SRC

** Install rtags
You need llvm
#+BEGIN_SRC emacs-lisp
  ;; (defun my/install-rtags ()
    ;; (interactive)
    ;; (async-shell-command " cd ~
  ;; git clone --recursive https://github.com/Andersbakken/rtags.git
  ;; cd rtags
  ;; cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .
  ;; make"))
;; 
  ;; (define-key my/software-install-map (kbd "r") 'my/install-rtags)
#+END_SRC

** Compile config
#+BEGIN_SRC emacs-lisp
  (defun my/compile-config ()
    (interactive)
    (byte-compile-file my/config-exported-location nil))

  (define-key my/software-install-map (kbd "C-c") 'my/compile-config)
#+END_SRC

* Minor
** Startup
Disable startup message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

** Scratch buffer
*** Disable initial scratch buffer message
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

** Encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** Line wrapping
*** Enable truncate lines mode
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines nil)
  (setq truncate-lines nil)

  ;; Always truncate lines
  (setq truncate-partial-width-windows nil)
  (setq-default truncate-partial-width-windows nil)
#+END_SRC

**** Toggle truncate lines
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-v")
    '(lambda () (interactive)
       (setq truncate-lines (not truncate-lines))))
#+END_SRC

*** Fringe indicators of wrapped line
#+BEGIN_SRC emacs-lisp
  (setq visual-line-fringe-indicators '(right-triangle nil))
#+END_SRC

** Disable useless functionallity
#+BEGIN_SRC emacs-lisp
  (mouse-wheel-mode -1)
  (tooltip-mode -1)
#+END_SRC

** 1 letter prompts
Convert yes or no prompt to y or n prompt
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
  
** Smooth scroll
Scroll 1 line at a time when cursor goes outside screen
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Bell
Disable bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Subword (camel case movement)
 #+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
 #+END_SRC

** Change max killring size
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** Pixel scroll mode
In org mode when displaying images pixel scroll mode can be useful maybe
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'org-mode-hook 'pixel-scroll-mode)
#+END_SRC

** Increase and decrease brightness
#+BEGIN_SRC emacs-lisp
  (defun my/increase-brightness ()
    (interactive)
    (shell-command "xbacklight +5"))

  (defun my/decrease-brightness ()
    (interactive)
    (shell-command "xbacklight -5"))

  (global-set-key (kbd "<XF86MonBrightnessUp>") 'my/increase-brightness)
  (global-set-key (kbd "<XF86MonBrightnessDown>") 'my/decrease-brightness)
#+END_SRC

** Update packages
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-u") 'list-packages)
#+END_SRC

** Sudo edit
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'sudo-edit)

  (define-key my/leader-map (kbd "M-s") 'sudo-edit)
#+END_SRC

** With-editor
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'with-editor)
#+END_SRC

** Enable disabled commands
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
#+END_SRC

** Async
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'async)

  (require 'async)
  (require 'dired-async)
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1)
#+END_SRC

** Zoom
#+BEGIN_SRC emacs-lisp
  ;; (defun my/increase-volume ()
  ;; (interactive)
  ;; (text-scale-set 0))
  ;; (define-key my/leader-map (kbd "+") ')
  ;; (define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-set 0)))
  ;; 
  (define-key my/leader-map (kbd "-") '(lambda () (interactive) (text-scale-decrease 4)))
  (define-key my/leader-map (kbd "=") '(lambda () (interactive) (text-scale-increase 4)))

  (define-key my/leader-map (kbd "C--") '(lambda () (interactive) (text-scale-decrease 1)))
  (define-key my/leader-map (kbd "C-=") '(lambda () (interactive) (text-scale-increase 1)))


  (define-key my/leader-map (kbd "+") '(lambda () (interactive) (text-scale-mode 0)))
  (define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-mode 0)))
#+END_SRC

** Toggle mono-font
#+BEGIN_SRC emacs-lisp
  ;;(font-get "opensans" :spacing)
  (defun my/toggle-mono-font(&optional arg)
    "If ARG is non-nil enable monofont, otherwise toggle it."
    (interactive)
    (if window-system
        (if (not my/is-font-mono)
            (if  (or arg (string= (face-attribute 'default :family) my/font-raw))
                (my/set-default-font my/mono-font)
              (my/set-default-font my/font)))))

  (define-key my/leader-map (kbd "C-f") 'my/toggle-mono-font)
#+END_SRC

*** Toggle local mono font
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-local-mono-font(&optional arg)
    "If ARG is non-nil enable monofont, otherwise toggle it."
    (interactive)
    (if window-system
        (if (not my/is-font-mono)
            (if  (or arg (string= (face-attribute 'default :family) my/font-raw))
                (face-remap-add-relative 'default :family my/mono-font)
              (face-remap-add-relative 'default :family my/font-raw)))))

  (define-key my/leader-map (kbd "M-f") 'my/toggle-local-mono-font)
#+END_SRC

** Exit emacs
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-z") 'save-buffers-kill-emacs)
#+END_SRC

** Help mode
#+BEGIN_SRC emacs-lisp
  ;;(define-key my/leader-map (kbd "C-h") help-map)
#+END_SRC

*** Disable help mode binds
#+BEGIN_SRC emacs-lisp
  (setq help-mode-map (make-sparse-keymap))
  (setq-default help-mode-map (make-sparse-keymap))

  ;; (evil-define-key 'normal help-mode-map (kbd "H") 'help-go-back)
  ;; (evil-define-key 'normal help-mode-map (kbd "L") 'help-go-forward)
  ;; (evil-define-key 'normal help-mode-map (kbd "<escape>") 'keyboard-quit)

  (setq help-mode-map
        (let ((map (make-sparse-keymap)))
          (define-key map "H" 'help-go-back)
          (define-key map "L" 'help-go-forward)
          (define-key map (kbd "<escape>") 'keyboard-quit)
          map))
#+END_SRC

** Compilation mode
#+BEGIN_SRC emacs-lisp
  (setq compilation-mode-map (make-sparse-keymap))
  (setq-default compilation-mode-map (make-sparse-keymap))
#+END_SRC

** Prefer loading newest lisp source file
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** Revert buffer bind
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "r") 'revert-buffer)
#+END_SRC

** Hotkey to hide cursor
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "M-h") (lambda () (interactive) (setq cursor-type nil)))
#+END_SRC

** Tetris
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'insert tetris-mode-map (kbd "p") 'tetris-rotate-next)
  (evil-define-key 'insert tetris-mode-map (kbd "n") 'tetris-move-down)
  (evil-define-key 'insert tetris-mode-map (kbd "h") 'tetris-move-left)
  (evil-define-key 'insert tetris-mode-map (kbd "l") 'tetris-move-right)
#+END_SRC

* File options
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/file-options-map)
  (define-key my/leader-map (kbd "`") 'my/file-options-map)
#+END_SRC

** Revert
#+BEGIN_SRC emacs-lisp
  (define-key my/file-options-map (kbd "r") 'revert-buffer)
#+END_SRC

** Statistics
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/statistics-map)
  (define-key my/file-options-map (kbd "s") 'my/statistics-map)

  (define-key my/statistics-map (kbd "w") 'count-words)
  (define-key my/statistics-map (kbd "r") 'count-words-region)
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/indentation-map)
  (define-key my/file-options-map (kbd "i") 'my/indentation-map)

  (defun my/change-tab-width ()
    (interactive)
    (setq-default tab-width (string-to-number (completing-read "Enter tab width" nil))))

  ;; Applies only to region
  (define-key my/indentation-map (kbd "t") 'tabify)
  (define-key my/indentation-map (kbd "SPC") 'untabify)

  (define-key my/indentation-map (kbd "w") 'my/change-tab-width)
#+END_SRC

* Open
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/open-map)
  (define-key my/leader-map (kbd "o") 'my/open-map)

  (defvar my/open-map-hook nil
    "Hook called after a buffer is visited through my/open-map")
#+END_SRC

** Scratch
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-scratch()
    (interactive)
    (switch-to-buffer "*scratch*")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "s") 'my/switch-to-scratch)
#+END_SRC

** Backup
#+BEGIN_SRC emacs-lisp
  (defun my/backups-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "backups")))
    (run-hooks 'my/open-map-hook))

  (defun my/backups-per-session-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "backups/per-session")))
    (run-hooks 'my/open-map-hook))


  (define-key my/open-map (kbd "b") 'my/backups-per-session-visit)
  (define-key my/open-map (kbd "B") 'my/backups-visit)
#+END_SRC

** Visit config
#+BEGIN_SRC emacs-lisp
  (defun my/config-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
    (define-key my/open-map (kbd "c") 'my/config-visit)
#+END_SRC
  
** Reload config
#+BEGIN_SRC emacs-lisp
  (defun my/config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "C-r") 'my/config-reload)

#+END_SRC

** Open trash
#+BEGIN_SRC emacs-lisp
  (defun my/trash-visit ()
    (interactive)
    (find-file "~/.local/share/Trash/files/")
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "t") 'my/trash-visit)

#+END_SRC

** Open agenda
#+BEGIN_SRC emacs-lisp
  (defun my/org-agenda-show-agenda-and-todo (&optional arg)
    (interactive "P")
    (org-agenda arg "a")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "a") 'my/org-agenda-show-agenda-and-todo)
#+END_SRC

** Open downloads
#+BEGIN_SRC emacs-lisp
  (defun my/open-downloads ()
    (interactive)
    (find-file "~/Downloads")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "d") 'my/open-downloads)
#+END_SRC

** Open password file
#+BEGIN_SRC emacs-lisp
  (defun my/open-passwords ()
    (interactive)
    (find-file espy-password-file)
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "p") 'my/open-passwords)
#+END_SRC

** Visit agenda file
#+BEGIN_SRC emacs-lisp
  (defun my/agenda-file-visit ()
    (interactive)
    (find-file "~/Notes/Agenda.org")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "A") 'my/agenda-file-visit)
#+END_SRC

** Open firefox
#+BEGIN_SRC emacs-lisp
  (defvar my/gui-browser
    (if (my/is-system-package-installed 'icecat)
        "icecat"
      (if (my/is-system-package-installed 'iceweasel)
          "iceweasel"
        "firefox")))

  (defvar my/temp-firefox-title-name "")
  (defvar my/browser-bookmarks '(
                                 "youtube.com"
                                 "discordapp.com/channels/@me"
                                 "github.com"
                                 "steamcommunity.com/chat"
                                 ))
  (defun my/launch-firefox ()
    (interactive)
    (let* (
           (search (completing-read "url " my/browser-bookmarks))
           (adress  
            (if (cl-member search my/browser-bookmarks :test #'string=)
                search
              (concat "https://www.google.com/search?q=" search))))
      (start-process (concat my/gui-browser my/temp-firefox-title-name) nil my/gui-browser "--new-window" adress)))

  (define-key my/leader-map (kbd "C-b") 'my/launch-firefox)
#+END_SRC

** Open eww
#+BEGIN_SRC emacs-lisp
  (defun my/launch-eww ()
    (interactive)
    (eww-browse-url (concat "https://www.google.com/search?q=" (completing-read "search: " nil))))

  (define-key my/leader-map (kbd "b") 'my/launch-eww)
#+END_SRC

** Suggest
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "s") 'suggest)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org)
  (require 'org)
  (require 'org-agenda)

  (define-prefix-command 'my/org-mode-map)
  (evil-define-key 'normal org-mode-map (kbd (concat my/leader-map-key " a")) 'my/org-mode-map)
#+END_SRC

** Babel
*** Supported runnable languages
  ;; (org-babel-do-load-languages
   ;; 'org-babel-load-languages
   ;; '((R . t)
     ;; (ditaa . t)
     ;; (dot . t)
     ;; (emacs-lisp . t)
     ;; (gnuplot . t)
     ;; (haskell . nil)
     ;; (ocaml . nil)
     ;; (python . t)
     ;; (ruby . t)
     ;; (screen . nil)
     ;; (sh . t)
     ;; (sql . nil)
     ;; (sqlite . t)))

** Bullets
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org-bullets)
  (require 'org-bullets)

  (when window-system
    (if (eq system-type 'windows-nt)
        (setq inhibit-compacting-font-caches t))
    (add-hook 'org-mode-hook (lambda () (interactive) (org-bullets-mode))))
#+END_SRC

** Visuals
*** Change face of levels
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-level-1 nil :inherit 'outline-1 :height 1.9)
  (set-face-attribute 'org-level-2 nil :inherit 'outline-2 :height 1.6)
  (set-face-attribute 'org-level-3 nil :inherit 'outline-3 :height 1.4)
  (set-face-attribute 'org-level-4 nil :inherit 'outline-4 :height 1.3)
  (set-face-attribute 'org-level-5 nil :inherit 'outline-5 :height 1.25)
  (set-face-attribute 'org-level-6 nil :inherit 'outline-6 :height 1.2)
  (set-face-attribute 'org-level-7 nil :inherit 'outline-7 :height 1.15)
  (set-face-attribute 'org-level-8 nil :inherit 'outline-8 :height 1.10)

  ;; :weight 'semi-bold
#+END_SRC

*** Ellipsis face
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis my/fold-ellipsis)
#+END_SRC

*** Always truncate lines
#+BEGIN_SRC emacs-lisp
  (setq org-startup-truncated nil)
#+END_SRC

** Indent mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Org SRC
*** Make c-' open in current window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

*** Don't save window layout
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-src-mode-hook '(lambda () (interactive) (setq org-src--saved-temp-window-config nil)))
#+END_SRC
   
*** SRC region templates
**** Emacs lisp
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

**** Plant uml
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("uml" "#+BEGIN_SRC plantuml\n?\n#+END_SRC"))
#+END_SRC

**** R export to image
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("ri" "#+BEGIN_SRC R :results output graphics :file RImage.png\n?\n#+END_SRC"))
#+END_SRC

** Export
TODO
ox-html5slide
org-html-themes
*** Syntax highlighting for HTML export
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'htmlize)
#+END_SRC

*** Twitter bootstrap
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'ox-twbs)
#+END_SRC

** Agenda
Give agenda file to use
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/Notes/Agenda.org")
      (setq org-agenda-files (quote ("~/Notes/Agenda.org"))))
#+END_SRC
*** Stop agenda from messing with windows
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

*** Display at startup
Spawn agenda buffer
#+BEGIN_SRC emacs-lisp
  ;;(org-agenda-list)
#+END_SRC

**** Declare switch function
Because just giving "*Org Agenda*" to "initial-buffer-choice" doesn't work
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-agenda()
    (interactive)
    (switch-to-buffer "*Org Agenda*"))
#+END_SRC

**** Run switch function as initial buffer choice
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice 'my/switch-to-agenda)
#+END_SRC

**** Close all other open windows at start
#+BEGIN_SRC emacs-lisp
  (delete-other-windows)
#+END_SRC

** Clock
#+BEGIN_SRC emacs-lisp
;;(setq org-clock-mode-line-total today)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; (define-prefix-command 'my/clock-map)
  ;; (define-key my/leader-map (kbd "c") 'my/clock-map)
;; 
  ;; (define-key my/clock-map (kbd "s") 'org-clock-in)
  ;; (define-key my/clock-map (kbd "S") 'org-clock-out)
  ;; (define-key my/clock-map (kbd "C-s") 'org-clock-in-last)
;; 
  ;; (define-key my/clock-map (kbd "e") 'org-clock-modify-effort-estimate)
#+END_SRC

** Export
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-map)
  (define-key my/org-mode-map (kbd "E") 'my/org-export-map)
#+END_SRC

*** ASCII
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-ascii-map)
  (define-key my/org-export-map (kbd "a") 'my/org-export-ascii-map)

  (define-key my/org-export-ascii-map (kbd "a") 'org-ascii-export-to-ascii)
#+END_SRC

*** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-html-map)
  (define-key my/org-export-map (kbd "h") 'my/org-export-html-map)

  (define-key my/org-export-html-map (kbd "h") 'org-html-export-to-html)
  (define-key my/org-export-html-map (kbd "t") 'org-twbs-export-to-html)
#+END_SRC

*** PDF
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-pdf-map)
  (define-key my/org-export-map (kbd "p") 'my/org-export-pdf-map)

  (define-key my/org-export-pdf-map (kbd "p") 'org-latex-export-to-pdf)
#+END_SRC

*** Beamer presentation
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-slides-map)
  (define-key my/org-export-map (kbd "s") 'my/org-export-slides-map)

  (define-key my/org-export-slides-map (kbd "b") 'org-beamer-export-to-pdf)
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-markdown-map)
  (define-key my/org-export-map (kbd "m") 'my/org-export-markdown-map)

  (define-key my/org-export-markdown-map (kbd "m") 'org-md-export-to-markdown)
#+END_SRC

*** ODT
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-odt-map)
  (define-key my/org-export-map (kbd "o") 'my/org-export-odt-map)

  (define-key my/org-export-odt-map (kbd "o") 'org-odt-export-to-odt)
#+END_SRC

*** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-latex-map)
  (define-key my/org-export-map (kbd "l") 'my/org-export-latex-map)

  (define-key my/org-export-latex-map (kbd "l") 'org-latex-export-to-latex)
#+END_SRC

** Key
#+BEGIN_SRC emacs-lisp
  ;;(evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
  (evil-define-key 'normal org-mode-map (kbd "C-s") 'swiper)

  (define-key my/org-mode-map (kbd "i") 'org-toggle-inline-images)
  (define-key my/org-mode-map (kbd "f") 'org-insert-link)
  (define-key my/org-mode-map (kbd "e") 'org-babel-execute-src-block)

  (define-key my/org-mode-map (kbd "p") 'org-shiftup)
  (define-key my/org-mode-map (kbd "n") 'org-shiftdown)
  (define-key my/org-mode-map (kbd "l") 'org-shiftright)
  (define-key my/org-mode-map (kbd "h") 'org-shiftleft)

  (define-key my/org-mode-map (kbd "P") 'org-metaup)
  (define-key my/org-mode-map (kbd "N") 'org-metadown)
  (define-key my/org-mode-map (kbd "L") 'org-metaright)
  (define-key my/org-mode-map (kbd "H") 'org-metaleft)

  (define-key my/org-mode-map (kbd "|") 'org-table-create-or-convert-from-region)

  (define-key my/org-mode-map (kbd "z") 'org-shifttab)

  (define-prefix-command 'my/org-show-mode-map)
  (define-key my/org-mode-map (kbd "s") 'my/org-show-mode-map)

  (define-key my/org-show-mode-map (kbd "l") 'org-toggle-link-display)
#+END_SRC

*** Macros
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-macros-map)
  (define-key my/org-mode-map (kbd "m") 'my/org-macros-map)
#+END_SRC

**** Org
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-org-macros-map)
  (define-key my/org-macros-map (kbd "o") 'my/org-org-macros-map)

  ;; Center text, doesn't work for all exports
  (define-key my/org-org-macros-map (kbd "c") (lambda () (interactive) (insert "#+BEGIN_CENTER") (newline) (newline) (insert "#+END_CENTER")))

  ;; Comment
  (define-key my/org-org-macros-map (kbd "C") (lambda () (interactive) (insert "#+BEGIN_COMMENT") (newline) (newline) (insert "#+END_COMMENT")))
#+END_SRC

**** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-latex-macros-map)
  (define-key my/org-macros-map (kbd "l") 'my/org-latex-macros-map)

  ;;Literal latex code for export
  (define-key my/org-latex-macros-map (kbd "i") (lambda () (interactive) (insert "#+LATEX: ")))

  ;; Header
  (define-key my/org-latex-macros-map (kbd "h") (lambda () (interactive) (insert "#+LATEX_HEADER: ")))

  ;; Newline
  (define-key my/org-latex-macros-map (kbd "RET") (lambda () (interactive) (insert "#+LATEX: \\newpage")))

  ;; Fix huge margins
  (define-key my/org-latex-macros-map (kbd "4") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage[a4paper, total={6in, 8in}]{geometry}")))

  ;; Make lists compact
  (define-key my/org-latex-macros-map (kbd "C-l") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage{enumitem}") (newline) (insert "#+LATEX_HEADER: \\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}")))
#+END_SRC

**** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-html-macros-map)
  (define-key my/org-macros-map (kbd "h") 'my/org-html-macros-map)

  ;;Literal HTML code for export
  (define-key my/org-html-macros-map (kbd "i") (lambda () (interactive) (insert "#+HTML: ")))

  ;;HTML break line
  (define-key my/org-html-macros-map (kbd "RET") (lambda () (interactive) (insert "#+HTML: <br><br />")))
#+END_SRC

* Outline
http://www.modernemacs.com/post/outline-ivy/
#+BEGIN_SRC emacs-lisp
  ;; Must be set before outline is loaded
  ;; Required by outorg
  (defvar outline-minor-mode-prefix "\M-#")

  (straight-use-package 'outline)

  (add-hook 'prog-mode-hook 'outline-minor-mode)
#+END_SRC

** Outshine
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'outshine)
  ;; (straight-use-package '(outshine :type git :host github :repo "alphapapa/outshine"))
  (require 'outshine)

  (add-hook 'outline-minor-mode-hook 'outshine-mode)

  (setq outshine-startup-folded-p nil)
#+END_SRC

** Outorg
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'outorg)
#+END_SRC

** Visuals
#+BEGIN_SRC emacs-lisp
  (setq counsel-outline-face-style nil)

  (set-face-attribute 'outshine-level-1 nil :inherit 'outline-1 :height 1.9)
  (set-face-attribute 'outshine-level-2 nil :inherit 'outline-2 :height 1.6)
  (set-face-attribute 'outshine-level-3 nil :inherit 'outline-3 :height 1.4)
  (set-face-attribute 'outshine-level-4 nil :inherit 'outline-4 :height 1.3)
  (set-face-attribute 'outshine-level-5 nil :inherit 'outline-5 :height 1.25)
  (set-face-attribute 'outshine-level-6 nil :inherit 'outline-6 :height 1.2)
  (set-face-attribute 'outshine-level-7 nil :inherit 'outline-7 :height 1.15)
  (set-face-attribute 'outshine-level-8 nil :inherit 'outline-8 :height 1.10)
#+END_SRC

** Java outline
#+BEGIN_SRC emacs-lisp
;; (setq outline-regexp "\\(?:\\([ \t]*.*\\(class\\|interface\\)[ \t]+[a-zA-Z0-9_]+[ \t\n]*\\({\\|extends\\|implements\\)\\)\\|[ \t]*\\(public\\|private\\|static\\|final\\|native\\|synchronized\\|transient\\|volatile\\|strictfp\\| \\|\t\\)*[ \t]+\\(\\([a-zA-Z0-9_]\\|\\( *\t*< *\t*\\)\\|\\( *\t*> *\t*\\)\\|\\( *\t*, *\t*\\)\\|\\( *\t*\\[ *\t*\\)\\|\\(]\\)\\)+\\)[ \t]+[a-zA-Z0-9_]+[ \t]*(\\(.*\\))[ \t]*\\(throws[ \t]+\\([a-zA-Z0-9_, \t\n]*\\)\\)?[ \t\n]*{\\)" )
#+END_SRC

** Allow indented outlines
use "^\s*" instead of "^"
#+BEGIN_SRC emacs-lisp
  (setq outline-regexp  "[*\^L]+")

  (defun outshine-chomp (str)
    "Chomp leading and trailing whitespace from STR."
    (save-excursion
      (save-match-data
        (while (string-match
                "\\`\n+\\|^\s*\\s-+\\|\\s-+$\\|\n+\\'"
                str)
          (setq str (replace-match "" t t str)))
        str)))

  (defun outshine-change-level (delta)
    "Workhorse for `outline-demote' and `outline-promote'."
    (let* ((headlist (outshine-headings-list))
           (atom (outshine-headings-atom headlist))
           (re (concat "^\s*" outline-regexp))
           (transmode (and transient-mark-mode mark-active))
           beg end)

      ;; Find the boundaries for this operation
      (save-excursion
        (if transmode
            (setq beg (min (point) (mark))
                  end (max (point) (mark)))
          (outline-back-to-heading)
          (setq beg (point))
          (outline-end-of-heading)
          (outline-end-of-subtree)
          (setq end (point)))
        (setq beg (move-marker (make-marker) beg)
              end (move-marker (make-marker) end))

        (let (head newhead level newlevel static)

          ;; First a dry run to test if there is any trouble ahead.
          (goto-char beg)
          (while (re-search-forward re end t)
            (outshine-change-heading headlist delta atom 'test))

          ;; Now really do replace the headings
          (goto-char beg)
          (while (re-search-forward re end t)
            (outshine-change-heading headlist delta atom))))))

  (defun outshine-headings-list ()
    "Return a list of relevant headings, either a user/mode defined
  list, or an alist derived from scanning the buffer."
    (let (headlist)
      (cond
       (outshine-promotion-headings
        ;; configured by the user or the mode
        (setq headlist outshine-promotion-headings))

       ((and (eq major-mode 'outline-mode) (string= outline-regexp "[*\^L]+"))
        ;; default outline mode with original regexp
        ;; this need special treatment because of the \f in the regexp
        (setq headlist '(("*" . 1) ("**" . 2))))  ; will be extrapolated

       (t ;; Check if the buffer contains a complete set of headings
        (let ((re (concat "^\s*" outline-regexp)) head level)
          (save-excursion
            (goto-char (point-min))
            (while (re-search-forward re nil t)
              (save-excursion
                (beginning-of-line 1)
                (setq head (outshine-cleanup-match (match-string 0))
                      level (funcall outline-level))
                (add-to-list  'headlist (cons head level))))))
        ;; Check for uniqueness of levels in the list
        (let* ((hl headlist) entry level seen nonunique)
          (while (setq entry (car hl))
            (setq hl (cdr hl)
                  level (cdr entry))
            (if (and (not (outshine-static-level-p level))
                     (member level seen))
                ;; We have two entries for the same level.
                (add-to-list 'nonunique level))
            (add-to-list 'seen level))
          (if nonunique
              (error "Cannot promote/demote: non-unique headings at level %s\nYou may want to configure `outline-promotion-headings'."
                     (mapconcat 'int-to-string nonunique ","))))))
      ;; OK, return the list
      headlist))

  (defun outshine-calc-outline-level ()
    "Calculate the right outline level for the
    outshine-regexp"
    (save-excursion
      ;; THIS FIXED IT
      (back-to-indentation)
      (save-match-data
        (and
         (looking-at (outshine-calc-outline-regexp))
         ;; ;; FIXME this works?
         ;; (looking-at outline-regexp)
         (let ((m-strg (match-string-no-properties 0)))
           (if outshine-enforce-no-comment-padding-p
               ;; deal with oldschool elisp headings (;;;+)
               (setq m-strg
                     (split-string
                      (substring m-strg 2)
                      nil
                      'OMIT-NULLS))
             ;; orgmode style elisp heading (;; *+)
             (setq m-strg
                   (split-string
                    m-strg
                    (format "%s" outshine-normalized-comment-start)
                    'OMIT-NULLS)))
           (length
            (mapconcat
             (lambda (str)
               (car
                (split-string
                 str
                 " "
                 'OMIT-NULLS)))
             m-strg
             "")))
         ))))

  ;; (advice-add 'outshine-calc-outline-level :before (lambda () (interactive) (back-to-indentation)))
#+END_SRC

** Allow indented outlines - outline mode
#+BEGIN_SRC emacs-lisp
  (defvar outline-font-lock-keywords
    '(
      ;; Highlight headings according to the level.
      (eval . (list (concat "^\s*\\(?:" outline-regexp "\\).+")
                    0 '(outline-font-lock-face) nil t)))
    "Additional expressions to highlight in Outline mode.")

  (define-derived-mode outline-mode text-mode "Outline"
    "Set major mode for editing outlines with selective display.
  Headings are lines which start with asterisks: one for major headings,
  two for subheadings, etc.  Lines not starting with asterisks are body lines.

  Body text or subheadings under a heading can be made temporarily
  invisible, or visible again.  Invisible lines are attached to the end
  of the heading, so they move with it, if the line is killed and yanked
  back.  A heading with text hidden under it is marked with an ellipsis (...).

  \\{outline-mode-map}
  The commands `outline-hide-subtree', `outline-show-subtree',
  `outline-show-children', `outline-hide-entry',
  `outline-show-entry', `outline-hide-leaves', and `outline-show-branches'
  are used when point is on a heading line.

  The variable `outline-regexp' can be changed to control what is a heading.
  A line is a heading if `outline-regexp' matches something at the
  beginning of the line.  The longer the match, the deeper the level.

  Turning on outline mode calls the value of `text-mode-hook' and then of
  `outline-mode-hook', if they are non-nil."
    (make-local-variable 'line-move-ignore-invisible)
    (setq line-move-ignore-invisible t)
    ;; Cause use of ellipses for invisible text.
    (add-to-invisibility-spec '(outline . t))
    (set (make-local-variable 'paragraph-start)
         (concat paragraph-start "\\|\\(?:" outline-regexp "\\)"))
    ;; Inhibit auto-filling of header lines.
    (set (make-local-variable 'auto-fill-inhibit-regexp) outline-regexp)
    (set (make-local-variable 'paragraph-separate)
         (concat paragraph-separate "\\|\\(?:" outline-regexp "\\)"))
    (set (make-local-variable 'font-lock-defaults)
         '(outline-font-lock-keywords t nil nil backward-paragraph))
    (setq imenu-generic-expression
          (list (list nil (concat "^\s*\\(?:" outline-regexp "\\).*$") 0)))
    (add-hook 'change-major-mode-hook 'outline-show-all nil t))

  (defun outline-next-heading ()
    "Move to the next (possibly invisible) heading line."
    (interactive)
    ;; Make sure we don't match the heading we're at.
    (if (and (bolp) (not (eobp))) (forward-char 1))
    (if (re-search-forward (concat "^\s*\\(?:" outline-regexp "\\)")
                           nil 'move)
        (goto-char (match-beginning 0))))


  (defun outline-previous-heading ()
    "Move to the previous (possibly invisible) heading line."
    (interactive)
    (re-search-backward (concat "^\s*\\(?:" outline-regexp "\\)")
                        nil 'move))

  (defun outline-back-to-heading (&optional invisible-ok)
    (interactive)
    "Move to previous heading line, or beg of this line if it's a heading.
  Only visible heading lines are considered, unless INVISIBLE-OK is non-nil."
    (beginning-of-line)
    ;; Hack, doesn't work otherwise
    ;;(next-line)
    (or (outline-on-heading-p invisible-ok)
        (let (found)
          (save-excursion
            (while (not found)
              (or (progn
                    (back-to-indentation)
                    (let ((result (looking-at outline-regexp)))
                      (beginning-of-line)
                      result))
                  (re-search-backward (concat "^\s*\\(?:" outline-regexp "\\)")
                                      nil t)
                  (error "Before first heading"))
              (setq found (and (or invisible-ok (not (outline-invisible-p)))
                               (point)))))
          (goto-char found)
          (back-to-indentation)
          found)))

  (defun outline-map-region (fun beg end)
    "Call FUN for every heading between BEG and END.
  When FUN is called, point is at the beginning of the heading and
  the match data is set appropriately."
    (save-excursion
      (setq end (copy-marker end))
      (goto-char beg)
      (when (re-search-forward (concat "^\s*\\(?:" outline-regexp "\\)") end t)
        (goto-char (match-beginning 0))
        (funcall fun)
        (while (and (progn
                      (outline-next-heading)
                      (< (point) end))
                    (not (eobp)))
          (funcall fun)))))

  (defun outline-next-visible-heading (arg)
    "Move to the next visible heading line.
  With ARG, repeats or can move backward if negative.
  A heading line is one that starts with a `*' (or that
  `outline-regexp' matches)."
    (interactive "p")
    (if (< arg 0)
        (beginning-of-line)
      (end-of-line))
    (let (found-heading-p)
      (while (and (not (bobp)) (< arg 0))
        (while (and (not (bobp))
                    (setq found-heading-p
                          (re-search-backward
                           (concat "^\s*\\(?:" outline-regexp "\\)")
                           nil 'move))
                    (outline-invisible-p)))
        (setq arg (1+ arg)))
      (while (and (not (eobp)) (> arg 0))
        (while (and (not (eobp))
                    (setq found-heading-p
                          (re-search-forward
                           (concat "^\s*\\(?:" outline-regexp "\\)")
                           nil 'move))
                    (outline-invisible-p (match-beginning 0))))
        (setq arg (1- arg)))
      (if found-heading-p (beginning-of-line))))

  ;; Fixes `(outline-next-preface)' used in `(outline-hide-body)'
  (defun outline-next-preface ()
    "Skip forward to just before the next heading line.
  If there's no following heading line, stop before the newline
  at the end of the buffer."
    (if (re-search-forward (concat "\n\s*\\(?:" outline-regexp "\\)")
                           nil 'move)
        (goto-char (match-beginning 0)))
    (if (and (bolp) (or outline-blank-line (eobp)) (not (bobp)))
        (forward-char -1)))
#+END_SRC

** Fix counsel-outline
#+BEGIN_SRC emacs-lisp
  (defun counsel-outline-candidates (&optional settings)
    "Return an alist of outline heading completion candidates.
  Each element is a pair (HEADING . MARKER), where the string
  HEADING is located at the position of MARKER.  SETTINGS is a
  plist entry from `counsel-outline-settings', which see."
    (let ((bol-regex (concat "^\s*\\(?:"
                             (or (plist-get settings :outline-regexp)
                                 outline-regexp)
                             "\\)"))
          (outline-title-fn (or (plist-get settings :outline-title)
                                #'counsel-outline-title))
          (outline-level-fn (or (plist-get settings :outline-level)
                                outline-level))
          (display-style (or (plist-get settings :display-style)
                             counsel-outline-display-style))
          (path-separator (or (plist-get settings :path-separator)
                              counsel-outline-path-separator))
          (face-style (or (plist-get settings :face-style)
                          counsel-outline-face-style))
          (custom-faces (or (plist-get settings :custom-faces)
                            counsel-outline-custom-faces))
          (stack-level 0)
          (orig-point (point))
          cands name level marker stack)
      (save-excursion
        (setq counsel-outline--preselect 0)
        (goto-char (point-min))
        (while (re-search-forward bol-regex nil t)
          (save-excursion
            (setq name (or (save-match-data
                             (funcall outline-title-fn))
                           ""))
            (goto-char (match-beginning 0))
            (setq marker (point-marker))
            (setq level (funcall outline-level-fn))
            (cond ((eq display-style 'path)
                   ;; Update stack.  The empty entry guards against incorrect
                   ;; headline hierarchies, e.g. a level 3 headline
                   ;; immediately following a level 1 entry.
                   (while (<= level stack-level)
                     (pop stack)
                     (cl-decf stack-level))
                   (while (> level stack-level)
                     (push "" stack)
                     (cl-incf stack-level))
                   (setf (car stack)
                         (counsel-outline--add-face
                          name level face-style custom-faces))
                   (setq name (mapconcat #'identity
                                         (reverse stack)
                                         path-separator)))
                  (t
                   (when (eq display-style 'headline)
                     (setq name (concat (make-string level ?*) " " name)))
                   (setq name (counsel-outline--add-face
                               name level face-style custom-faces))))
            (push (cons name marker) cands))
          (unless (or (string= name "")
                      (< orig-point marker))
            (cl-incf counsel-outline--preselect))))
      (nreverse cands)))
#+END_SRC

** Outline bullets
http://www.modernemacs.com/post/outline-ivy/
http://www.modernemacs.com/post/outline-bullets/
https://github.com/ekaschalk/.spacemacs.d/blob/master/layers/display/local/pretty-outlines/pretty-outlines.el
https://github.com/ekaschalk/.spacemacs.d/tree/master/layers/display
#+BEGIN_SRC emacs-lisp
  (defmacro with-face (STR &rest PROPS)
    "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

  (defvar pretty-outlines-bullets-bullet-list org-bullets-bullet-list
    "An implemention of `org-bullets-bullet-list' for outlines.")

  (defvar-local pretty-outlines-buffer-font-lock-keyword nil)

  (defun pretty-outlines--add-font-locks (font-lock-alist)
    "Put text property for FONT-LOCK-ALIST for var-width replacements."
    (setq pretty-outlines-buffer-font-lock-keyword
          (-map (-lambda ((rgx outline-str))
                  `(,rgx (0 (prog1 nil
                              (put-text-property (match-beginning 1) (match-end 1)
                                                 'display ,outline-str)))))
                font-lock-alist))
    (font-lock-add-keywords nil pretty-outlines-buffer-font-lock-keyword))

  (defun pretty-outlines-remove-font-locks ()
    (interactive)
    (font-lock-remove-keywords nil pretty-outlines-buffer-font-lock-keyword))

  (defun pretty-outlines--bullets-rgx-at-level (level)
    "Calculate regex or outline-bullets at LEVEL."
    ;; In buffers like org, `outshine-calc-outline-string-at-level 1' always returns "  ", check for this
    (if (not (string= (s-trim (outshine-calc-outline-string-at-level 1)) ""))
        (concat "\\(^\s*"
                (->> level
                     1+
                     outshine-calc-outline-string-at-level
                     s-trim-right
                     (s-replace "*" "\\*"))
                "\\) ")))

  (defun pretty-outlines--propertize-bullet (level bullet)
    "Add LEVEL-dependent face to BULLET."
    (with-face bullet
               (pcase level
                 (0 '(:inherit outline-1 :underline nil :height 1.9))
                 (1 '(:inherit outline-2 :underline nil :height 1.6))
                 (2 '(:inherit outline-3 :underline nil :height 1.4))
                 (3 '(:inherit outline-4 :underline nil :height 1.3))
                 (4 '(:inherit outline-5 :underline nil :height 1.25))
                 (5 '(:inherit outline-6 :underline nil :height 1.2))
                 (6 '(:inherit outline-7 :underline nil :height 1.15))
                 (7 '(:inherit outline-8 :underline nil :height 1.10))
                 (_ nil))))

  (defun pretty-outlines--bullets-cycle ()
    "Cycle through `pretty-outlines-bullets-bullet-list'"
    (-let [max-outline-depth 8]
      (->> pretty-outlines-bullets-bullet-list -cycle (-take max-outline-depth))))

  (defun pretty-outlines--format-bullet (level bullet)
    "Propertize and perform all other styling for BULLET at LEVEL."
    (concat (s-repeat level " ")
            (pretty-outlines--propertize-bullet level bullet)))

  (defun pretty-outlines-add-bullets ()
    "Use with `add-hook' to enable pretty-outlines-bullets-bullet-list for mode."
    (interactive)
    ;; Not sure why, but org mode headers are small otherwise
    (if (not (string= major-mode "org-mode"))
        (->>
         (pretty-outlines--bullets-cycle)
         (-map-indexed (-lambda (level bullet)
                         (list (pretty-outlines--bullets-rgx-at-level level)
                               (pretty-outlines--format-bullet level bullet))))
         pretty-outlines--add-font-locks)))

  (add-hook 'outline-mode-hook 'pretty-outlines-add-bullets t)
  (add-hook 'outline-minor-mode-hook 'pretty-outlines-add-bullets t)
#+END_SRC

** Outline ellipsis
#+BEGIN_SRC emacs-lisp
  (defvar outline-display-table (make-display-table))
  (set-display-table-slot outline-display-table 'selective-display
                          (vector (make-glyph-code my/fold-ellipsis-char 'escape-glyph)))
  (defun set-outline-display-table ()
    (setf buffer-display-table outline-display-table))

  (add-hook 'outline-mode-hook 'set-outline-display-table)
  (add-hook 'outline-minor-mode-hook 'set-outline-display-table)
#+END_SRC

** Narrowing
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/narrow-map)
  (define-key my/leader-map (kbd "n") 'my/narrow-map)

  (define-key my/narrow-map (kbd "w") 'widen)
  (define-key my/narrow-map (kbd "r") 'narrow-to-region)

  (define-key my/narrow-map (kbd "p") 'narrow-to-page)
  (define-key my/narrow-map (kbd "d") 'narrow-to-defun)
#+END_SRC

** Folding
*** Origami
#+BEGIN_SRC emacs-lisp
   (straight-use-package 'origami)

   (global-origami-mode)
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
  (setq origami-fold-replacement my/fold-ellipsis)
#+END_SRC

*** Keys
Vim bindings to change fold
#+BEGIN_SRC emacs-lisp
  (define-key evil-motion-state-map (kbd "g N") 'origami-forward-fold)
  (define-key evil-motion-state-map (kbd "g P") 'origami-previous-fold)

  (define-key evil-motion-state-map (kbd "g C-o") 'origami-open-node)
  (define-key evil-motion-state-map (kbd "g C-h") 'origami-close-node)

  (define-key evil-motion-state-map (kbd "g M-o") 'origami-open-all-nodes)
  (define-key evil-motion-state-map (kbd "g M-h") 'origami-close-all-nodes)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
    (defun my/outline-hide-all-body ()
      (interactive)
      (outline-show-all)
      (outline-hide-body))

  (my/evil-normal-define-key "ga" 'my/outline-hide-all-body)
  (my/evil-normal-define-key "gA" 'outline-show-all)

  (my/evil-normal-define-key "go" 'evil-open-fold)
  (my/evil-normal-define-key "gO" 'evil-open-fold-rec)

  (my/evil-normal-define-key "gh" 'evil-close-fold)
  (my/evil-normal-define-key "gH" '(lambda () (interactive) (hide-sublevels 1)))

  (defvar-local buffer-has-outline-bullets t)
  (defun my/toggle-outline-bullets ()
    (interactive)
    (if (not (string= major-mode "org-mode"))
        (progn
          (if buffer-has-outline-bullets
              (progn
                (setq buffer-has-outline-bullets nil)
                (pretty-outlines-remove-font-locks))
            (setq buffer-has-outline-bullets t)
            (pretty-outlines-add-bullets))

          ;; Completely refresh font-lock
          (set-text-properties (point-min) (point-max) nil))))

  (define-key my/leader-map (kbd "C-h") 'my/toggle-outline-bullets)
#+END_SRC

* Completion
** Ivy
#+BEGIN_SRC emacs-lisp
    (straight-use-package 'ivy)

    (ivy-mode 1)

    ;; Buffer history
  ;;  (setq ivy-use-virtual-buffers t)
    (setq ivy-use-virtual-buffers nil)

    ;; Allows calling new minibuffer commands while in the minibuffer. So for example C-s M-x works
    (setq enable-recursive-minibuffers t)

    ;; Make user intput selectable
    (setq ivy-use-selectable-prompt t)

    ;;Disable fuzzy search for swiper
    ;;(setq ivy-re-builders-alist
    ;;      '((swiper . ivy--regex-plus)
    ;;       (t      . ivy--regex-fuzzy)))
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
  ;; Height of minibuffer
  ;; (setq ivy-height 10)

  ;; Highlight whole row in minibuffer
  (setq ivy-format-function 'ivy-format-function-line)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (defun my/ivy-top ()
  (interactive)
  (ivy-previous-line ivy--length))

  (defun my/ivy-bot ()
    (interactive)
    (ivy-next-line ivy--length))

  (setq ivy-minibuffer-map (make-sparse-keymap))

  ;; Enable avy movements in ivy buffer
  (evil-define-key 'normal ivy-minibuffer-map (kbd "M-n") 'ivy-avy)
  (evil-define-key 'normal ivy-minibuffer-map (kbd "M-p") 'ivy-avy)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "G") 'my/ivy-bot)
  (evil-define-key 'normal ivy-minibuffer-map (kbd "g g") 'my/ivy-top)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "n") 'ivy-next-line)
  (evil-define-key 'normal ivy-minibuffer-map (kbd "p") 'ivy-previous-line)

  (define-key ivy-minibuffer-map [remap evil-ret] 'ivy-done)
  (define-key ivy-minibuffer-map [remap newline] 'ivy-done)

  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-n") 'ivy-next-line)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-p") 'ivy-previous-line)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-g") 'minibuffer-keyboard-quit)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-g") 'minibuffer-keyboard-quit)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-u") 'ivy-scroll-down-command)
  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-w") 'ivy-scroll-up-command)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-u") 'ivy-scroll-down-command)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-w") 'ivy-scroll-up-command)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-o") 'ivy-occur)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-o") 'ivy-occur)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-h") 'ivy-dispatching-done)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-h") 'ivy-dispatching-done)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "C-s") 'ivy-next-line-or-history)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "C-s") 'ivy-next-line-or-history)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "TAB") 'ivy-partial-or-done)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "TAB") 'ivy-partial-or-done)

  (evil-define-key 'normal ivy-minibuffer-map (kbd "DEL") 'ivy-backward-delete-char)
  (evil-define-key 'insert ivy-minibuffer-map (kbd "DEL") 'ivy-backward-delete-char)
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'counsel)

  (counsel-mode 1)

  ;;(setq-default counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
  (setq counsel-grep-base-command "grep -i -E -n -e %s %s")
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-find-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)

  (global-set-key (kbd "M-k") 'counsel-yank-pop)

  (define-key my/help-map (kbd "C-c") 'counsel-colors-emacs)
  (define-key my/help-map (kbd "C") 'counsel-colors-web)

  (define-key my/leader-map (kbd "S") 'counsel-imenu)
  (define-key my/leader-map (kbd "h") 'counsel-outline)
#+END_SRC

** Counsel flycheck
  https://github.com/nathankot/dotemacs/blob/master/init.el
#+BEGIN_SRC emacs-lisp

  (defvar counsel-flycheck-history nil
    "History for `counsel-flycheck'")

  (defun counsel-flycheck ()
    (interactive)
    (if (not (bound-and-true-p flycheck-mode))
        (message "Flycheck mode is not available or enabled")
      (ivy-read "Error: "
                (let ((source-buffer (current-buffer)))
                  (with-current-buffer (or (get-buffer flycheck-error-list-buffer)
                                          (progn
                                            (with-current-buffer
                                                (get-buffer-create flycheck-error-list-buffer)
                                              (flycheck-error-list-mode)
                                              (current-buffer))))
                    (flycheck-error-list-set-source source-buffer)
                    (flycheck-error-list-reset-filter)
                    (revert-buffer t t t)
                    (split-string (buffer-string) "\n" t " *")))
                :action (lambda (s &rest _)
                          (-when-let* ( (error (get-text-property 0 'tabulated-list-id s))
                                        (pos (flycheck-error-pos error)) )
                            (goto-char (flycheck-error-pos error))))
                :history 'counsel-flycheck-history)))

  (define-key my/leader-map (kbd "J") 'counsel-flycheck)
#+END_SRC

** Swiper 
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'swiper)

  (defun my/use-swiper-or-grep(&optional input case-sensative)
    (interactive)
    (swiper input))
    ;;(if (and buffer-file-name (not (bound-and-true-p org-src-mode)) (not (string= "gz" (file-name-extension buffer-file-name))))
        ;;(counsel-grep input)
      ;;(swiper input)))

  ;; Checks for if case sensative search
  ;; (if case-sensative
  ;; (setq counsel-grep-base-command "grep -E -n -e %s %s")
  ;; (setq-default counsel-grep-base-command "grep -i -E -n -e %s %s"))

  (global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
  (global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
  (global-set-key (kbd "M-s") 'swiper-all)
  ;;(global-set-key (kbd "M-s") (lambda () (interactive) (my/use-swiper-or-grep nil t)))

  ;;  (setq swiper-use-visual-line t)
#+END_SRC

*** Search for thing-at-point
#+BEGIN_SRC emacs-lisp
  (defun my/swiper-thing-at-point ()
    "jump to word under cursor"
    (interactive)
    (my/use-swiper-or-grep (thing-at-point 'evil-WORD)))

    (my/evil-normal-define-key "#" 'my/swiper-thing-at-point)
    (my/evil-normal-define-key "*" 'my/swiper-thing-at-point)
#+END_SRC

** Ivy rich
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'ivy-rich)
  (require 'ivy-rich)
  (ivy-rich-mode 1)

  ;;(ivy-set-display-transformer 'ivy-switch-buffer 'ivy-switch-buffer)
  ;;(setq ivy-rich-path-style 'abbrev)
  '(ivy-switch-buffer
  (:columns
   ((ivy-rich-candidate (:width 30))  ; return the candidate itself
    (ivy-rich-switch-buffer-size (:width 7))  ; return the buffer size
    (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
    (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
    (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
    (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
   :predicate
   (lambda (cand) (get-buffer cand)))
  counsel-M-x
  (:columns
   ((counsel-M-x-transformer (:width 40))  ; thr original transfomer
    (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the command
  counsel-describe-function
  (:columns
   ((counsel-describe-function-transformer (:width 40))  ; the original transformer
    (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the function
  counsel-describe-variable
  (:columns
   ((counsel-describe-variable-transformer (:width 40))  ; the original transformer
    (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))  ; return the docstring of the variable
  counsel-recentf
  (:columns
   ((ivy-rich-candidate (:width 0.8)) ; return the candidate itself
    (ivy-rich-file-last-modified-time (:face font-lock-comment-face))))) ; return the last modified time of the file
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'company)
  (require 'company)

  (setq company-idle-delay 0)
  (setq company-echo-delay 0)

  ;; Don't downcase result
  (setq company-dabbbrev-downcase nil)

  ;; Make tooltim margin minimal
  (setq company-tooltip-margin 2)

  ;; Start searching for candidates when 2 letters has been written
  (setq company-minimum-prefix-length 2)

  (add-to-list 'company-transformers 'company-sort-prefer-same-case-prefix)

  (setq company-show-numbers t)

  ;; Make sure only 10 candidates are shown at a time
  (setq company-tooltip-limit 10)

  ;; Align annotations to right side
  (setq company-tooltip-align-annotations t)

  ;; Makes it possible to exit company without a candidate selected
  (setq company-require-match nil)

  ;; Enable scrollbar
  (setq company-tooltip-offset-display 'scrollbar) ;;'line

  (global-company-mode t)

  ;; Remove dabbrev because evil has a better alternative and dabbrev is slow with long files
  (setq company-backends (delete 'company-dabbrev company-backends))
#+END_SRC

*** Company doc buffer
Company doc mode disables visual line mode for whatever reason, enable it inside this redefinition of company-show-doc-buffer
#+BEGIN_SRC emacs-lisp
  (defun my/company-show-doc-buffer ()
    "Temporarily show the documentation buffer for the selection."
    (interactive)
    (let (other-window-scroll-buffer)
      (company--electric-do
        (let* ((selected (nth company-selection company-candidates))
               (doc-buffer (or (company-call-backend 'doc-buffer selected)
                               (user-error "No documentation available")))
               start)
          (with-current-buffer doc-buffer
            (setq truncate-lines nil))
          (when (consp doc-buffer)
            (setq start (cdr doc-buffer)
                  doc-buffer (car doc-buffer)))
          (setq other-window-scroll-buffer (get-buffer doc-buffer))
          (let ((win (display-buffer doc-buffer t)))
            (set-window-start win (if start start (point-min))))))))

  (define-key company-active-map (kbd "C-h") 'my/company-show-doc-buffer)

  (defun my/company-show-doc-buffer-keep-open ()
    "Temporarily show the documentation buffer for the selection."
    (interactive)
    (let (other-window-scroll-buffer)
      (let* ((selected (nth company-selection company-candidates))
             (doc-buffer (or (company-call-backend 'doc-buffer selected)
                             (user-error "No documentation available")))
             start)
        (with-current-buffer doc-buffer
          (setq truncate-lines nil))
        (when (consp doc-buffer)
          (setq start (cdr doc-buffer)
                doc-buffer (car doc-buffer)))
        (setq other-window-scroll-buffer (get-buffer doc-buffer))
        (let ((win (display-buffer doc-buffer t)))
          (set-window-start win (if start start (point-min)))))))

  (define-key company-active-map (kbd "M-h") 'my/company-show-doc-buffer-keep-open)
#+END_SRC

*** Company-show-numbers but with letters
Need to implement
Letters, etc for autocomplete
line 2769, might also need to change more lines due to "company show numbers" being at a few more places
#+BEGIN_SRC emacs-lisp
;;  (setq right (concat (format " %s" (nth numbered '(a s d f g h j k l i r))) right)))

#+END_SRC

**** Find function that gets hotkey
name "company-complete-number"

*** Disable quickhelp for good
fsharp mode auto-enables quickhelp by default, disable it
#+BEGIN_SRC emacs-lisp
  (setq company-quickhelp-delay nil)
#+END_SRC

*** Visuals
Make company mode inherit colors from theme, change later maybe
#+BEGIN_SRC emacs-lisp
  (require 'color)

  ;; Compatibility with 16 color terminals
  (if (not (string= (face-attribute 'default :background) "unspecified-bg"))
      (let* ((my/background-color (face-attribute 'default :background)))
        (set-face-attribute 'company-scrollbar-bg nil :background (color-lighten-name my/background-color 10))
        (set-face-attribute 'company-scrollbar-fg nil :background (color-lighten-name my/background-color 5))

        ;; Selected entry
        (set-face-attribute 'company-tooltip-selection nil :background (face-attribute 'font-lock-function-name-face :background) :foreground  (face-attribute 'font-lock-function-name-face :foreground))
        ;; All unmatching text
        (set-face-attribute 'company-tooltip nil :foreground (face-attribute 'default :foreground) :background (color-lighten-name my/background-color 10))
        ;; All matching text
        (set-face-attribute 'company-tooltip-common nil :foreground (face-attribute 'font-lock-constant-face :foreground) :background (face-attribute 'font-lock-constant-face :background)))
    (set-face-attribute 'company-scrollbar-bg nil :background "black")
    (set-face-attribute 'company-scrollbar-fg nil :background "white")

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background "black" :foreground "red")
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground "white" :background "black")
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground "orange" :background "black"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)

  (define-key company-active-map (kbd "C-u") 'company-previous-page)
  (define-key company-active-map (kbd "C-w") 'company-next-page)

  ;; using C-h is better in every way 
  (define-key company-active-map (kbd "<f1>") 'nil)

  ;; Force autocomplete
  (my/evil-universal-define-key "C-." 'company-complete)
#+END_SRC


** Company-box
Company with icons
Doesn't work with my setup right now
#+BEGIN_SRC emacs-lisp
;;(when window-system
;;  (straight-use-package 'company-box)
;;
;;  (add-hook 'company-mode-hook 'company-box-mode)
;;
;;  ;;(setq company-box-minimum-width 100)
;;  ;;(setq company-box--height 500)
;;  ;;(setq company-tooltip-minimum 10)
;;
;;  (remove-hook 'company-box-selection-hook 'company-box-doc)
;;  (remove-hook 'company-box-hide-hook 'company-box-doc--hide))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'flycheck)

  ;; Use new buffer if message is longer than 1 line, can't get it to expand the minibuffer instead
  (setq max-mini-window-height 1)

  ;; Decrease delay
  (setq flycheck-display-errors-delay 0.1)

  (global-flycheck-mode)
#+END_SRC

*** Flycheck inline
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'flycheck-inline)

  (require 'flycheck-inline)

  (with-eval-after-load 'flycheck
    (add-hook 'flycheck-mode-hook #'turn-on-flycheck-inline))
#+END_SRC

*** Flycheck-package
Flycheck with extra correction for elisp packages
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'which-key)

  (which-key-mode)

  (setq which-key-idle-delay 1)

  (if window-system
      (progn
        (set-face-attribute 'which-key-command-description-face nil :family my/mono-font)
        (set-face-attribute 'which-key-docstring-face nil :family my/mono-font)
        (set-face-attribute 'which-key-group-description-face nil :family my/mono-font)
        (set-face-attribute 'which-key-highlighted-command-face nil :family my/mono-font)
        (set-face-attribute 'which-key-key-face nil :family my/mono-font)
        (set-face-attribute 'which-key-local-map-description-face nil :family my/mono-font)
        (set-face-attribute 'which-key-note-face nil :family my/mono-font)
        (set-face-attribute 'which-key-separator-face nil :family my/mono-font)
        (set-face-attribute 'which-key-special-key-face nil :family my/mono-font)))
#+END_SRC

*** Bind
#+BEGIN_SRC emacs-lisp
  (define-key my/help-map (kbd "m") 'which-key-show-major-mode)
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'yasnippet)
  (require 'yasnippet)

  (straight-use-package 'yasnippet-snippets)

  ;;(yas-reload-all)

  (add-hook 'prog-mode-hook 'yas-minor-mode-on)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "i") 'yas-insert-snippet)

  (define-key my/help-map (kbd "y") 'yas-describe-tables)
#+END_SRC

* Movement
** Goto middle of line
#+BEGIN_SRC emacs-lisp
  (defun my/go-to-middle-of-line ()
    (interactive)
    (goto-char (/  (+ (line-end-position) (line-beginning-position)) 2)))

(my/evil-normal-define-key "^" 'my/go-to-middle-of-line)
#+END_SRC

** Marks
#+BEGIN_SRC emacs-lisp
  (setq mark-ring-max 100)

  (defvar my/current-mark 0)
  (defvar my/current-mark-reference nil)

  (defun my/reset-current-marks-if-mark-ring-change ()
    (if (and my/current-mark-reference (ignore-errors (= my/current-mark-reference (car mark-ring))))
        nil
      ;; Reset all mark counters
      (setq my/current-mark-reference (car mark-ring))
      (setq my/current-mark 0)
      ;;(push-mark)
      t))

  (defun my/mark-move (jump-distance)
    "Moves between marks"
    (interactive)
    (or mark-ring
        (error "No mark set"))
    (or (my/reset-current-marks-if-mark-ring-change)
        (setq my/current-mark
              (if (and (>= (+ my/current-mark jump-distance) 0) (< (+ my/current-mark jump-distance) (length mark-ring)))
                  (+ my/current-mark jump-distance)
                my/current-mark)))
    (let* ((marker (nth my/current-mark mark-ring))
           (position (marker-position marker)))
      ;; (if (and (= my/current-mark 1) (not (= position (point))))
      ;; (progn (push-mark)
      ;; (setq my/current-mark-reference (car mark-ring))))
      (message (concat "At mark: " (number-to-string my/current-mark)))
      (or (and (>= position (point-min))
               (<= position (point-max)))
          (if widen-automatically
              (widen)
            (error "Global mark position is outside accessible part of buffer")))
      (goto-char position)))

(my/evil-normal-define-key "C-b" '(lambda () (interactive) (my/mark-move 1)))
(my/evil-normal-define-key "C-f" '(lambda () (interactive) (my/mark-move -1)))

  ;; (define-key my/keys-mode-map (kbd "M-h") 'previous-buffer)
  ;; (define-key my/keys-mode-map (kbd "M-l") 'next-buffer)
#+END_SRC

** Relative line numbers
#+BEGIN_SRC emacs-lisp
  (when (version<= "26.0.50" emacs-version )
    (global-display-line-numbers-mode)

    (setq display-line-numbers-type 'relative)
    (setq-default display-line-numbers-type 'relative)
    (setq display-line-numbers-current-absolute nil)
    (setq-default display-line-numbers-current-absolute nil)

    ;; Fixes org headings not 
    ;;(add-hook 'org-mode-hook (lambda ()(interactive) (setq-local display-line-numbers-type 'visual)))
    (add-hook 'outline-mode-hook (lambda ()(interactive) (setq-local display-line-numbers-type 'visual)))
    (add-hook 'outline-minor-mode-hook (lambda ()(interactive) (setq-local display-line-numbers-type 'visual)))

    (if window-system
        (progn
          (set-face-attribute 'line-number-current-line nil :family my/mono-font)
          (set-face-attribute 'line-number nil :family my/mono-font))))
#+END_SRC

** Avy
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'avy)
  (require 'avy)

  (setq avy-keys '(
                   ;; Easy
                   ?a ?n ?e ?t ?o ?s ?h ?d ?i ?r
                   ;; Med
                   ?g ?m ?l ?w ?y ?f ?u ?b ?x ?c ?v ?k ?p ?, ?.
                   ;; Hard
                   ?q ?\; ?j ?\/ ?z

                   ;; Shifted

                   ;; Easy
                   ?A ?N ?E ?T ?O ?S ?H ?D
                   ;; Med
                   ?R ?I ?G ?M ?L ?W ?Y ?F ?U ?B ?X ?C ?V ?K ?P
                   ;; Hard
                   ?Q ?\: ?J ?\? ?Z

                   ;; Digits
                   ?7 ?4 ?8 ?3 ?9 ?2 ?0 ?1
                   ))

  ;; Disable highlighting when avy is used. Doesn't work on 16 color terminals
  (if window-system (setq avy-background t))
#+END_SRC

*** Avy-goto-line
**** Above
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-above-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-above 2 t)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

**** Below
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-below-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-below 2)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

*** Avy-goto-word
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-word-0-in-line(&optional arg)
    (interactive "p")

    (if (not (eq evil-state 'visual))
        (my/evil-normal-state arg))

    (avy-goto-subword-0 t nil (line-beginning-position) (line-end-position)))
#+END_SRC

** Avy flycheck
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'avy-flycheck)

  (define-key my/leader-map (kbd "j") 'avy-flycheck-goto-error)
#+END_SRC

** Link-hint
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'link-hint)
#+END_SRC

** Scroll
#+BEGIN_SRC emacs-lisp
  (my/evil-universal-define-key "C-u" 'evil-scroll-up)
  (my/evil-universal-define-key "C-w" 'evil-scroll-down)
#+END_SRC

*** On-screen
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'on-screen)
  ;; (on-screen-global-mode)
  ;; (setq on-screen-highlight-method 'fringe)
#+END_SRC

** Jammer
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'jammer)
;; 
  ;; (setq jammer-repeat-delay 0.5)
  ;; (setq jammer-repeat-window 1)
;; 
  ;; (setq jammer-type 'repeat)
  ;; (setq jammer-block-type 'blacklist)
  ;; (setq jammer-block-list '(
                            ;; ;; Backward/forward
                            ;; evil-backward-char evil-forward-char evil-previous-line evil-next-line previous-line next-line
                            ;; ;; Dired
                            ;; dired-next-line dired-previous-line
;; 
;; 
;; 
                            ;; ;; word movements
                            ;; evil-forward-word evil-forward-word-begin evil-forward-word-end evil-backward-word-begin
;; 
                            ;; ;; WORD movements
                            ;; evil-forward-WORD evil-forward-WORD-begin evil-forward-WORD-end evil-backward-WORD-begin
;; 
                            ;; evil-backward-word-begin evil-backward-word-end))
  ;; (jammer-mode)
#+END_SRC

** goto change
g-; and g-,
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'goto-chg)
#+END_SRC

** My find file
#+BEGIN_SRC emacs-lisp
  (defun my/find-file ()
    (interactive)
    (find-file (let ((dir (ignore-errors (dired-current-directory))))
                 (if dir 
                     (read-file-name "Find file: " dir)
                   (read-file-name "Find file: " default-directory)))))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "M-f" 'avy-goto-char-in-line)
    (define-key my/leader-map (kbd "f") 'avy-goto-char-in-line)

  (my/evil-normal-define-key "M-w" 'my/avy-goto-word-0-in-line)
    (define-key my/leader-map (kbd "w") 'my/avy-goto-word-0-in-line)

  (my/evil-normal-define-key "M-g" 'avy-goto-char-2)
    (define-key my/leader-map (kbd "g") 'avy-goto-char-2)

  (my/evil-normal-define-key "M-g" 'avy-goto-char-2)
    (define-key my/leader-map (kbd "g") 'avy-goto-char-2)

  (my/evil-normal-define-key "M-n" 'avy-goto-word-0-below)
    (define-key evil-normal-state-map (kbd "M-p") 'avy-goto-word-0-above)

    ;; (define-key my/leader-map (kbd "n") 'my/avy-goto-line-below-keep-horizontal-position)
    ;; (define-key my/leader-map (kbd "p") 'my/avy-goto-line-above-keep-horizontal-position)

    ;;(define-key my/keys-mode-map (kbd "M-l") 'link-hint-open-link)
    (define-key my/leader-map (kbd "l") 'link-hint-open-link)
    ;;(define-key my/keys-mode-map (kbd "M-???") 'link-hint-copy-link)
#+END_SRC

* Bookmark management 
#+BEGIN_SRC emacs-lisp
  (defun my/select-bookmark (message)
    (ivy-read message (bookmark-all-names)))

  (defun my/add-bookmark ()
    (interactive)
    (bookmark-set (my/select-bookmark "Add bookmark ")))

  (defun my/delete-bookmark ()
    (interactive)
    (bookmark-delete (my/select-bookmark "Delete bookmark ")))

  ;; doesn't work
  ;; (defun my/load-bookmark-file ()
  ;; (interactive)
  ;; (bookmark-load (ivy-read "load bookmark file " nil)))
#+END_SRC

* Window management
#+BEGIN_SRC emacs-lisp
  (defvar my/window-config-name-changed-hook nil
    "Hook called after user has loaded a window configuration")

  (defvar my/window-configurations nil)
  (defvar my/current-window-configuration "None")

  (defun my/get-window-config-names ()
    (mapcar #'car my/window-configurations))

  (defun my/select-window-config (message)
    (ivy-read message (my/get-window-config-names)))

  (defun my/get-selected-window-config-position (selected-config)
    (cl-position selected-config (my/get-window-config-names) :test 'string=))

  (defun my/update-current-window-config ()
    (setq my/current-window-configuration my/selected-window-config)
    (run-hooks 'my/window-config-name-changed-hook))

  (defun my/add-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Add window config "))

    (setq my/selected-window-config-position (my/get-selected-window-config-position my/selected-window-config))

    (if (eq my/selected-window-config-position nil)
        (push (list my/selected-window-config (current-window-configuration)) my/window-configurations)
      (setf (nth my/selected-window-config-position my/window-configurations) (list my/selected-window-config (current-window-configuration))))

    (my/update-current-window-config))

  (defun my/load-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Load window config "))
    (set-window-configuration (nth 1 (nth (my/get-selected-window-config-position my/selected-window-config) my/window-configurations)))

    (my/update-current-window-config))

  (defun my/delete-window-config ()
    (interactive)
    (setq my/window-configurations (delete (nth (my/get-selected-window-config-position (my/select-window-config "Delete window config ")) my/window-configurations) my/window-configurations)))
#+END_SRC

** Switch to minibuffer
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (progn
          (if (string= major-mode "minibuffer-inactive-mode")
              (progn
                (message "HERE")
                (select-window (previous-window)))
            (select-window (active-minibuffer-window))))
      (error "Minibuffer is not active")))

  (define-key my/keys-mode-map (kbd "M-TAB") 'my/toggle-switch-to-minibuffer)
  (my/evil-universal-define-key "M-TAB" 'my/toggle-switch-to-minibuffer)
#+END_SRC

* Window and buffer settings
** Delete other windows
#+BEGIN_SRC emacs-lisp
  (defun my/delete-other-windows()
    (interactive)
    (delete-other-windows)
    (my/lv-line-create)
    (run-hooks 'my/switch-buffer-hook))
#+END_SRC

** Switch window hook
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Switch buffer hook
#+BEGIN_SRC emacs-lisp
  (defvar my/switch-buffer-hook nil
    "Hook called after user has switched buffer")
  (add-hook 'window-configuration-change-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))
  (add-hook 'minibuffer-exit-hook (lambda () (interactive) (run-with-timer 0.1 nil (lambda () (interactive) (run-hooks 'my/switch-buffer-hook)))))
  (add-hook 'my/switch-window-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))

  (defadvice evil-window-up (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-down (after evil-window-down activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-left (after evil-window-left activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-right (after evil-window-right activate) (run-hooks 'my/switch-buffer-hook))
#+END_SRC

** Window settings 
*** Make cursor auto move to new split window
#+BEGIN_SRC emacs-lisp
  (defun my/split-and-follow-horozontally ()
    (interactive)
    (split-window-below)
    ;;(balance-windows)
    (other-window 1))

  (defun my/split-and-follow-vertically()
    (interactive)
    (split-window-right)
    ;;(balance-windows)
    (other-window 1))
#+END_SRC

*** Don't ask for confirmation when killing window
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC


*** Kill all buffers
#+BEGIN_SRC emacs-lisp
  (defun my/kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+END_SRC

*** Unique names for identical buffer names
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'nil)
;;(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

* Dired
#+BEGIN_SRC emacs-lisp
  (require 'dired)

  (defun my/dired-mode ()
    (rainbow-delimiters-mode-disable)
    (dired-hide-details-mode))

  (add-hook 'dired-mode-hook 'my/dired-mode)
#+END_SRC

** Human readable file sizes
Make file sizes human readable
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

** Put deleted files into trash folder
#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Dired async
*** Better async confirmation messages
#+BEGIN_SRC emacs-lisp
  (setq dired-async-message-function
        (lambda (text face &rest args)
          (shell-command (format "echo '%s'" (apply #'format text args)))))
#+END_SRC

** Dired atool
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'dired-atool)

  (dired-atool-setup)

  (define-key dired-mode-map "c" 'dired-atool-do-pack)
  (define-key dired-mode-map "Z" 'dired-atool-do-unpack-with-subdirectory)
#+END_SRC

** Wdired
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/wdired-mode-map)
  (evil-define-key 'normal wdired-mode-map (kbd (concat my/leader-map-key " a")) 'my/wdired-mode-map)

  (define-key my/wdired-mode-map (kbd "s") 'wdired-finish-edit)
  (define-key my/wdired-mode-map (kbd "u") 'wdired-abort-changes)
#+END_SRC

** Dired collapse
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'dired-collapse)
;; 
  ;; (add-hook 'dired-mode-hook 'dired-collapse-mode)
#+END_SRC

** Subtree
#+BEGIN_SRC emacs-lisp
  ;;(straight-use-package 'dired-subtree)
#+END_SRC

** Sorting
Sort dired dir listing in different ways. Modified to work with ivy
URL `http://ergoemacs.org/emacs/dired_sort.html'
Version 2015-07-30"
#+BEGIN_SRC emacs-lisp
  (defun my/dired-sort-menu ()
    (interactive)
    (let ($sort-by $arg)
      (setq $sort-by (completing-read "Sort by:" '( "date" "size" "name" "dir")))
      (cond
       ((equal $sort-by "name") (setq $arg "-Al --si --time-style long-iso "))
       ((equal $sort-by "date") (setq $arg "-Al --si --time-style long-iso -t"))
       ((equal $sort-by "size") (setq $arg "-Al --si --time-style long-iso -S"))
       ((equal $sort-by "dir") (setq $arg "-Al --si --time-style long-iso --group-directories-first"))
       (t (error "logic error 09535" )))
      (dired-sort-other $arg )))

  (define-key dired-mode-map (kbd "s") 'my/dired-sort-menu)
#+END_SRC

** Recursive folder size
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'dired-du)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  ;; Reset dired mode map
  (setq dired-mode-map (make-sparse-keymap))

  (defun my/toggle-delete-to-trash ()
    (interactive)
    (if (eq delete-by-moving-to-trash nil)
        (progn
          (setq delete-by-moving-to-trash t)
          (message "Delete to trash enabled"))
      (progn
        (setq delete-by-moving-to-trash nil)
        (message "Delete to trash disabled"))))

  (define-prefix-command 'my/dired-mode-map)
  (evil-define-key 'normal dired-mode-map (kbd (concat my/leader-map-key " a")) 'my/dired-mode-map)

  (define-key my/dired-mode-map (kbd "t") 'my/toggle-delete-to-trash)
  (define-key my/dired-mode-map (kbd "w") 'dired-toggle-read-only)
  (defun my/image-dired ()
    (interactive)
    (image-dired default-directory))
  (define-key my/dired-mode-map (kbd "i") 'my/image-dired)
  (define-key my/dired-mode-map (kbd "h") 'dired-hide-details-mode)
#+END_SRC

*** Dired keys
#+BEGIN_SRC emacs-lisp
  ;; Bind =Backspace= to go up one directory
  ;;(define-key dired-mode-map [?\d] 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "DEL") 'dired-up-directory)
  (evil-define-key 'insert dired-mode-map (kbd "DEL") 'dired-up-directory)

  (evil-define-key 'insert dired-mode-map (kbd "q") 'quit-window)
  (evil-define-key 'normal dired-mode-map (kbd "q") 'quit-window)

  ;; Upper case keys (except !) for operating on the marked files
  (evil-define-key 'normal dired-mode-map (kbd "RET") 'dired-find-file)
  (evil-define-key 'insert dired-mode-map (kbd "RET") 'dired-find-file)

  (evil-define-key 'insert dired-mode-map (kbd "A") 'dired-do-find-regexp)
  (evil-define-key 'normal dired-mode-map(kbd "C") 'dired-do-copy)
  (evil-define-key 'insert dired-mode-map  (kbd "C") 'dired-do-copy)
  (evil-define-key 'insert dired-mode-map  (kbd "B") 'dired-do-byte-compile)
  (evil-define-key 'normal dired-mode-map (kbd "D") 'dired-do-delete)
  (evil-define-key 'insert dired-mode-map  (kbd "D") 'dired-do-delete)
  (evil-define-key 'insert dired-mode-map  (kbd "G") 'dired-do-chgrp)
  (evil-define-key 'insert dired-mode-map  (kbd "H") 'dired-do-hardlink)
  (evil-define-key 'insert dired-mode-map  (kbd "L") 'dired-do-load)
  (evil-define-key 'normal dired-mode-map  (kbd "M") 'dired-do-chmod)
  (evil-define-key 'insert dired-mode-map  (kbd "M") 'dired-do-chmod)
  (evil-define-key 'normal dired-mode-map  (kbd "O") 'dired-do-chown)
  (evil-define-key 'insert dired-mode-map  (kbd "O") 'dired-do-chown)
  (evil-define-key 'insert dired-mode-map  (kbd "P") 'dired-do-print)
  (evil-define-key 'insert dired-mode-map  (kbd "Q") 'dired-do-find-regexp-and-replace)
  (evil-define-key 'normal dired-mode-map  (kbd "R") 'dired-do-rename)
  (evil-define-key 'insert dired-mode-map  (kbd "R") 'dired-do-rename)
  (evil-define-key 'normal dired-mode-map  (kbd "S") 'dired-do-symlink)
  (evil-define-key 'insert dired-mode-map  (kbd "S") 'dired-do-symlink)
  (evil-define-key 'insert dired-mode-map  (kbd "T") 'dired-do-touch)
  (evil-define-key 'normal dired-mode-map  (kbd "X") 'dired-do-shell-command)
  (evil-define-key 'insert dired-mode-map  (kbd "X") 'dired-do-shell-command)
  (evil-define-key 'normal dired-mode-map  (kbd "Z") 'dired-do-compress)
  (evil-define-key 'insert dired-mode-map  (kbd "Z") 'dired-do-compress)
  (evil-define-key 'normal dired-mode-map  (kbd "c") 'dired-do-compress-to)
  (evil-define-key 'insert dired-mode-map  (kbd "c") 'dired-do-compress-to)
  (evil-define-key 'normal dired-mode-map  (kbd "!") 'dired-do-shell-command)
  (evil-define-key 'insert dired-mode-map  (kbd "!") 'dired-do-shell-command)
  (evil-define-key 'normal dired-mode-map  (kbd "&") 'dired-do-async-shell-command)
  (evil-define-key 'insert dired-mode-map  (kbd "&") 'dired-do-async-shell-command)
  ;; Comparison commands
  (evil-define-key 'normal dired-mode-map (kbd "=") 'dired-diff)
  (evil-define-key 'insert dired-mode-map (kbd "=") 'dired-diff)
  ;; Make all regexp commands share a `%' prefix:
  ;; We used to get to the submap via a symbol dired-regexp-prefix,
  ;; but that seems to serve little purpose, and copy-keymap
  ;; does a better job without it.
  (evil-define-key 'insert dired-mode-map (kbd "%") nil)
  (evil-define-key 'insert dired-mode-map  (kbd "%u") 'dired-upcase)
  (evil-define-key 'insert dired-mode-map  (kbd "%l") 'dired-downcase)
  (evil-define-key 'insert dired-mode-map  (kbd "%d") 'dired-flag-files-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%g") 'dired-mark-files-containing-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%m") 'dired-mark-files-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%r") 'dired-do-rename-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%C") 'dired-do-copy-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%H") 'dired-do-hardlink-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%R") 'dired-do-rename-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%S") 'dired-do-symlink-regexp)
  (evil-define-key 'insert dired-mode-map  (kbd "%&") 'dired-flag-garbage-files)
  ;; Commands for marking and unmarking.
  (evil-define-key 'normal dired-mode-map (kbd "*") nil)
  (evil-define-key 'insert dired-mode-map (kbd "*") nil)
  (evil-define-key 'normal dired-mode-map (kbd "**") 'dired-mark-executables)
  (evil-define-key 'insert dired-mode-map (kbd "**") 'dired-mark-executables)
  (evil-define-key 'normal dired-mode-map (kbd "*/") 'dired-mark-directories)
  (evil-define-key 'insert dired-mode-map (kbd "*/") 'dired-mark-directories)
  (evil-define-key 'normal dired-mode-map (kbd "*@") 'dired-mark-symlinks)
  (evil-define-key 'insert dired-mode-map (kbd "*@") 'dired-mark-symlinks)
  (evil-define-key 'normal dired-mode-map (kbd "*%") 'dired-mark-files-regexp)
  (evil-define-key 'insert dired-mode-map (kbd "*%") 'dired-mark-files-regexp)
  (evil-define-key 'normal dired-mode-map (kbd "*c") 'dired-change-marks)
  (evil-define-key 'insert dired-mode-map (kbd "*c") 'dired-change-marks)
  (evil-define-key 'normal dired-mode-map (kbd "*s") 'dired-mark-subdir-files)
  (evil-define-key 'insert dired-mode-map (kbd "*s") 'dired-mark-subdir-files)
  (evil-define-key 'normal dired-mode-map (kbd "*m") 'dired-mark)
  (evil-define-key 'insert dired-mode-map (kbd "*m") 'dired-mark)
  (evil-define-key 'normal dired-mode-map (kbd "*u") 'dired-unmark)
  (evil-define-key 'insert dired-mode-map (kbd "*u") 'dired-unmark)
  (evil-define-key 'normal dired-mode-map (kbd "*?") 'dired-unmark-all-files)
  (evil-define-key 'insert dired-mode-map (kbd "*?") 'dired-unmark-all-files)
  (evil-define-key 'normal dired-mode-map (kbd "*!") 'dired-unmark-all-marks)
  (evil-define-key 'insert dired-mode-map (kbd "*!") 'dired-unmark-all-marks)
  (evil-define-key 'normal dired-mode-map (kbd "U") 'dired-unmark-all-marks)
  (evil-define-key 'insert dired-mode-map (kbd "U") 'dired-unmark-all-marks)
  (evil-define-key 'normal dired-mode-map (kbd "*\177") 'dired-unmark-backward)
  (evil-define-key 'insert dired-mode-map (kbd "*\177") 'dired-unmark-backward)
  (evil-define-key 'normal dired-mode-map (kbd "*\C-n") 'dired-next-marked-file)
  (evil-define-key 'insert dired-mode-map (kbd "*\C-n") 'dired-next-marked-file)
  (evil-define-key 'normal dired-mode-map (kbd "*\C-p") 'dired-prev-marked-file)
  (evil-define-key 'insert dired-mode-map (kbd "*\C-p") 'dired-prev-marked-file)
  (evil-define-key 'normal dired-mode-map (kbd "*t") 'dired-toggle-marks)
  (evil-define-key 'insert dired-mode-map (kbd "*t") 'dired-toggle-marks)
  ;; Lower keys for commands not operating on all the marked files
  (evil-define-key 'insert dired-mode-map (kbd "a") 'dired-find-alternate-file)
  (evil-define-key 'normal dired-mode-map (kbd "d") 'dired-flag-file-deletion)
  (evil-define-key 'insert dired-mode-map (kbd "d") 'dired-flag-file-deletion)
  (evil-define-key 'insert dired-mode-map (kbd "e") 'dired-find-file)
  (evil-define-key 'insert dired-mode-map (kbd "f") 'dired-find-file)
  (evil-define-key 'insert dired-mode-map (kbd "\C-m") 'dired-find-file)
  ;; (put 'dired-find-file :advertised-binding (kbd "\C-m"))
  (evil-define-key 'insert dired-mode-map (kbd "g") 'revert-buffer)
  (evil-define-key 'insert dired-mode-map (kbd "i") 'dired-maybe-insert-subdir)
  (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-goto-file)
  (evil-define-key 'insert dired-mode-map (kbd "j") 'dired-goto-file)
  ;; Maybe bind this??
  (evil-define-key 'insert dired-mode-map (kbd "k") 'dired-do-kill-lines)
  (evil-define-key 'insert dired-mode-map (kbd "l") 'dired-do-redisplay)
  (evil-define-key 'normal dired-mode-map (kbd "m") 'dired-mark)
  (evil-define-key 'insert dired-mode-map (kbd "m") 'dired-mark)
  (evil-define-key 'insert dired-mode-map (kbd "n") 'dired-next-line)
  (evil-define-key 'normal dired-mode-map (kbd "o") 'dired-find-file-other-window)
  (evil-define-key 'insert dired-mode-map (kbd "o") 'dired-find-file-other-window)
  (evil-define-key 'insert dired-mode-map (kbd "\C-o") 'dired-display-file)
  (evil-define-key 'insert dired-mode-map (kbd "p") 'dired-previous-line)
  (evil-define-key 'normal dired-mode-map (kbd "s") 'my/dired-sort-menu)
  (evil-define-key 'insert dired-mode-map (kbd "s") 'my/dired-sort-menu)
  (evil-define-key 'insert dired-mode-map (kbd "t") 'dired-toggle-marks)
  (evil-define-key 'insert dired-mode-map (kbd "u") 'dired-unmark)
  (evil-define-key 'insert dired-mode-map (kbd "v") 'dired-view-file)
  (evil-define-key 'normal dired-mode-map (kbd "y") 'dired-copy-filename-as-kill)
  (evil-define-key 'insert dired-mode-map (kbd "y") 'dired-copy-filename-as-kill)
  (evil-define-key 'insert dired-mode-map (kbd "w") 'browse-url-of-dired-file)
  (evil-define-key 'normal dired-mode-map (kbd "x") 'dired-do-flagged-delete)
  (evil-define-key 'insert dired-mode-map (kbd "x") 'dired-do-flagged-delete)
  (evil-define-key 'normal dired-mode-map (kbd "?") 'dired-show-file-type)
  (evil-define-key 'insert dired-mode-map (kbd "?") 'dired-show-file-type)
  (evil-define-key 'normal dired-mode-map (kbd "+") 'dired-create-directory)
  (evil-define-key 'insert dired-mode-map (kbd "+") 'dired-create-directory)
  ;; moving
  (evil-define-key 'normal dired-mode-map (kbd "<") 'dired-prev-dirline)
  (evil-define-key 'insert dired-mode-map (kbd "<") 'dired-prev-dirline)
  (evil-define-key 'normal dired-mode-map (kbd ">") 'dired-next-dirline)
  (evil-define-key 'insert dired-mode-map (kbd ">") 'dired-next-dirline)
  (evil-define-key 'normal dired-mode-map (kbd "^") 'dired-up-directory)
  (evil-define-key 'insert dired-mode-map (kbd "^") 'dired-up-directory)
  ;; folding
  (evil-define-key 'normal dired-mode-map (kbd "g") nil)
  (evil-define-key 'normal dired-mode-map (kbd "g a") 'dired-hide-all)
  (evil-define-key 'normal dired-mode-map (kbd "g A") 'dired-hide-all)
  (evil-define-key 'normal dired-mode-map (kbd "g f") 'dired-hide-subdir)
  (evil-define-key 'normal dired-mode-map (kbd "g F") 'dired-hide-subdir)
  (evil-define-key 'normal dired-mode-map (kbd "g o") 'dired-hide-subdir)
  (evil-define-key 'normal dired-mode-map (kbd "g O") 'dired-hide-subdir)
  (define-key dired-mode-map  [remap evil-close-fold] 'dired-hide-subdir)
  (define-key dired-mode-map  [remap my/outline-hide-all-body] 'dired-hide-all)
  (define-key dired-mode-map  [remap outline-show-all] 'dired-hide-all)
  ;; misc
  ;; (evil-define-key 'insert dired-mode-map [remap read-only-mode] 'dired-toggle-read-only)
  ;; ;; `toggle-read-only' is an obsolete alias for `read-only-mode'
  ;; (evil-define-key 'insert dired-mode-map [remap toggle-read-only] 'dired-toggle-read-only)
  ;; (evil-define-key 'insert dired-mode-map  (kbd "\177") 'dired-unmark-backward)
  (define-key dired-mode-map  [remap undo] 'dired-undo)
  (define-key dired-mode-map  [remap undo-tree-undo] 'dired-undo)
  ;; thumbnail manipulation (image-dired)
  (evil-define-key 'insert dired-mode-map (kbd "\C-td") 'image-dired-display-thumbs)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tt") 'image-dired-tag-files)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tr") 'image-dired-delete-tag)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tj") 'image-dired-jump-thumbnail-buffer)
  (evil-define-key 'insert dired-mode-map (kbd "\C-ti") 'image-dired-dired-display-image)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tx") 'image-dired-dired-display-external)
  (evil-define-key 'insert dired-mode-map (kbd "\C-ta") 'image-dired-display-thumbs-append)
  (evil-define-key 'insert dired-mode-map (kbd "\C-t.") 'image-dired-display-thumb)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tc") 'image-dired-dired-comment-files)
  (evil-define-key 'insert dired-mode-map (kbd "\C-tf") 'image-dired-mark-tagged-files)
  (evil-define-key 'insert dired-mode-map (kbd "\C-t\C-t") 'image-dired-dired-toggle-marked-thumbs)
  (evil-define-key 'insert dired-mode-map (kbd "\C-te") 'image-dired-dired-edit-comment-and-tags)
  ;; encryption and decryption (epa-dired)
  ;; (evil-define-key 'insert (kbd ":d") 'epa-dired-do-decrypt)
  ;; (evil-define-key 'insert  (kbd ":v") 'epa-dired-do-verify)
  ;; (evil-define-key 'insert  (kbd ":s") 'epa-dired-do-sign)
  ;; (evil-define-key 'insert  (kbd ":e") 'epa-dired-do-encrypt)
#+END_SRC

* Gud
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'realgud)
  (setq gdb-many-windows 'nil)
  ;;(require 'realgud)
#+END_SRC

* Code
** Generic
*** Ivy-xref
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'ivy-xref)

  (require 'ivy-xref)
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs)
#+END_SRC

*** Smartparens
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'smartparens)
;; 
  ;; (smartparens-global-mode)
#+END_SRC
    
*** Eldoc
Shows information in echo area
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (setq eldoc-echo-area-use-multiline-p 't)
  (setq-default eldoc-echo-area-use-multiline-p 't)
  (setq eldoc-idle-delay 0)
#+END_SRC

*** Aggressive indent
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'aggressive-indent)

  (global-aggressive-indent-mode)
  ;;(add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
    
*** Whitespace cleanup
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'whitespace-cleanup-mode)

  (global-whitespace-cleanup-mode)
#+END_SRC

*** indent guide
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'highlight-indent-guides)
;; 
  ;; (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
;; 
  ;; ;;(setq highlight-indent-guides-method 'column)
  ;; (setq highlight-indent-guides-method 'fill)
;; 
  ;; (setq highlight-indent-guides-responsive 'top)
  ;; (setq highlight-indent-guides-delay 0)
#+END_SRC

*** Auto jump to definition
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'dumb-jump)

  (defun my/auto-jump-to-definition ()
    (interactive)
    (pcase major-mode
      ('fsharp-mode (fsharp-ac/gotodefn-at-point))
      ('clojure-mode (clojure-find-def))
      ('c-mode (xref-find-definitions))
      ('c++-mode (xref-find-definitions))
      ('objc-mode (xref-find-definitions))
      (_ (dumb-jump-go))))

  (define-key my/leader-map (kbd "t") 'my/auto-jump-to-definition)

  (setq dumb-jump-selector 'ivy)
#+END_SRC

*** Auto find references
#+BEGIN_SRC emacs-lisp
  (defun my/auto-find-references ()
    (interactive)
    (pcase major-mode
      (_ (xref-find-references))))

  (define-key my/leader-map (kbd "C-r") 'my/auto-find-references)
#+END_SRC

*** Auto eval
#+BEGIN_SRC emacs-lisp
  (defun my/auto-eval ()
    (interactive)
    (if (eq evil-state 'visual)
        (my/auto-eval-region)
      (pcase major-mode
        ('org-mode (call-interactively 'org-babel-execute-src-block))
        ('scheme-mode (geiser-eval-last-sexp nil))
        ('clojure-mode (cider-eval-last-sexp))
        ('plantuml-mode (plantuml-preview-region 0 (line-beginning-position) (line-end-position)))
        ('fsharp-mode (fsharp-eval-phrase))
        ('c-mode (cling-send-region (line-beginning-position) (line-end-position)))
        ('c++-mode (cling-send-region (line-beginning-position) (line-end-position)))
        (_ (eval-defun nil)))))

  (defun my/auto-eval-region ()
    (interactive)
    (pcase major-mode
      ('clojure-mode (cider-eval-region (point) (mark t)))
      ('plantuml-mode (plantuml-preview-region 0 (point) (mark t)))
      ('fsharp-mode (fsharp-eval-region (point) (mark t)))
      ('c-mode (cling-send-region (point) (mark t)))
      ('c++-mode (cling-send-region (point) (mark t)))
      (_ (eval-region (point) (mark t) t))))

  (defun my/auto-eval-buffer ()
    (interactive)
    (pcase major-mode
      ('scheme-mode (geiser-eval-buffer nil))
      ('clojure-mode (cider-eval-buffer))
      ('plantuml-mode (plantuml-preview-buffer 0))
      ('fsharp-mode (fsharp-eval-region (point-min) (point-max)))
      ('c-mode (cling-send-buffer))
      ('c++-mode (cling-send-buffer))
      (_ (eval-buffer nil))))

  (defun my/auto-eval-print ()
    (interactive)
    (pcase major-mode
      ('scheme-mode (geiser-eval-last-sexp t))
      ('clojure-mode (cider-eval-print-last-sexp))
      (_ eval-print-last-sexp nil)))

  (define-key my/leader-map (kbd "e") 'my/auto-eval)
  (define-key my/leader-map (kbd "E") 'my/auto-eval-buffer)
  (define-key my/leader-map (kbd "M-e") 'my/auto-eval-print)
#+END_SRC

*** Auto debug
#+BEGIN_SRC emacs-lisp
  (defun my/auto-debug ()
    (interactive)
    ;;(load-library "realgud")
    (if (eq evil-state 'visual)
        (my/auto-debug-region)
      (pcase major-mode
        ('emacs-lisp-mode (call-interactively #'edebug-set-breakpoint))
        ('c-mode (call-interactively #'gud-break))
        ('c++-mode (call-interactively #'gud-break))
        (_ (eval-last-sexp nil)))))

  (defun my/auto-remove-debug ()
    (interactive)
    ;;(load-library "realgud")
    (if (eq evil-state 'visual)
        (my/auto-debug-region)
      (pcase major-mode
        ('emacs-lisp-mode (call-interactively #'edebug-unset-breakpoint))
        ('c-mode (call-interactively #'gud-remove))
        ('c++-mode (call-interactively #'gud-remove))
        (_ (eval-last-sexp nil)))))

  ;;(defun my/auto-debug-region ()
    ;;(interactive)
    ;;)

  (defun my/start-gdb()
    (split-window-below)
    (call-interactively #'gdb))

  (defun my/auto-start-debugger ()
    (interactive)
    ;;(load-library "realgud")
    (pcase major-mode
      ('c-mode (my/start-gdb))
      ('c++-mode (my/start-gdb))
      (_ (eval-last-sexp nil))))

  (define-key my/leader-map (kbd "d") 'my/auto-debug)
  (define-key my/leader-map (kbd "C-d") 'my/auto-remove-debug)
  ;;(define-key my/leader-map (kbd "D") 'my/auto-debug-buffer)
  (define-key my/leader-map (kbd "M-d") 'my/auto-start-debugger)
#+END_SRC

*** Auto compile
#+BEGIN_SRC emacs-lisp
  (defun my/auto-compile ()
    (interactive)
    (pcase major-mode
      ('emacs-lisp-mode (emacs-lisp-byte-compile))
      ('clojure-mode (cider-eval-last-sexp))
      ('plantuml-mode (plantuml-preview-buffer 0))
      (_ (recompile))))

  (define-key my/leader-map (kbd "C") 'my/auto-compile)
#+END_SRC

** Documentation
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'zeal-at-point)

  (define-key my/leader-map (kbd "T") 'zeal-at-point)
#+END_SRC

** Plantuml
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'plantuml-mode)

  ;; Org src compatibility
  (add-to-list 'auto-mode-alist '("\\.plantuml\\'" . plantuml-mode))

  (defun my/plantuml-mode ()
    (interactive)
    (aggressive-indent-mode -1))

  (add-hook 'plantuml-mode-hook 'my/plantuml-mode)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'lsp-mode)

  ;; Normally lsp-mode starts up flymake mode automaticall which breaks ccls
  (setq lsp-prefer-flymake nil)
#+END_SRC

*** Company LSP
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'company-lsp)

#+END_SRC

*** LSP-ui
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'lsp-ui)
#+END_SRC

** Elgot
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'eglot)
#+END_SRC

** Common lisp
*** Slime
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'slime)

  (setq inferior-lisp-program "/usr/bin/sbcl")
  (setq slime-contribs '(slime-fancy))
#+END_SRC

**** Slime comany
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'slime-company)

  (slime-setup '(slime-fancy slime-company))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/common-lisp-mode-map)
  (evil-define-key 'normal lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/common-lisp-mode-map)

  (define-key my/common-lisp-mode-map (kbd "d") 'slime-inspect-definition)

#+END_SRC

** Scheme
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'geiser)

  (define-prefix-command 'my/scheme-mode-map)
  (evil-define-key 'normal scheme-mode-map (kbd (concat my/leader-map-key " a")) 'my/scheme-mode-map)

  (define-key my/scheme-mode-map (kbd "s") 'geiser-set-scheme)
  (define-key my/scheme-mode-map (kbd "C-s") 'run-geiser)
#+END_SRC

** Emacs-lisp
*** Enable debugging on error
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
#+END_SRC

*** Debugging
#+BEGIN_SRC emacs-lisp
#+END_SRC

*** Suggest
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'suggest)
#+END_SRC


*** Formatting
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'elisp-format)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/emacs-lisp-mode-map)
  (evil-define-key 'normal emacs-lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/emacs-lisp-mode-map)

  (define-key my/emacs-lisp-mode-map (kbd "d") 'find-function)
  (define-key my/emacs-lisp-mode-map (kbd "D") 'find-variable)

  (define-key my/emacs-lisp-mode-map (kbd "c") 'emacs-lisp-byte-compile)

  (define-key my/emacs-lisp-mode-map (kbd "s") 'suggest)

  (define-prefix-command 'my/emacs-lisp-formatting-map)
  (define-key my/emacs-lisp-mode-map (kbd "f") 'my/emacs-lisp-formatting-map)

  (define-key my/emacs-lisp-formatting-map (kbd "b") 'elisp-format-buffer)
  (define-key my/emacs-lisp-formatting-map (kbd "r") 'elisp-format-region)
  (define-key my/emacs-lisp-formatting-map (kbd "f") 'elisp-format-file)
  (define-key my/emacs-lisp-formatting-map (kbd "C-d") 'elisp-format-directory)
  ;; Format marked files in dired
  ;;elisp-format-dired-mark-files


  ;; control
  (define-key my/emacs-lisp-mode-map "n" 'edebug-step-mode)
  ;;(define-key my/emacs-lisp-mode-map "n" 'edebug-next-mode)

  (define-key my/emacs-lisp-mode-map (kbd "s") 'edebug-go-mode)
  (define-key my/emacs-lisp-mode-map "S" 'edebug-Go-nonstop-mode)
  (define-key my/emacs-lisp-mode-map "t" 'edebug-trace-mode)
  (define-key my/emacs-lisp-mode-map "T" 'edebug-Trace-fast-mode)

  (define-key my/emacs-lisp-mode-map "g" 'edebug-goto-here)

  (define-key my/emacs-lisp-mode-map "i" 'edebug-step-in)
  (define-key my/emacs-lisp-mode-map "o" 'edebug-step-out)
#+END_SRC

** Java
Try
https://github.com/mopemope/meghanada-emacs
or
=ENSIME= 
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'lsp-java)

  (add-hook 'java-mode-hook 'lsp-java-enable)
  (add-hook 'java-mode-hook (lambda () (lsp-ui-flycheck-enable t)))
  (add-hook 'java-mode-hook 'lsp-ui-sideline-mode)

  ;; set the projects that are going to be imported into the workspace.
  (setq lsp-java--workspace-folders 
        (list 
         "~/eclipse-workspace/"
         "~/workspace"))

  (defun my/java-mode ()
    (aggressive-indent-mode 0)

    ;; TODO right now these are permanently set if you start lsp-java mode
    ;; Taken from lsp-java readme
    (setq-local lsp-inhibit-message t)
    (setq-local lsp-eldoc-render-all nil)
    (setq-local lsp-highlight-symbol-at-point nil)

    (setq-local lsp-ui-sideline-enable t)
    (setq-local lsp-ui-sideline-show-symbol t)
    (setq-local lsp-ui-sideline-show-hover t)
    (setq-local lsp-ui-sideline-show-code-actions t)
    (setq-local lsp-ui-sideline-update-mode 'point)

    ;; Requested by lsp java
    (setq-local company-lsp-enable-snippet t)
    (setq-local company-lsp-cache-candidates t)
    (push 'company-lsp company-backends))

  (add-hook 'java-mode-hook 'my/java-mode)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/java-mode-map)
  (evil-define-key 'normal java-mode-map (kbd (concat my/leader-map-key " a")) 'my/java-mode-map)

  (define-key my/java-mode-map (kbd "r") 'lsp-rename)
  (define-key my/java-mode-map (kbd "C-r") 'lsp-workspace-restart)
  (define-key my/java-mode-map (kbd "f") 'lsp-format-buffer)
  (define-key my/java-mode-map (kbd "i") 'lsp-java-organize-imports)
  (define-key my/java-mode-map (kbd "C-b") 'lsp-java-build-project)

  (define-key my/java-mode-map (kbd "f") 'xref-find-references)
  (define-key my/java-mode-map (kbd "a") 'xref-find-apropos)

  (define-prefix-command 'my/java-refractor-map)
  (define-key my/java-mode-map (kbd "R") 'my/java-refractor-map)

  (define-key my/java-refractor-map (kbd "c") 'lsp-java-extract-to-constant)
  (define-key my/java-refractor-map (kbd "u") 'lsp-java-add-unimplemented-methods)
  (define-key my/java-refractor-map (kbd "p") 'lsp-java-create-parameter)
  (define-key my/java-refractor-map (kbd "f") 'lsp-java-create-field)
  (define-key my/java-refractor-map (kbd "l") 'lsp-java-create-local)
  (define-key my/java-refractor-map (kbd "m") 'lsp-java-extract-method)
  (define-key my/java-refractor-map (kbd "i") 'lsp-java-add-import)
#+END_SRC

** Python
*** Jedi
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'company-jedi)

  (add-to-list 'company-backends 'company-jedi)
#+END_SRC

** C/CPP
*** Irony
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'irony)
;; 
  ;; (add-hook 'c++-mode-hook 'irony-mode)
  ;; (add-hook 'c-mode-hook 'irony-mode)
  ;; (add-hook 'objc-mode-hook 'irony-mode)
;; 
  ;; (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
#+END_SRC

**** Windows tweaks
Windows performance tweaks
#+BEGIN_SRC emacs-lisp
  ;; (when (boundp 'w32-pipe-read-delay)
    ;; (setq w32-pipe-read-delay 0))
   ;; ;; Set the buffer size to 64K on Windows (from the original 4K)
   ;; (when (boundp 'w32-pipe-buffer-size)
   ;; (setq irony-server-w32-pipe-buffer-size (* 64 1024)))
#+END_SRC

**** Flycheck-irony
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'flycheck-irony)
;; 
  ;; (eval-after-load 'flycheck
    ;; '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
#+END_SRC

**** Company-irony
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'company-irony)
;; 
  ;; (eval-after-load 'company
    ;; '(add-to-list 'company-backends 'company-irony))
#+END_SRC

**** Eldoc-irony
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'irony-eldoc)
;; 
  ;; (add-hook 'irony-mode-hook #'irony-eldoc)
#+END_SRC

*** Elgot
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'c-mode-hook 'eglot-ensure)
  ;; (add-hook 'c++-mode-hook 'eglot-ensure)
  ;; (add-hook 'objc-mode-hook 'eglot-ensure)
#+END_SRC

*** LSP CCLS
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'ccls)
  (require 'ccls)

  (setq ccls-executable "/bin/ccls")

  (add-hook 'c-mode-hook '(lambda () (interactive) (aggressive-indent-mode 0)))
  (add-hook 'c++-mode-hook '(lambda () (interactive) (aggressive-indent-mode 0)))
  (add-hook 'objc-mode-hook '(lambda () (interactive) (aggressive-indent-mode 0)))

  (add-hook 'c-mode-hook 'lsp)
  (add-hook 'c++-mode-hook 'lsp)
  (add-hook 'objc-mode-hook 'lsp)

  (add-hook 'c-mode-hook (lambda () (push 'company-lsp company-backends)))
  (add-hook 'c++-mode-hook (lambda () (push 'company-lsp company-backends)))
  (add-hook 'objc-mode-hook (lambda () (push 'company-lsp company-backends)))
#+END_SRC

*** Cling
https://github.com/brianqq/inferior-cling
#+BEGIN_SRC emacs-lisp
  (defun cling (&optional flags)
    "Move to the buffer containing Cling, or create one if it does not exist. Defaults to C++11"
    (interactive)
    (let ((flags (or flags "-std=c++11"))) 
      (make-comint "inferior-cling" "cling" nil flags)
      (switch-to-buffer-other-window "*inferior-cling*")))

  (defun cling-send-string (string &optional process)
    "Send a string terminated with a newline to the inferior-cling buffer. Has the effect of executing a command"
    (let ((process (or process (get-process "inferior-cling"))))
      (comint-send-string process string)
      (comint-send-string process "\n")))

  (defun cling-send-region (start end)
    "Sends the region in the current buffer between `start` and `end` to the inferior-cling buffer. Sends the currently selected region when called interactively."
    (interactive "r")
    (cling-send-string (buffer-substring start end)))

  (defun cling-send-buffer ()
    "Sends the current buffer to the inferior-cling buffer."
    (interactive)
    (cling-send-region (point-min) (point-max))) ;;do i want to wrap-raw this? 

  (defun cling-wrap-raw (string)
    "Wraps `string` in \".rawInput\", which tells Cling to accept function definitions"
    (format ".rawInput\n%s\n.rawInput" string))

  (defun cling-wrap-region-and-send (start end)
    "Sends the region between start and end (currently selected when called interactively) to cling in raw input mode "
    (interactive "r")
    (cling-send-string (cling-wrap-raw (buffer-substring start end))))

  (defun flatten-function-def ()
    "Flattens a function definition into a single line. This makes it easier to send to the inferior-cling buffer"
    (interactive)
    (replace-regexp "
  " "" nil (mark) (point))) ;;;Why did I do this again? 

  (defun select-defun ()
    "Selects the defun containing the point. Currently only works when point is on the line where the function's name is declared."
    (interactive)
    (move-beginning-of-line nil)
    (push-mark (point))
    (re-search-forward "{")
    (save-excursion
     (flatten-function-def))
    (backward-char)
    (forward-sexp))

  (defun cling-wrap-defun-and-send ()
    "Sends the current defun to cling in raw input mode. Currently only works when point is on the first line of function definition."
    (interactive)
    (save-excursion
      (select-defun)
      (cling-wrap-region-and-send (mark) (point))
      (undo)
      (undo)));;;this is a rather leaky way of doing temporary changes. there should be some way to save buffer contents or something
  ;;;probably uses with-temp-buffer
#+END_SRC

*** Etags
#+BEGIN_SRC emacs-lisp
  ;;(straight-use-package 'etags)
  ;;(straight-use-package 'counsel-etags)
#+END_SRC

*** Rtags
#+BEGIN_SRC emacs-lisp

#+END_SRC

*** Debugging
#+BEGIN_SRC emacs-lisp
  ;;(require 'gdb-mi)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/c-mode-map)

  (evil-define-key 'normal c-mode-map (kbd (concat my/leader-map-key " a")) 'my/c-mode-map)
  (evil-define-key 'normal c++-mode-map (kbd (concat my/leader-map-key " a")) 'my/c-mode-map)

  (define-key my/c-mode-map (kbd "e") 'cling)

  (define-key my/c-mode-map (kbd "n") 'gud-step)
  (define-key my/c-mode-map (kbd "N") 'gud-next)

  (define-key my/c-mode-map (kbd "p") 'gud-print)
  (define-key my/c-mode-map (kbd "P") 'gud-pstar)

  (define-key my/c-mode-map (kbd "s") 'gud-go)

  ;; Run to selected line
  (define-key my/c-mode-map (kbd "g") 'gud-until)

  ;; Run out of function
  (define-key my/c-mode-map (kbd "f") 'gud-finish)

  (define-key my/c-mode-map (kbd "v") 'gdb-display-locals-buffer)
  (define-key my/c-mode-map (kbd "V") 'gdb-display-locals-for-thread)

  (define-key my/c-mode-map (kbd "b") 'gdb-display-breakpoints-buffer)
#+END_SRC

** C#
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'csharp-mode)
#+END_SRC

*** Omnisharp-emacs
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'omnisharp)

  (add-hook 'csharp-mode-hook 'omnisharp-mode)
  (add-hook 'csharp-mode-hook (lambda () (push 'company-omnisharp company-backends)))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/csharp-mode-map)
  (evil-define-key 'normal csharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/csharp-mode-map)

  (define-key my/csharp-mode-map (kbd "r") 'omnisharp-run-code-action-refactoring)
  (define-key my/csharp-mode-map (kbd "f") 'omnisharp-code-format-entire-file)
  (define-key my/csharp-mode-map (kbd "R") 'omnisharp-rename-interactively)
  (define-key my/csharp-mode-map (kbd "s") 'omnisharp-reload-solution)
  (define-key my/csharp-mode-map (kbd "d") 'omnisharp-go-to-definition-other-window)
  (define-key my/csharp-mode-map (kbd "u") 'omnisharp-find-usages)
  (define-key my/csharp-mode-map (kbd "i") 'omnisharp-find-implementations)
  (define-key my/csharp-mode-map (kbd "p") 'omnisharp-navigate-to-solution-file)
  (define-key my/csharp-mode-map (kbd "a") 'omnisharp-solution-actions)
  (define-key my/csharp-mode-map (kbd "e") 'omnisharp-solution-errors)
#+END_SRC

**** Write formatting settings to omnisharp server config
omnisharp.json should be in ~/.omnisharp on all OSs
#+BEGIN_SRC emacs-lisp
;; if(not(file-directory-p "~/.omnisharp")
;;     (make-directory "~/.omnisharp"))
;;
;; (if(not(file-exists-p "~/.omnisharp/omnisharp.json"))
;;     (progn
;;       (write-region "
;;         {
;;             \"formattingOptions\": {
;;                 PUT OPTIONS HERE
;;             }
;;         }
;;        " nil "~/.omnisharp/omnisharp.json")
;;
;;       (message "~/.omnisharp/omnisharp.json created")
;;       )
;;   )
#+END_SRC

** F#
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'fsharp-mode)

  ;;:mode ("\\.fs\\'" . fsharp-mode)
  (setq fsharp-doc-idle-delay 0)

  ;;(setq-default fsharp-indent-offset 2)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (add-hook 'fsharp-mode-hook 'my/fsharp-keys-init)

  (define-prefix-command 'my/fsharp-mode-map)

  (defun my/fsharp-keys-init()
    (interactive)
    (evil-define-key 'normal fsharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/fsharp-mode-map))

  (define-key my/fsharp-mode-map (kbd "d") 'fsharp-ac/gotodefn-at-point)
  (define-key my/fsharp-mode-map (kbd "v") 'fsharp-mark-phrase)
  (define-key my/fsharp-mode-map (kbd "b") 'fsharp-goto-block-up)
  (define-key my/fsharp-mode-map (kbd "C-r") 'fsharp-ac-status)
  (define-key my/fsharp-mode-map (kbd "C-k") 'fsharp-ac/stop-process)
  (define-key my/fsharp-mode-map (kbd "C-s") 'fsharp-ac/start-process)
#+END_SRC

*** Settings
#+BEGIN_SRC emacs-lisp
  (defun my/fsharp-mode()
    ;; Disable not so helpful modes
    ;; 
    (aggressive-indent-mode 0)
    ;; Fsharp has built in intellisense highlight thing at point
    (highlight-thing-mode -1)
    ;; Visual line mode in fsharp mode is broken, makes swiper take years to start, use truncate lines mode instead
    (visual-line-mode 0))

    ;; Autostart
    (add-hook 'fsharp-mode-hook 'my/fsharp-mode)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'clojure-mode)
#+END_SRC

*** Cider
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'cider)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/clojure-mode-map)
  (evil-define-key 'normal clojure-mode-map (kbd (concat my/leader-map-key " a")) 'my/clojure-mode-map)

  (define-key my/clojure-mode-map (kbd "C-s") 'cider-jack-in)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'markdown-mode)
#+END_SRC

** Web mode
TODO: Fix settings, grab them from package site 
#+BEGIN_SRC emacs-lisp
   (straight-use-package 'web-mode)

   (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
   ;; Messes with .cs files???
   ;;(add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.xml?\\'" . web-mode))
#+END_SRC

*** Debugger
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'dap-mode)
#+END_SRC

* Encryption
** GPG  
*** Pinentry
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'pinentry)

  (if window-system
      (add-hook 'exwm-init-hook 'pinentry-start)
    (pinentry-start))
#+END_SRC

*** Reset GPG agent
#+BEGIN_SRC emacs-lisp
  (defun my/reset-gpg-agent ()
    (interactive)
    (shell-command "gpgconf --kill gpg-agent")
    (pinentry-stop)
    (pinentry-start))
#+END_SRC
** Passwords
Enable org mode for .org.gpg files
#+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.org.gpg\\'" . org-mode))
#+END_SRC

*** Espy
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'espy)

  (setq espy-password-file "~/pass.org.gpg")

  (define-prefix-command 'my/password-map)
  (define-key my/leader-map (kbd "p") 'my/password-map)

  (define-key my/password-map (kbd "r") 'my/reset-gpg-agent)
  (define-key my/password-map (kbd "u") 'espy-get-user)
  (define-key my/password-map (kbd "p") 'espy-get-pass)
#+END_SRC

*** Auto-clean kill ring
#+BEGIN_SRC emacs-lisp
  ;;(defvar my/pass-in-killring nil)

  ;; (defun my/ivy-pass ()
  ;; (interactive)
  ;; (setq my/pass-in-killring t)
  ;; (ivy-pass))
  ;; 
  ;; (defun my/pass-pop-killring ()
  ;; (if (eq my/pass-in-killring t)
  ;; (progn
  ;; (progn (pop kill-ring) 
  ;; (message "Password removed"))
  ;; (setq my/pass-in-killring nil))))

  (defun my/pop-killring ()
    (pop kill-ring)
    (setq my/pass-in-killring nil))

  (define-key my/leader-map (kbd "C-k") 'my/pop-killring)
  ;;(advice-add 'evil-goggles--paste-advice :before (lambda () (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-goggles--paste-advice :before 
  ;;(advice-add 'evil-paste-after :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-paste-before :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
#+END_SRC

* Eshell
 ;https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org
#+BEGIN_SRC emacs-lisp
  (require 'eshell)
  ;; Change to temporary name before renaming
  (setq eshell-buffer-name "eshell")

  (setq eshell-highlight-prompt t)
  (setq eshell-hist-ignoredups t)
  (setq eshell-history-size 10000)

  (setq-default eshell-status-in-mode-line nil)
  (defun my/eshell ()
    (interactive)
    (eshell)
    (my/give-buffer-unique-name "*eshell*"))

  (defun my/eshell-insert-history ()
    (interactive)
    (insert (completing-read "Eshell history: "
                             (delete-dups
                              (ring-elements eshell-history-ring)))))
#+END_SRC

** Aliases
#+BEGIN_SRC emacs-lisp
  (defun eshell/f (file)
    (find-file file))
#+END_SRC

** Clear
Default eshell/clear only spams newlines
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    "Clear the eshell buffer."
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))
#+END_SRC

** Term
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "{") 'ansi-term)
#+END_SRC

** Disable minor modes
Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

** Use ansi term for certain applications
#+BEGIN_SRC emacs-lisp
  (require 'em-term)
  (add-to-list 'eshell-visual-commands "vim")
#+END_SRC

** Remove banner
#+BEGIN_SRC emacs-lisp
(setq eshell-banner-message "")
#+END_SRC

** Custom prompt
#+BEGIN_SRC emacs-lisp
(defvar my/eshell-prompt-symbol)
  (if window-system
    (setq my/eshell-prompt-symbol "λ")
   (setq my/eshell-prompt-symbol "$"))

(setq eshell-prompt-function
             (lambda ()
     (concat (abbreviate-file-name (eshell/pwd))
	     (if (= (user-uid) 0) " # " (concat " " my/eshell-prompt-symbol " ")))))
             
        (setq eshell-prompt-regexp
             (concat "^[^#$\n]* [#" my/eshell-prompt-symbol "] "))
#+END_SRC

** Alert when task is done
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-after-prompt-hook (lambda () (interactive) (if (not (= 1 (line-number-at-pos (point))))
                                                                   (progn
                                                                     (my/alert nil 'low)
                                                                     (message "Eshell command done!")))))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "[") 'my/eshell)

  ;; Eshell keys are buffer local... Bind them on startup
  (defun my/bind-eshell-keys ()
    (define-prefix-command 'my/eshell-mode-map)
    (evil-define-key 'normal eshell-mode-map (kbd (concat my/leader-map-key " a")) 'my/eshell-mode-map)

    (evil-define-key 'normal eshell-mode-map (kbd "RET") 'eshell-send-input)
    (define-key eshell-mode-map [remap evil-ret] 'eshell-send-input)

    (define-key my/eshell-mode-map (kbd "k") 'my/eshell-insert-history)

    (evil-define-key 'normal eshell-mode-map (kbd "C-p") 'eshell-previous-matching-input-from-input)
    (evil-define-key 'normal eshell-mode-map (kbd "C-n") 'eshell-next-matching-input-from-input)
    (evil-define-key 'insert eshell-mode-map (kbd "C-p") 'eshell-previous-matching-input-from-input)
    (evil-define-key 'insert eshell-mode-map (kbd "C-n") 'eshell-next-matching-input-from-input))

  (add-hook 'eshell-mode-hook 'my/bind-eshell-keys)
#+END_SRC

* Keys
** Key rebinds
#+BEGIN_SRC emacs-lisp
  (require 'evil-maps)
#+END_SRC

*** General
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'general)

  (general-evil-setup)
#+END_SRC

*** Language specific symbols
#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "M-w") '(lambda () (interactive) (my/fake-key "å" ?\å)))
  (define-key evil-insert-state-map (kbd "M-r") '(lambda () (interactive) (my/fake-key "ä" ?\ä)))
  (define-key evil-insert-state-map (kbd "M-j") '(lambda () (interactive) (my/fake-key "ö" ?\ö)))

  (define-key evil-insert-state-map (kbd "M-W") '(lambda () (interactive) (my/fake-key "Å" ?\å)))
  (define-key evil-insert-state-map (kbd "M-R") '(lambda () (interactive) (my/fake-key "Ä" ?\ä)))
  (define-key evil-insert-state-map (kbd "M-J") '(lambda () (interactive) (my/fake-key "Ö" ?\ö)))

  (define-key evil-replace-state-map (kbd "M-w") '(lambda () (interactive) (my/fake-key "å" ?\å)))
  (define-key evil-replace-state-map (kbd "M-r") '(lambda () (interactive) (my/fake-key "ä" ?\ä)))
  (define-key evil-replace-state-map (kbd "M-j") '(lambda () (interactive) (my/fake-key "ö" ?\ö)))

  (define-key evil-replace-state-map (kbd "M-W") '(lambda () (interactive) (my/fake-key "Å" ?\Å)))
  (define-key evil-replace-state-map (kbd "M-R") '(lambda () (interactive) (my/fake-key "Ä" ?\Ä)))
  (define-key evil-replace-state-map (kbd "M-J") '(lambda () (interactive) (my/fake-key "Ö" ?\Ö)))
#+END_SRC

*** Backspace/delete C-h, C-l
#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "C-h") 'backward-delete-char-untabify)
  (define-key evil-insert-state-map (kbd "C-l") 'delete-char)

  (define-key evil-replace-state-map (kbd "C-h") 'backward-delete-char-untabify)
  (define-key evil-replace-state-map (kbd "C-l") 'delete-char)
#+END_SRC

*** k(Move up) <--> p(Paste)
**** k
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "k" 'evil-paste-after)
  (my/evil-normal-define-key "K" 'evil-paste-before)

  (define-key evil-visual-state-map "k" 'evil-visual-paste)

  ;; Universal paste key
  (global-set-key (kbd "C-k") 'evil-paste-after)
  (global-set-key (kbd "C-K") 'evil-paste-before)
  (define-key evil-insert-state-map (kbd "C-k") 'evil-paste-after)
  (define-key evil-insert-state-map (kbd "C-K") 'evil-paste-before)

  (define-key evil-window-map "k" 'evil-window-mru)
#+END_SRC

**** p
#+BEGIN_SRC emacs-lisp
  (define-key evil-window-map "p" 'evil-window-up)
  (define-key evil-window-map "P" 'evil-window-move-very-top)

(my/evil-normal-define-key "p" 'evil-previous-line)

  ;; Rebind to make consistent with N
(my/evil-normal-define-key "P" 'delete-indentation)

  (define-key evil-window-map (kbd "C-S-p") 'evil-window-move-very-top)

(my/evil-normal-define-key "gp" 'evil-previous-visual-line)
#+END_SRC

*** n(search-next) <--> j(Move up)
**** n
#+BEGIN_SRC emacs-lisp
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "N" 'evil-window-move-very-bottom)

(my/evil-normal-define-key "n" 'evil-next-line)

(my/evil-normal-define-key "N" 'evil-join)


  ;; ex
  ;;  (evil-ex-define-cmd "j[oin]" 'evil-ex-join)
  ;;  (evil-ex-define-cmd "ju[mps]" 'evil-show-jumps)

(my/evil-normal-define-key "gN" 'evil-join-whitespace)

(my/evil-normal-define-key "gn" 'evil-next-visual-line)

  (define-key evil-window-map (kbd "C-S-n") 'evil-window-move-very-bottom)
#+END_SRC

**** j 
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "j" 'evil-search-previous)
  (my/evil-normal-define-key "J" 'evil-search-next)

  ;; ex
  ;;(evil-ex-define-cmd "new" 'evil-window-new)
  ;;(evil-ex-define-cmd "norm[al]" 'evil-ex-normal)
  ;;(evil-ex-define-cmd "noh[lsearch]" 'evil-ex-nohighlight)

  (my/evil-normal-define-key "gj" 'evil-next-match)
  (my/evil-normal-define-key "gJ" 'evil-previous-match)
#+END_SRC

*** Rebind save key
#+BEGIN_SRC emacs-lisp
  ;;(defun my/save-and-backup-buffer()
      ;;(interactive)
      ;;(my/force-backup-of-buffer)
      ;;(my/fake-open-keymap "C-x")
      ;;(my/fake-key (kbd "C-s") ?\C-s)
      ;;)


  (general-simulate-key "C-x C-s")

  (defun my/save-and-backup-buffer()
    (interactive)
    (my/force-backup-of-buffer)
    (general-simulate-C-x_C-s))

  (define-key my/leader-map (kbd "s") 'my/save-and-backup-buffer)
  (define-key my/leader-map (kbd "C-s") 'write-file)
#+END_SRC

*** Rebind C-d
#+BEGIN_SRC emacs-lisp
  (my/evil-normal-define-key "C-d" nil)
#+END_SRC

*** Rebind esc
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "<escape>") (kbd "C-e"))
  (define-key key-translation-map (kbd "C-e") (kbd "<escape>"))
#+END_SRC

*** Rebind enter
#+BEGIN_SRC emacs-lisp
;;  (define-key key-translation-map (kbd "RET") (kbd "C-a"))
  (define-key key-translation-map (kbd "C-a") (kbd "RET"))
#+END_SRC

*** Rebind tab
Use C-i instead
#+BEGIN_SRC emacs-lisp
  ;;(define-key my/keys-mode-map (kbd "C-e") 'my/simulate-esc)
  ;;(define-key key-translation-map (kbd "?\\t") (kbd "C-="))
  (define-key key-translation-map (kbd "TAB") (kbd "C-="))
  (define-key key-translation-map (kbd "<tab>") (kbd "C-="))
  (define-key key-translation-map (kbd "C-t") (kbd "TAB"))
  (define-key key-translation-map (kbd "M-C-t") (kbd "C-TAB"))
#+END_SRC

*** Rebind backspace
#+BEGIN_SRC emacs-lisp
  ;; (define-key key-translation-map (kbd "C-e") (kbd "TAB"))
  ;; (define-key key-translation-map (kbd "M-C-i") (kbd "C-TAB"))
#+END_SRC

* exwm
https://emacs.stackexchange.com/questions/33326/how-do-i-cut-and-paste-effectively-between-applications-while-using-exwm
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'exwm)

  (require 'exwm)
  ;;(require 'exwm-config)

  ;; Fix magit ediff
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; enable exwm
  (exwm-enable)

  (add-hook 'exwm-manage-finish-hook 'my/exwm-mode)
  (defun my/exwm-mode ()
    (interactive)
    ())
#+END_SRC

** Exwm-edit
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'exwm-edit)
  (require 'exwm-edit)
#+END_SRC

** Set exwm buffer name 
*** Manually set buffer name
#+BEGIN_SRC emacs-lisp
  (defun my/exwm-set-window-name ()
    (interactive)
    (exwm-workspace-rename-buffer (completing-read "set title " nil)))

  (define-key my/file-options-map (kbd "r") 'my/exwm-set-window-name)
#+END_SRC

*** Auto set buffer name
We use class names for all windows expect for Java applications and GIMP (because of problems with those).
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                         (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or
                     (not exwm-instance-name)
                     (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                     (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC

** Multi-screen

#+BEGIN_SRC emacs-lisp
  (require 'exwm-randr)
#+END_SRC

*** Get monitor setup
#+BEGIN_SRC emacs-lisp
  (exwm-randr-enable)

  (defun my/exwm-randr-auto-get-monitor ()
    (let* ((result)
           (monitors (nth 1 (exwm-randr--get-monitors))))
      (dotimes (i (/ (length monitors) 2))
        (push (nth (* i 2) monitors) result)
        (push i result))
      result))

  ;; Get monitor setup
  (if my/device/monitor-setup 
      (progn
        (setq exwm-workspace-number (/ (length my/device/monitor-setup) 2))
        (setq exwm-randr-workspace-monitor-plist my/device/monitor-setup)))
  ;;(let ((monitor-setup (my/exwm-randr-auto-get-monitor)))
  ;;(setq exwm-workspace-number (/ (length monitor-setup) 2))
  ;;(setq exwm-randr-workspace-monitor-plist monitor-setup)))

  ;; (exwm-randr-refresh)
#+END_SRC

*** Enable
#+BEGIN_SRC emacs-lisp
  (if (> exwm-workspace-number 1)
      (progn
        (exwm-randr-enable)))
#+END_SRC

*** Switch monitor (workspace) functions
#+BEGIN_SRC emacs-lisp
  ;; `exwm-workspace-number' is equal to monitor count
  ;;(add-hook 'focus-out-hook 'exwm-layout--refresh)
  (defun my/switch-monitor-left ()
    (interactive)
    (if (>= exwm-workspace-current-index (- exwm-workspace-number 1))
        (exwm-workspace-switch-create 0)
      (exwm-workspace-switch-create (+ exwm-workspace-current-index 1))))

  (defun my/switch-monitor-right ()
    (interactive)
    (if (= exwm-workspace-current-index 0)
        (exwm-workspace-switch-create (- exwm-workspace-number 1))
      (exwm-workspace-switch-create (- exwm-workspace-current-index 1))))

  ;;(define-key my/keys-mode-map (kbd "M-l") 'my/switch-monitor-right)
  ;;(define-key my/keys-mode-map (kbd "M-h") 'my/switch-monitor-left)
#+END_SRC

** Setting
#+BEGIN_SRC emacs-lisp
  ;; Garbage collect when entering x window (because x is not in sync with emacs)
  ;;(add-hook 'exwm-mode-hook 'garbage-collect)

  (setq exwm-workspace-show-all-buffers t)

  (setq exwm-workspace-minibuffer-position 'top)

  (add-hook 'exwm-init-hook (lambda () (interactive) (exwm-workspace-attach-minibuffer)))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key evil-emacs-state-map (kbd "TAB") 'nil)
  (global-unset-key (kbd "TAB"))
  ;; Rebind keys in exwm bufffers
  (setq exwm-input-simulation-keys
        '(
          ;; Delete char
          ([?\C-h] . [delete])
          ([?\C-l] . [backspace])
          ;; movement
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ;; ([?\C-u] . [prior])
          ;; ([?\C-w] . [next])
          ([?\C-w] . [?\C-d])

          ([?\C-s] . [?\C-f])

          ([?\C-a] . [return])
          ([?\r] . [return])

          ;;([?\C-e] . [?\C-[])
          ;; ([?\C-e] . [escape])
          ;; ([?\e] . [escape])

          ([?\C-t] . [tab])
          ([?\t] . [tab])

          ([?\C-g] . [escape])
          ;;([?\e] . [escape])

          ;; Firefox hard-coded open url hotkey
          ([?\C-o] . [f6])

          ;; Redo
          ([?\C-r] . [?\C-y])
          ;; Undo
          ([?\M-u] . [?\C-z])

          ;; cut/paste.
          ([?\C-y] . [?\C-c])
          ([?\C-k] . [?\C-v])

          ([?\M-w] . [?\C-å])
          ([?\M-r] . [?\C-ä])
          ([?\M-j] . [?\C-ö])))

  (setq exwm-input-prefix-keys nil)
  ;; Exwm don't send back these keys
  (dolist (k '(
               XF86AudioLowerVolume
               XF86AudioRaiseVolume
               XF86PowerOff
               XF86AudioMute
               XF86AudioPlay
               XF86AudioStop
               XF86AudioPrev
               XF86AudioNext
               XF86ScreenSaver
               XF68Back
               XF86Forward
               Scroll_Lock
               print
               ))
    (cl-pushnew k exwm-input-prefix-keys))

  ;; Some keys have to be defined using "exwm-input-set-key" in order to be usable if they are in "exwm-input-prefix-keys"
  (exwm-input-set-key (kbd my/mod-leader-map-key) 'my/leader-map)

  (exwm-input-set-key (kbd "M-<tab>") 'my/toggle-switch-to-minibuffer)
  ;;(exwm-input-set-key (kbd "C-M-=") 'my/toggle-switch-to-minibuffer)

  ;;(exwm-input-set-key (kbd "C-M-i") 'my/toggle-switch-to-minibuffer)

  (exwm-input-set-key (kbd "C-e") 'keyboard-quit)
  (exwm-input-set-key (kbd "<tab>") 'my/window-hydra/body)
  (exwm-input-set-key (kbd "C-=") 'my/window-hydra/body)
  (exwm-input-set-key (kbd "M-x") 'counsel-M-x)

  (exwm-input-set-key (kbd "M-h") 'previous-buffer)
  (exwm-input-set-key (kbd "M-l") 'next-buffer)

  ;; Enter and exit char mode
  ;; (exwm-input-set-key (kbd "M-a") 'exwm-input-grab-keyboard)
  ;; (exwm-input-set-key (kbd "M-i") 'exwm-input-release-keyboard)

  ;; Notes
  ;; (defun my/send-key(event)
  ;; (interactive "e")
  ;; (exwm-input--fake-key event))
  ;; (define-key 'my/leader-map (kbd "C-q") 'my/send-key)
  ;; 
  ;; (exwm-input--fake-key (event-basic-type ?\C-a))
#+END_SRC

* Shr
#+BEGIN_SRC emacs-lisp
  (require 'shr)
#+END_SRC

*** Highlight code
#+BEGIN_SRC emacs-lisp
  (defface my/eww-code-face
    '((t
       :family my/mono-font
       ))
    "Eww code face"
    :group 'eww-mode)

  (defun my/eww-tag-code (dom)
    (let ((start (point))
          (text (dom-text dom)))
      (insert text)
      (message text)
      (add-face-text-property start (point) 'my/eww-code-face)
      (insert " ")))
  (setq shr-external-rendering-functions '((code . my/eww-tag-code)))

  (defun my/eww-toggle-code-highlighting ()
    (interactive)
    (if (member '(code . my/eww-tag-code) shr-external-rendering-functions)
        (setq shr-external-rendering-functions (remove '(code . my/eww-tag-code) shr-external-rendering-functions))
      (add-to-list 'shr-external-rendering-functions '(code . my/eww-tag-code))))
#+END_SRC

*** Fix background colors shr
#+BEGIN_SRC emacs-lisp
  ;; Try fixing colors
  ;;(setq shr-color-visible-luminance-min 80)
  ;;(setq shr-color-visible-distance-min 5)

  ;; Fully disables colors
  (advice-add #'shr-colorize-region :around (defun shr-no-colourise-region (&rest ignore)))
#+END_SRC

*** Auto-open image at point
Redefine function to attempt to open image if link at point wasn't found
#+BEGIN_SRC emacs-lisp
  (defun shr-browse-url (&optional external mouse-event)
    "Browse the URL at point using `browse-url'.
  If EXTERNAL is non-nil (interactively, the prefix argument), browse
  the URL using `shr-external-browser'.
  If this function is invoked by a mouse click, it will browse the URL
  at the position of the click.  Optional argument MOUSE-EVENT describes
  the mouse click event."
    (interactive (list current-prefix-arg last-nonmenu-event))
    (mouse-set-point mouse-event)
    (let ((url (get-text-property (point) 'shr-url)))
      (cond
       ((not url)
       ;; Was unsuccessful in opening link, attempt to open image
        (shr-browse-image))
       ((string-match "^mailto:" url)
        (browse-url-mail url))
       (t
        (if external
            (funcall shr-external-browser url)
          (browse-url url))))))
#+END_SRC

* Browser
** Eww/shr
#+BEGIN_SRC emacs-lisp
  (require 'eww)
#+END_SRC

*** Add URL to buffer name
#+BEGIN_SRC emacs-lisp
  (add-hook 'eww-after-render-hook '(lambda () (interactive) (my/give-buffer-unique-name (concat "eww - " (plist-get eww-data :title)))))
#+END_SRC
      
*** Keys
#+BEGIN_SRC emacs-lisp
  ;; (define-key eww-mode-map [?\d] 'eww-back-url)
  ;; (evil-define-key 'normal eww-mode-map [?\d] 'eww-back-url)
  ;; (evil-define-key 'visual eww-mode-map [?\d] 'eww-back-url)

  (evil-define-key 'normal eww-mode-map (kbd "w") 'evil-forward-word-begin)
  (setq shr-map (make-sparse-keymap))

  (evil-define-key 'normal eww-mode-map (kbd "H") 'eww-back-url)
  (evil-define-key 'normal eww-mode-map (kbd "L") 'eww-forward-url)

  (define-prefix-command 'my/eww-mode-map)
  (evil-define-key 'normal eww-mode-map (kbd (concat my/leader-map-key " a")) 'my/eww-mode-map)

  (define-key my/eww-mode-map (kbd "d") 'eww-download)
  (define-key my/eww-mode-map (kbd "h") 'eww-history-browse)
  (define-key my/eww-mode-map (kbd "o") 'eww-open-in-new-buffer)
  (define-key my/eww-mode-map (kbd "r") 'eww-reload)
  (define-key my/eww-mode-map (kbd "f") 'eww-open-file)
  (define-key my/eww-mode-map (kbd "C-c") 'my/eww-toggle-code-highlighting)
#+END_SRC

** Firefox exwm integration
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'exwm
    (progn
      (straight-use-package '(exwm-firefox-core :type git :host github :repo "walseb/exwm-firefox-core"))
      (straight-use-package '(exwm-firefox-evil :type git :host github :repo "walseb/exwm-firefox-evil"))
      (require 'exwm-firefox-evil)

      ;; Auto enable exwm-firefox-evil-mode on all firefox buffers
      (add-hook 'exwm-manage-finish-hook 'exwm-firefox-evil-activate-if-firefox)

      ;; Run firefox buffers in normal mode
      (add-hook 'exwm-firefox-evil-mode-hook 'exwm-firefox-evil-normal)))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'exwm
    (progn
      (defun my/exwm-firefox-evil-link-hint ()
        (interactive)
        (exwm-input--fake-key ?f)
        (exwm-input-send-next-key 2))

   ;;; Normal
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "f") 'my/exwm-firefox-evil-link-hint)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-up)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-down)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "p") 'exwm-firefox-core-up)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "n") 'exwm-firefox-core-down)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-l") 'exwm-firefox-core-right)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-h") 'exwm-firefox-core-left)

      (evil-define-key 'motion exwm-firefox-evil-mode-map (kbd "C-l") 'exwm-firefox-core-right)
      (evil-define-key 'motion exwm-firefox-evil-mode-map (kbd "C-h") 'exwm-firefox-core-left)

      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-l") '(lambda () (interactive) (exwm-input--fake-key 'delete)))
      (evil-define-key 'insert  exwm-firefox-evil-mode-map (kbd "C-h") '(lambda () (interactive) (exwm-input--fake-key 'backspace)))

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "p") 'exwm-firefox-core-up)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "n") 'exwm-firefox-core-down)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-up)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-down)

      (evil-define-key 'motion exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-up)
      (evil-define-key 'motion exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-down)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-w") 'exwm-firefox-core-half-page-down)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "N") 'exwm-firefox-core-tab-next)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "P") 'exwm-firefox-core-tab-previous)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "s") 'exwm-firefox-core-tab-close)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "j") 'exwm-firefox-core-find-next)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "J") 'exwm-firefox-core-find-previous)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-s") 'exwm-firefox-core-quick-find)

      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
      (evil-define-key 'normal exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)

   ;;; Visual
      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "p") 'exwm-firefox-core-up-select)
      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "n") 'exwm-firefox-core-down-select)

      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-w") 'exwm-firefox-core-half-page-down-select)

      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "j") 'exwm-firefox-core-find-next)
      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "J") 'exwm-firefox-core-find-previous)

      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
      (evil-define-key 'visual exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)

   ;;; Insert
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-p") 'exwm-firefox-core-up-select)
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-n") 'exwm-firefox-core-down-select)

      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-u") 'exwm-firefox-core-half-page-up)
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-w") 'exwm-firefox-core-half-page-down)
    
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-w") '(lambda () (interactive) (exwm-input--fake-key ?\å)))
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-r") '(lambda () (interactive) (exwm-input--fake-key ?\ä)))
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "M-j") '(lambda () (interactive) (exwm-input--fake-key ?\ö)))

      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-y") 'exwm-firefox-core-copy)
      (evil-define-key 'insert exwm-firefox-evil-mode-map (kbd "C-k") 'exwm-firefox-core-paste)))
#+END_SRC

** Next browser
#+BEGIN_SRC emacs-lisp
  ;; (defun my/write-next-config ()
    ;; (my/create-dir-if-not-exist "~/.config")
    ;; (my/create-dir-if-not-exist "~/.config/next")
    ;; (my/create-file-with-content-if-not-exist "~/.config/next/init.lisp")
  ;; 
    ;; )
#+END_SRC

** Set default browser
#+BEGIN_SRC emacs-lisp
  (setq-default browse-url-browser-function 'eww-browse-url)
#+END_SRC

* Version control
** Projectile
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'projectile)

  ;; Disable projectile mode so that CPU isn't taken by projectile wating to refresh git project directory all the time
  (projectile-mode 0)
#+END_SRC

** Counsel projectile
If enabled it auto enables projectile, which has high CPU usage
#+BEGIN_SRC emacs-lisp
(straight-use-package 'counsel-projectile)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'magit)

  (setq git-commit-summary-max-length 50)
#+END_SRC

*** Forge
#+BEGIN_SRC emacs-lisp
  (straight-use-package '(forge :type git :host github :repo "magit/forge"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; Magit ignores this bind by default
  (require 'magit-mode)
  (define-key magit-mode-map (kbd "M-<tab>") 'my/toggle-switch-to-minibuffer)
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'diff-hl)

  (global-diff-hl-mode)

  ;; If there is no fringe (terminal), use margin instead
  (unless (display-graphic-p) (diff-hl-margin-mode))

  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)

  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

  ;;(diff-hl-flydiff-mode)
#+END_SRC

** Keys 
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'insert magit-mode-map (kbd "a") 'evil-append)

  (define-prefix-command 'my/vc-map)
  (define-key my/leader-map (kbd "v") 'my/vc-map)

  (define-key my/vc-map (kbd "n") 'diff-hl-next-hunk)
  (define-key my/vc-map (kbd "p") 'diff-hl-previous-hunk)

  (define-key my/vc-map (kbd "r") 'diff-hl-revert-hunk)
  (define-key my/vc-map (kbd "=") 'diff-hl-diff-goto-hunk)

  (define-key my/vc-map (kbd "o") 'counsel-git-grep)
  (define-key my/vc-map (kbd "a") 'counsel-projectile-ag)
  (define-key my/vc-map (kbd "d") 'projectile-dired)
  (define-key my/vc-map (kbd "D") 'counsel-projectile-find-dir)
  (define-key my/vc-map (kbd "f") 'counsel-projectile-find-file)

  (define-key my/vc-map (kbd "K") 'projectile-kill-buffers)
  (define-key my/vc-map (kbd "f") 'counsel-projectile-switch-to-buffer)
  (define-key my/vc-map (kbd "F") 'projectile-ibuffer)

  (define-key my/vc-map (kbd "S") 'projectile-save-project-buffers)
  (define-key my/vc-map (kbd "C") 'projectile-compile-project)

  (define-key my/vc-map (kbd "!") 'projectile-run-shell-command-in-root)
  (define-key my/vc-map (kbd "&") 'projectile-run-async-shell-command-in-root)

  (define-key my/vc-map (kbd "s") 'magit-status)
#+END_SRC

* Media
** Videos
*** Ivy-youtube
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'ivy-youtube)

  (setq ivy-youtube-play-at "mpv")

  (setq ivy-youtube-max-results 50)
  (setq ivy-youtube-history-file nil)

  (define-key my/leader-map (kbd "y") 'ivy-youtube)
#+END_SRC

**** Play video at max audio quality
#+BEGIN_SRC emacs-lisp
  (setq mpv-youtube-dl-parameters
        (concat
         ;; Video
         "--ytdl-format="
         ;; Prefer free format and my resolution
         "((bestvideo[height<=?" (int-to-string (car (cdr my/device/resolution))) "][vcodec^=vp9]"
         ;; Then just my resolution
         "/bestvideo[height<=?" (int-to-string (car (cdr my/device/resolution))) "]"
         ;; Then just any video
         "/bestvideo)"

         ;; Audio
         ;; Prefer free formats
         "+(bestaudio[acodec=opus]"
         "/bestaudio[acodec=vorbis]"
         "/bestaudio[acodec=aac]"
         ;; Then just any audio format
         "/bestaudio))"
         "/best"))

  (defun ivy-youtube-play-on-process (video-url)
    "Start a process based on ivy-youtube-play-at variable passing VIDEO-URL."
    (message (format "Starting a process with: [%s %s] with youtube-dl parameters: %s" ivy-youtube-play-at video-url mpv-youtube-dl-parameters))
    (make-process :name "Ivy Youtube"
                  :buffer "*Ivy Youtube Output*"
                  :sentinel (lambda (process event)
                              (message
                               (format "Ivy Youtube: Process %s (Check buffer *Ivy Youtube Output*)" event)))
                  :command `(,ivy-youtube-play-at ,mpv-youtube-dl-parameters ,video-url)))
#+END_SRC

** Volume keys
#+BEGIN_SRC emacs-lisp
  (defvar my/audio-sink nil)
  ;; Pulse sometimes first starts when a video, etc starts
  (defun my/pulse-update-audio-sink ()
    (interactive)
    (setq my/audio-sink (substring (shell-command-to-string "pacmd list-sinks | grep \"\* index\"") (string-match "[0-9]" (shell-command-to-string "pacmd list-sinks | grep \"index\"")) -1)))

  (defun my/pulse-mute-toggle ()
    (interactive)
    (my/pulse-update-audio-sink)
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " toggle")))

  (global-set-key (kbd "<XF86AudioMute>") 'my/pulse-mute-toggle)
  (global-set-key (kbd "s-`") 'my/pulse-mute-toggle)

  (defun my/pulse-raise-volume ()
    (interactive)
    (my/pulse-update-audio-sink)
    ;; Unmute
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
    (shell-command (concat "pactl set-sink-volume " my/audio-sink " +2.5%")))

  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'my/pulse-raise-volume)
  (global-set-key (kbd "s-=") 'my/pulse-raise-volume)

  (defun my/pulse-lower-volume ()
    (interactive)
    (my/pulse-update-audio-sink)
    ;; Unmute
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
    (shell-command (concat "pactl set-sink-volume " my/audio-sink " -2.5%")))

  (global-set-key (kbd "<XF86AudioLowerVolume>") 'my/pulse-lower-volume)

  (global-set-key (kbd "s--") 'my/pulse-lower-volume)
#+END_SRC

#+RESULTS:
: my/pulse-lower-volume

** Music
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/music-map)
  (define-key my/leader-map (kbd "m") 'my/music-map)
#+END_SRC

*** EMMS
Setup emms
#+BEGIN_SRC emacs-lisp
  (defvar my/emms-has-init nil)

  (defvar my/emms-init-hook nil
    "Hook called when emms has to init fully")

  (straight-use-package 'emms)


  (add-hook 'my/emms-init-hook (lambda () (interactive)
                                 (unless my/emms-has-init
                                   (setq my/emms-has-init t)
                                   (require 'emms-setup)
                                   (require 'emms-player-mpd)

                                   (emms-all) 
                                   ;; Disable name of playing track in modeline (time is kept though)
                                   (emms-mode-line-disable))))

  (setq emms-mode-line-format nil)

  (setq emms-seek-seconds 5)
  (setq emms-player-list '(emms-player-mpd))
  (setq emms-info-functions '(emms-info-mpd))

  (setq emms-player-mpd-server-name "localhost")
  (setq emms-player-mpd-server-port "6600")

  ;;(setq mpc-host "localhost:6600")
#+END_SRC

**** Sort by directory name instead of metadata
#+BEGIN_SRC emacs-lisp
  (setq emms-browser-get-track-field-function 'emms-browser-get-track-field-use-directory-name)
#+END_SRC

**** Open playlist
emms doesn't automatically connect to mpd when loading playlist, results in empty playlist
#+BEGIN_SRC emacs-lisp
  (defun my/open-emms-and-connect()
    "Reconnect to MPD and open emms playlist"
    (interactive)
    (run-hooks 'my/emms-init-hook)
    (emms-player-mpd-connect)
    (emms-smart-browse))
#+END_SRC

**** Sync MPD and emms
#+BEGIN_SRC emacs-lisp
  (defun my/sync-mpd-and-emms ()
    "Updates the MPD and emms database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (emms-player-mpd-update-all-reset-cache)
    (emms-cache-set-from-mpd-all)
    (emms-player-mpd-connect)
    (message "MPD database and emms updated!"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (require 'emms-browser)
  (define-key my/music-map (kbd "u") 'my/sync-mpd-and-emms) 

  (define-key my/music-map (kbd "o") 'my/open-emms-and-connect)
  (define-key my/music-map (kbd "g") 'emms-seek-to)
  (define-key my/music-map (kbd "s") 'emms-pause)

  (define-key emms-browser-mode-map (kbd "s") 'emms-pause)

  (evil-define-key 'normal emms-browser-mode-map (kbd "RET") 'emms-browser-add-tracks)

  (evil-define-key 'normal emms-playlist-mode-map (kbd "RET") 'emms-playlist-mode-play-smart)

  (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause)
  (global-set-key (kbd "<XF86AudioStop>") 'emms-stop)
#+END_SRC

*** MPD
**** Start MPD
#+BEGIN_SRC emacs-lisp
  (defun my/start-mpd ()
    "Start MPD, connect to it and sync the metadata cache."
    (interactive)
    (start-process "mpd" nil "mpd")
    (message "MPD started and synced!"))
#+END_SRC

**** Kill daemon
#+BEGIN_SRC emacs-lisp
 (defun my/kill-music-daemon ()
   "Stops playback and kill the music daemon."
   (interactive)
   (emms-stop)
   (call-process "killall" nil nil nil "mpd")
   (message "MPD killed!"))
#+END_SRC

**** View MPD info
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-info ()
    "Runs mpc, showing info in message field"
    (interactive)
    (shell-command "mpc"))
#+END_SRC

**** Shuffle playlist random
***** Random on
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-on ()
    "Turns on MPD random play"
    (interactive)
    (shell-command "mpc random on"))
#+END_SRC

***** Random off
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-off ()
    "Turns off MPD random play"
    (interactive)
    (shell-command "mpc random off"))
#+END_SRC

**** Volume control
***** Raise volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-raise-volume()
  (interactive)
  (shell-command "mpc volume +4"))
#+END_SRC

***** Lower volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-lower-volume ()
  (interactive)
  (shell-command "mpc volume -4"))
#+END_SRC

**** Change song
***** Next song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-next-song()
  (interactive)
  (shell-command "mpc next"))
#+END_SRC

***** Previous song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-previous-song()
  (interactive)
  (shell-command "mpc prev"))
#+END_SRC

**** Change time on track
***** Forward
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-forward()
    (interactive)
    (shell-command "mpc seek +10"))
#+END_SRC

***** Forward far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-forward()
    (interactive)
    (shell-command "mpc seek +60"))
#+END_SRC

***** Backwards
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-backward()
    (interactive)
    (shell-command "mpc seek -10"))
#+END_SRC

***** Backwards far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-backward()
    (interactive)
    (shell-command "mpc seek -60"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/music-map (kbd "C-s") 'my/start-mpd)
  (define-key my/music-map (kbd "C-k") 'my/kill-music-daemon)
  (define-key my/music-map (kbd "i") 'my/mpd-info)

  (define-key my/music-map (kbd "r") 'my/mpd-random-on)
  (define-key my/music-map (kbd "C-r") 'my/mpd-random-off)

  (define-key my/music-map (kbd "=") 'my/mpd-raise-volume)
  (define-key my/music-map (kbd "-") 'my/mpd-lower-volume)

  (define-key my/music-map (kbd "n") 'my/mpd-next-song)
  (define-key my/music-map (kbd "p") 'my/mpd-previous-song)

  (define-key my/music-map (kbd "l") 'my/mpd-wind-forward)
  (define-key my/music-map (kbd "h") 'my/mpd-wind-backward)
  (define-key my/music-map (kbd "L") 'my/mpd-wind-far-forward)
  (define-key my/music-map (kbd "H") 'my/mpd-wind-far-backward)

  (global-set-key (kbd "<XF86AudioNext>") 'my/mpd-next-song)
  (global-set-key (kbd "<XF86AudioPrev>") 'my/mpd-previous-song)
#+END_SRC

* Screenshots
** Functions
*** Entire screen
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
      (sit-for 1)
      (start-process "screenshot" nil "import" "-window" "root" 
                     (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))))
#+END_SRC

*** Region
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC 

*** Region ask for name
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region-and-ask-for-name ()
    "Takes a screenshot of a region selected by the user and asks for file path"
    (interactive)
    (when window-system

      ;; Check if there is a directory called "images" in current dir, if so start read-file-name inside that directory
      (if(file-exists-p (concat default-directory "images/"))
          (setq screenshot-base-path (concat default-directory "images/"))
        (setq screenshot-base-path default-directory))

      ;; If screenshot path is not empty
      (call-process "import" nil nil nil ".newScreen.png")

      ;; Ask for path
      (setq screenshot-path (read-file-name "Screenshot file (.png already added) " screenshot-base-path))

      (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1" (concat screenshot-path ".png"))
      (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<print>") 'my/take-screenshot-region-and-ask-for-name)

  ;;  (define-key my/leader-map (kbd "p r") 'my/take-screenshot-region)
  ;;  (define-key my/leader-map (kbd "p w") 'my/take-screenshot)
#+END_SRC

* Mail
** Gnus
.gnus.el is written in =write config map=
https://github.com/gongzhitaao/GnusSolution
https://www.gnu.org/software/emacs/manual/html_node/gnus/Comparing-Mail-Back-Ends.html
#+BEGIN_SRC emacs-lisp
  (require 'gnus)
  (define-key my/open-map (kbd "g") 'gnus)

  ;; Encrypt passwords
  (setq netrc-file "~/.authinfo.gpg")

  (setq gnus-use-full-window nil)
#+END_SRC

*** Sources
#+BEGIN_SRC emacs-lisp
  ;; If dovecot server is setup
  (if (my/is-system-package-installed 'dovecot)
      (setq gnus-select-method '(nnimap "Dovecot"
                                        (nnimap-stream network)
                                        (nnimap-address "localhost")
                                        (nnimap-authenticator login)
                                        (nnimap-user "admin"))))

  (setq gnus-secondary-select-methods
        '((nntp "news.gmane.org")))

  (setq mail-user-agent 'gnus-user-agent)
  (setq read-mail-command 'gnus)
  (setq send-mail-function 'message-send-mail-with-sendmail)
  (setq sendmail-program "msmtp")

  ;; (setq smtpmail-smtp-server "smtp.gmail.com"
  ;; smtpmail-smtp-service 587
  ;; ;; Make Gnus NOT ignore [Gmail] mailboxes
  ;; gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
#+END_SRC

*** Minor settings
#+BEGIN_SRC emacs-lisp
  ;;Fix bug in gnus, Replace [ and ] with _ in ADAPT file names
  ;;(setq nnheader-file-name-translation-alist '((?[ . ?_) (?] . ?_)) )

  ;; Maybe disable later
  ;;(setq gnus-save-killed-list nil)

  (setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))

  ;; '(gnus-always-force-window-configuration t)

  ;; Disable signatures
  (setq message-signature nil)

  ;; never split messages
  (setq message-send-mail-partially-limit nil)

  ;; Disable gnus expiration
  (setq gnus-agent-enable-expiration 'DISABLE)

  ;; Create two connections to the server for faster fetching
  (setq gnus-asynchronous t)

  ;; Disable .newsrc file (file can be read by other newsreaders)
  (setq gnus-read-newsrc-file nil)
  (setq gnus-save-newsrc-file nil)

  (setq gnus-completing-read-function 'gnus-emacs-completing-read)
#+END_SRC

*** Group mode
Mode for choosing server
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-group-mode ()
    ;; Tree view for groups.
    (gnus-topic-mode)
    ;; List all groups over level 5
    (gnus-group-list-all-groups 5))

  (add-hook 'gnus-group-mode-hook 'my/gnus-group-mode)

  ;; Always show inbox
  ;; (setq gnus-permanently-visible-groups "INBOX")

  ;; Apparently only some servers support using 'some
  ;;(setq gnus-read-active-file 't)
   ;;(setq gnus-read-active-file 'some)
   ;;(setq gnus-check-new-newsgroups 'ask-server)
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal gnus-group-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-group-mode-map (kbd "RET") (lambda () (interactive) (gnus-topic-select-group t)))
  (evil-define-key 'normal gnus-group-mode-map (kbd "TAB") 'gnus-topic-select-group)
  (evil-define-key 'insert gnus-group-mode-map (kbd "TAB") 'gnus-topic-select-group)

  (define-prefix-command 'my/gnus-group-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-group-map)

  (defun my/gnus-group-list-all-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key 'my/gnus-group-map (kbd "s") 'my/gnus-group-list-all-subscribed-groups)
#+END_SRC

*** Topic mode
Adds headers to each server, tree view
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-topic-mode ()
    (my/gnus-topic-setup)
    (my/gnus-topic-add-gmane-groups))

  (add-hook 'gnus-topic-mode-hook 'my/gnus-topic-mode)
#+END_SRC

**** Subscribe to gmane groups
#+BEGIN_SRC emacs-lisp
  (defvar my/gnus-topic-gmane-prefix "nntp+news.gmane.org:")

  (setq my/gnus-gmane-subscribed-emacs `(
                                         ;; Gnus
                                         ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.help") ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.general") ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.announce") ,(concat my/gnus-topic-gmane-prefix "gmane.emacs.gnus.user")))

  (setq my/gnus-gmane-subscribed-emacs-blogs `(
                                               ,(concat my/gnus-topic-gmane-prefix "gwene.com.oremacs") ,(concat my/gnus-topic-gmane-prefix "gwene.me.emacsair")))

  (setq my/gnus-gmane-subscribed-fsharp `(
                                          ;; Gnus
                                          ,(concat my/gnus-topic-gmane-prefix "gwene.com.reddit.pay.r.fsharp")))

  (setq my/gnus-gmane-subscribed-guile `(
                                         ;; Gnus
                                         ,(concat my/gnus-topic-gmane-prefix "gmane.lisp.guile.user")))

  (defun my/gnus-gmane-subscribed-get()
    (append
     my/gnus-gmane-subscribed-guile
     my/gnus-gmane-subscribed-fsharp
     my/gnus-gmane-subscribed-emacs-blogs
     my/gnus-gmane-subscribed-emacs))

  (defun my/gnus-topic-add-gmane-groups ()
    (let ((list (my/gnus-gmane-subscribed-get)))
      (dotimes (i (+ 1 (length list)))
        (add-to-list 'gnus-newsrc-alist `(,(nth i list) 3 nil nil "nntp:news.gmane.org"))))

    ;; Move the dummy entry to the top
    (setq gnus-newsrc-alist (delete '("dummy.group" 0 nil) gnus-newsrc-alist))
    ;; We don't need the dummy group?
    ;;(add-to-list 'gnus-newsrc-alist '("dummy.group" 0 nil))
    )
#+END_SRC

**** Topic setup
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-topic-setup ()
    "Hides non-relevant servers and puts them into categories. To show all servers, disable my/gnus-topic-mode"

    ;; "Gnus" is the root folder, and there are three mail accounts, "misc", "hotmail", "gmail"
    (setq gnus-topic-topology '
          (("Gnus" visible)

           ;; Mail
           (("Mail" visible)
            (("gmail" visible))
            (("gmail-main" visible)))

           ;; News
           (("News" visible)
            (("Emacs" visible)
             (("Emacs blogs" visible)))
            (("Fsharp" visible))
            (("Guile" visible))
            )))

    (setq gnus-topic-alist `((("Gnus"))
                             ;; Mail
                             ("gmail-main"
                              "main-gmail/All"
                              "main-gmail/Sent"
                              "main-gmail/Starred"
                              "main-gmail/Trash")

                             ;; News
                             ,(append '("Emacs") my/gnus-gmane-subscribed-emacs)
                             ,(append '("Emacs blogs") my/gnus-gmane-subscribed-emacs-blogs)
                             ,(append '("Fsharp") my/gnus-gmane-subscribed-fsharp)
                             ,(append '("Guile") my/gnus-gmane-subscribed-guile)
                             )))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-topic-map)
  (evil-define-key 'normal gnus-topic-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-topic-map)
#+END_SRC

*** Summary mode
Mode for choosing which mail to open
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-summary-mode ()
    (setq truncate-lines t)
    (my/toggle-local-mono-font t))

  (add-hook 'gnus-summary-mode-hook 'my/gnus-summary-mode)

  ;; '(gnus-summary-mode-line-format "U%U %S" )
  ;; https://www.gnu.org/software/emacs/manual/html_node/gnus/Summary-Buffer-Lines.html
  (setq-default gnus-summary-line-format
                (concat
                 ;; Is unread
                 "%U"
                 ">"
                 ;; Total thread score
                 "%V"
                 ;; Has been replied to/cached/saved
                 "%R"
                 ;; Tab
                 "\t"
                 ;; Date as specified by `gnus-user-date-format-alist`
                 "%&user-date; \t"
                 ;; Linecount, leave -5,5 spacing
                 "%-5,5L"
                 ;; Sender taken from header, leave -20,20 spacing
                 "%-20,20n"

                 "\t"
                 ;; Reply tree
                 "%B"
                 ;; Article subject string
                 "%-80,80S"
                 ;; End
                 "\n"))

  (setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))
  (setq gnus-thread-sort-functions '(gnus-thread-sort-by-date))
  
  ;; Supposed to be better
  (setq-default gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)

  (setq gnus-sum-thread-tree-false-root ""
        gnus-sum-thread-tree-single-indent ""
        gnus-sum-thread-tree-root ""
        gnus-sum-thread-tree-vertical"|"
        gnus-sum-thread-tree-leaf-with-other "+-> "
        gnus-sum-thread-tree-single-leaf"\\-> "
        gnus-sum-thread-tree-indent " ")

  ;; '(gnus-thread-hide-subtree t)
  ;; '(gnus-thread-sort-functions (quote gnus-thread-sort-by-most-recent-date))
  ;; '(gnus-treat-hide-citation t)
  ;; '(gnus-unread-mark 42)
  ;; '(gnus-ancient-mark 32)
#+END_SRC

**** Visuals
#+BEGIN_SRC emacs-lisp
 ;; '(gnus-summary-high-unread ((t (:foreground "green"))))
 ;; '(gnus-summary-low-read ((t (:foreground "magenta"))))
 ;; '(gnus-summary-normal-read ((t (:foreground "red"))))
 ;; '(gnus-summary-selected ((t (:background "yellow"))))
 ;; '(gnus-summary-normal-unread ((t (:foreground "white"))))
#+END_SRC

**** Scoring
#+BEGIN_SRC emacs-lisp
(setq gnus-parameters
      '(("nnimap.*"
         (gnus-use-scoring nil)) ;; Enable later
        ))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-summary-map)
  (evil-define-key 'normal gnus-summary-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-summary-map)

  (evil-define-key 'normal gnus-summary-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-summary-mode-map (kbd "RET") 'gnus-summary-scroll-up)

  (defun my/gnus-summary-show-all-mail ()
    "Show all mail"
    (interactive)
    (gnus-summary-rescan-group 1))

  (define-key 'my/gnus-summary-map (kbd "s") 'my/gnus-summary-show-all-mail)
#+END_SRC

*** Article mode
Mode for reading contents of mail
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-article-mode ()
    ;; Font lock mode disables colors in html mail for whatever reason
    (font-lock-mode -1))

  (add-hook 'gnus-article-mode-hook 'my/gnus-article-mode)

  ;;(defun my/gnus-article-display-mode ()
  ;;  (gnus-article-de-quoted-unreadable)
  ;;  (gnus-article-emphasize)
  ;;  (gnus-article-hide-boring-headers)
  ;;  (gnus-article-hide-headers-if-wanted)
  ;;  (gnus-article-hide-pgp)
  ;;  (gnus-article-highlight)
  ;;  (gnus-article-highlight-citation)
  ;;  (gnus-article-date-local)
  ;;)

  (add-hook 'gnus-article-display-hook 'my/gnus-article-display-mode)

   ;; '(gnus-article-mode-line-format "U%U %S" )
#+END_SRC

**** Date headers
Make date headers better with timezone calculation and time passed
#+BEGIN_SRC emacs-lisp

(setq gnus-article-date-headers '(user-defined)
      gnus-article-time-format
      (lambda (time)
        (let* ((date (format-time-string "%a, %d %b %Y %T %z" time))
               (local (article-make-date-line date 'local))
               (combined-lapsed (article-make-date-line date
                                                        'combined-lapsed))
               (lapsed (progn
                         (string-match " (.+" combined-lapsed)
                         (match-string 0 combined-lapsed))))
          (concat local lapsed))))
#+END_SRC

**** Mail renderers, etc
#+BEGIN_SRC emacs-lisp
;; html renderer
(setq mm-text-html-renderer 'shr)
;; Inline images?
(setq mm-attachment-override-types '("image/.*"))
;; No HTML mail
(setq mm-discouraged-alternatives '("text/html" "text/richtext"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-article-map)
  (evil-define-key 'normal gnus-article-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-article-map)
#+END_SRC

*** Browse server mode
**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-browse-mode-map)
  (evil-define-key 'normal gnus-browse-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-browse-mode-map)

  (evil-define-key 'normal gnus-browse-mode-map (kbd "RET") 'gnus-browse-select-group)
#+END_SRC

*** Server mode
**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-server-mode-map)
  (evil-define-key 'normal gnus-server-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-server-mode-map)

  (evil-define-key 'normal gnus-server-mode-map (kbd "RET") 'gnus-server-read-server)
#+END_SRC

*** Message mode
Mode for writing mail

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-message-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-message-map)
#+END_SRC

*** Misc
**** Random color gnus logo
#+BEGIN_SRC emacs-lisp
  (random t) ; Randomize sequence of random numbers
  (defun my/random-hex (&optional num)
    (interactive "P")
    (let (($n (if (numberp num) (abs num) 6 )))
      (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n))))))

  (setq gnus-logo-colors (list (concat "#" (my/random-hex 6)) (concat "#" (my/random-hex 6))))
#+END_SRC

** mbsync
#+BEGIN_SRC emacs-lisp
  (defvar my/sync-mail-hook nil)
  (defvar my/sync-mail-has-begun nil)

  (defun my/sync-mail ()
    (interactive)
    (async-shell-command "mbsync -a")
    (run-with-timer 0 nil (lambda () (interactive) (run-hooks 'my/sync-mail-hook))))


  (add-hook 'gnus-topic-mode-hook 'my/sync-mail-begin)

  (defun my/sync-mail-begin ()
    (if (my/is-system-package-installed 'mbsync)
        (run-with-timer 10 300 'my/sync-mail)))
#+END_SRC

** Display unread mail count
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-scan-unread ()
    (if (get-buffer "*Group*")
        (gnus-group-get-new-news)
      (gnus)))

  (defun my/gnus-get-unread-mail-count ()
    (my/gnus-get-unread "Mail"))

    (defun my/gnus-get-unread-news-count ()
      (my/gnus-get-unread "News"))

  (defun my/gnus-get-unread (inbox)
    (let ((result ""))
      (dotimes (i (length gnus-topic-unreads))
        (if (string= inbox (car (nth i gnus-topic-unreads)))
            (progn
              (setq result (number-to-string (cdr (nth i gnus-topic-unreads))))
              (setq i (length gnus-topic-unreads)))))
      result))
#+END_SRC

* System
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-commands-map)
  (define-key my/leader-map (kbd "~") 'my/system-commands-map)
#+END_SRC

** Suspend
  #+BEGIN_SRC emacs-lisp
    (define-prefix-command 'my/system-suspend-map)
    (define-key my/system-commands-map (kbd "s") 'my/system-suspend-map)

    (defun my/systemd-suspend-PC()
      (interactive)
      (shell-command "systemctl suspend"))
    (define-key my/system-suspend-map (kbd "C-s") 'my/systemd-suspend-PC)

    (defun my/systemd-hibernate-PC()
      (interactive)
      (shell-command "systemctl hibernate"))
      ;; Never used
    ;;(define-key my/system-suspend-map (kbd "C-h") 'my/systemd-hibernate-PC)
#+END_SRC

** Multi-monitor
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-monitor-map)
  (define-key my/system-commands-map (kbd "m") 'my/system-monitor-map)

  (defun my/x-suspend-monitor()
    (interactive)
    (shell-command "xset dpms force suspend"))
  (define-key my/system-monitor-map (kbd "s") 'my/x-suspend-monitor)

  (defun my/print-monitors ()
    (interactive)
    (shell-command "xrandr"))
  (define-key my/system-monitor-map (kbd "p") 'my/print-monitors)

  (defun my/monitor-home-setup ()
    (interactive)
    (shell-command "xrandr --output DP-1 --mode 2560x1440 --rate 60 --left-of DVI-D-1 --output DVI-D-1 --mode 1280x800 --rate 59.81"))
  (define-key my/system-monitor-map (kbd "h") 'my/monitor-home-setup)

  (defun my/auto-connect-screen ()
    (interactive)
    (with-temp-buffer
      (call-process "xrandr" nil t nil)
      (beginning-of-buffer)
      (if (search-forward "VGA1 connected" nil 'noerror)
          (start-process-shell-command
           "xrandr" nil "xrandr --output VGA1 --primary --auto --output LVDS1 --off")
        (start-process-shell-command
         "xrandr" nil "xrandr --output LVDS1 --auto"))))

  (define-key my/system-monitor-map (kbd "a") 'my/auto-connect-screen)

  (if (window-system)
      (async-shell-command my/device/monitor-setup-command "xrandr setup buffer"))
#+END_SRC

** Process monitors
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/processes-map)
  (define-key my/system-commands-map (kbd "p") 'my/processes-map)
#+END_SRC

*** Top - proced
#+BEGIN_SRC emacs-lisp
  (define-key my/processes-map (kbd "t") 'proced)
#+END_SRC

**** Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'proced-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

**** Disable line wrapping
#+BEGIN_SRC emacs-lisp
  (defun my/proced-mode ()
    (interactive)
    (toggle-truncate-lines 1))

  ;;(add-hook 'proced-post-display-hook 'my/proced-mode)
  (add-hook 'proced-mode-hook 'my/proced-mode)
#+END_SRC

*** Profiler
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/profiler-map)
  (define-key my/processes-map (kbd "p") 'my/profiler-map)

  (define-key my/profiler-map (kbd "s") 'profiler-start)
  (define-key my/profiler-map (kbd "e") 'profiler-stop)
  (define-key my/profiler-map (kbd "r") 'profiler-report)
#+END_SRC

* Networking
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/net-utils-map)
  (define-key my/system-commands-map (kbd "n") 'my/net-utils-map)
#+END_SRC

TODO counsel-tramp

** Tramp
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC

** Netstat
#+BEGIN_SRC emacs-lisp
  (defun my/net-utils-mode ()
    (interactive)
    (toggle-truncate-lines 1))

  (add-hook 'net-utils-mode-hook 'my/net-utils-mode)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/net-utils-map (kbd "s") 'netstat)
  (define-key my/net-utils-map (kbd "p") 'ping)
  (define-key my/net-utils-map (kbd "i") 'ifconfig)
#+END_SRC

* Hardware
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/hardware-info-map)
  (define-key my/system-commands-map (kbd "h") 'my/hardware-info-map)

  ;; Memory
  (defun my/unix-get-memory-available()
    (interactive)
    (shell-command "grep \"MemAvailable\" /proc/meminfo"))
  (define-key my/hardware-info-map (kbd "m") 'my/unix-get-memory-available)

  ;; GPU
  (defun my/unix-get-gpu()
    (interactive)
    (shell-command "lspci | grep ' VGA ' | cut -d\" \" -f 1 | xargs -i lspci -v -s {}"))
  (define-key my/hardware-info-map (kbd "g") 'my/unix-get-gpu)

  ;; Blocked devices
  (defun my/rfkill-get-blocked-devices()
    (interactive)
    (shell-command "rfkill list"))
  (define-key my/hardware-info-map (kbd "b") 'my/rfkill-get-blocked-devices)

  ;; Get devices
  (defun my/rfkill-get-devices()
    (interactive)
    (shell-command "cat /proc/devices"))
  (define-key my/hardware-info-map (kbd "d") 'my/rfkill-get-devices)
#+END_SRC

** CPU
#+BEGIN_SRC emacs-lisp
  ;; Linux temps
  (if (file-exists-p "/proc/cpuinfo") (progn
                                        (define-prefix-command 'my/cpu-info-map)
                                        (define-key my/hardware-info-map (kbd "c") 'my/cpu-info-map)

                                        (defun my/unix-cpu-get-clock()
                                          (interactive)
                                          (shell-command "grep \"cpu MHz\" /proc/cpuinfo"))
                                        ;; Clock speed
                                        (define-key my/cpu-info-map (kbd "f") 'my/unix-cpu-get-clock)
                                        ;; Model name
                                        (defun my/unix-cpu-get-name()
                                          (interactive)
                                          (shell-command "grep \"model name\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "n") 'my/unix-cpu-get-name)
                                        ;; Core count
                                        (defun my/unix-cpu-get-core-count()
                                          (interactive)
                                          ;; Linux
                                          (shell-command "grep \"cores\" /proc/cpuinfo"))

                                        (define-key my/cpu-info-map (kbd "c") 'my/unix-cpu-get-core-count)
                                        ;; Flags
                                        (defun my/unix-cpu-get-flags()
                                          (interactive)
                                          (shell-command "grep \"flags\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "F") 'my/unix-cpu-get-flags)
                                        ;; Vendor
                                        (defun my/unix-cpu-get-vendor-id()
                                          (interactive)
                                          (shell-command "grep \"vendor_id\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "v") 'my/unix-cpu-get-vendor-id)
                                        ;; Bugs (Bugs that has affected CPU model)
                                        (defun my/unix-cpu-get-bugs()
                                          (interactive)
                                          (shell-command "grep \"bugs\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "b") 'my/unix-cpu-get-bugs)
                                        ;; Cache size
                                        (defun my/unix-cpu-get-cache-size()
                                          (interactive)
                                          (shell-command "grep \"cache size\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "C") 'my/unix-cpu-get-cache-size)))

  ;; Windows cpu core count
  ;; (if (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
      ;; (let ((number-of-processors (getenv "NUMBER_OF_PROCESSORS")))
        ;; (if number-of-processors
            ;; (string-to-number number-of-processors))))
#+END_SRC

* Find
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/find-map)
  (define-key my/leader-map (kbd "F") 'my/find-map)

  (define-key my/find-map (kbd "l") 'counsel-locate)

  (define-key my/find-map (kbd "g") 'counsel-ag)
#+END_SRC

* Spelling
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/spell-map)
  (define-key my/leader-map (kbd "C-l") 'my/spell-map)

  (defun my/toggle-company-ispell ()
    (interactive)
    (cond
     ((memq 'company-ispell company-backends)
      (setq company-backends (delete 'company-ispell company-backends))
      (message "company-ispell disabled"))
     (t
      (add-to-list 'company-backends 'company-ispell)
      (message "company-ispell enabled!"))))

  (define-key my/spell-map (kbd "l") 'ispell-change-dictionary)
  (define-key my/spell-map (kbd "s") 'flyspell-mode)
  (define-key my/spell-map (kbd "c") 'my/toggle-company-ispell)
#+END_SRC

* Calc
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "c") 'calc)

  (defun my/calc-kill-current-line ()
    (interactive)
    (calc-kill-region (line-beginning-position) (line-end-position)))

  (evil-define-key 'normal calc-mode-map (kbd "d d") 'my/calc-kill-current-line)
  (evil-define-key 'visual calc-mode-map (kbd "d") 'calc-kill-region)
#+END_SRC

* Artist mode
** Disable and restore modes aftere entering and exiting artist mode
https://www.emacswiki.org/emacs/FacesPerBuffer
#+BEGIN_SRC emacs-lisp
  (defvar my/artist-mode-highlight-thing-restore nil)
  (defvar my/artist-mode-aggressive-indent-restore nil)
  (defvar my/artist-mode-display-line-numbers-restore nil)

  (defvar my/artist-mode-restore-buffer nil)

  (defun my/artist-mode ()
    (if (eq major-mode 'picture-mode)
        (progn
          (setq my/artist-mode-restore-buffer (current-buffer))
          (if highlight-thing-mode
              (progn
                (highlight-thing-mode -1)
                (setq my/artist-mode-highlight-thing-restore t))
            (setq my/artist-mode-highlight-thing-restore nil))

          (if aggressive-indent-mode
              (progn
                (aggressive-indent-mode -1)
                (setq my/artist-mode-aggressive-indent-restore t))
            (setq my/artist-mode-aggressive-indent-restore nil))

          (if display-line-numbers
              (progn
                (display-line-numbers-mode -1)
                (setq my/artist-mode-display-line-numbers-restore t))
            (setq my/artist-mode-display-line-numbers-restore nil))

          (evil-emacs-state)

          (if (not my/is-font-mono)
              (set-face-attribute 'default nil
                                  :family my/mono-font)))

      ;; Turn everything back on
      (if (eq my/artist-mode-restore-buffer (current-buffer))
          (progn
            (if my/artist-mode-highlight-thing-restore
                (progn
                  (setq my/artist-mode-highlight-thing-restore nil)
                  (highlight-thing-mode 1)))

            (if my/artist-mode-aggressive-indent-restore
                (progn
                  (setq my/artist-mode-aggressive-indent-restore nil)
                  (aggressive-indent-mode 1)))

            (if my/artist-mode-display-line-numbers-restore
                (progn
                  (setq my/artist-mode-display-line-numbers-restore nil)
                  (display-line-numbers-mode 1)))

            (evil-exit-emacs-state)

            (if (and (not my/is-font-mono) window-system)
                (set-face-attribute 'default nil
                                    :family my/font))))
      (setq my/artist-mode-restore-buffer nil)))

  (add-hook 'artist-mode-hook 'my/artist-mode)
#+END_SRC


** Completing read
https://www.emacswiki.org/emacs/ArtistMode
#+BEGIN_SRC emacs-lisp
  (defun my/artist-select-operation (type)
    "Use ido to select a drawing operation in artist-mode"
    (interactive (list (completing-read "Drawing operation: " 
                                        (list "Pen" "Pen Line" "line" "straight line" "rectangle" 
                                              "square" "poly-line" "straight poly-line" "ellipse" 
                                              "circle" "text see-thru" "text-overwrite" "spray-can" 
                                              "erase char" "erase rectangle" "vaporize line" "vaporize lines" 
                                              "cut rectangle" "cut square" "copy rectangle" "copy square" 
                                              "paste" "flood-fill"))))
    (artist-select-operation type))

  (defun my/artist-select-settings (type)
    "Use ido to select a setting to change in artist-mode"
    (interactive (list (completing-read "Setting: " 
                                        (list "Set Fill" "Set Line" "Set Erase" "Spray-size" "Spray-chars" 
                                              "Rubber-banding" "Trimming" "Borders"))))
    (if (equal type "Spray-size") 
        (artist-select-operation "spray set size")
      (call-interactively (artist-fc-get-fn-from-symbol 
                           (cdr (assoc type '(("Set Fill" . set-fill)
                                              ("Set Line" . set-line)
                                              ("Set Erase" . set-erase)
                                              ("Rubber-banding" . rubber-band)
                                              ("Trimming" . trimming)
                                              ("Borders" . borders)
                                              ("Spray-chars" . spray-chars))))))))
#+END_SRC

** Picture mode keys
#+BEGIN_SRC emacs-lisp
  (setq picture-mode-map (make-sparse-keymap))
  (setq-default picture-mode-map (make-sparse-keymap))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "A") 'artist-mode)

  (define-prefix-command 'my/artist-mode-map)
  (evil-define-key 'normal artist-mode-map (kbd (concat my/leader-map-key " a")) 'my/artist-mode-map)

  (define-key my/artist-mode-map (kbd "o") 'my/artist-select-operation)
  (define-key my/artist-mode-map (kbd "s") 'my/artist-select-settings)


  ;; (evil-define-key 'insert artist-mode-map (kbd "SPC") '(lambda () (interactive) (insert " ")))
  ;; (evil-define-key 'insert artist-mode-map (kbd "SPC") 'self-insert-command)

  (setq artist-mode-map (make-sparse-keymap))
  (setq-default artist-mode-map (make-sparse-keymap))
  ;; (evil-define-key 'insert artist-mode-map (kbd "DEL") 'picture-backward-clear-column)
  ;; 
  ;; (evil-define-key 'insert artist-mode-map (kbd "RET") 'newline)

  (evil-define-key 'normal artist-mode-map (kbd "p") 'artist-previous-line)
  (evil-define-key 'normal artist-mode-map (kbd "n") 'artist-next-line)


  (evil-define-key 'normal artist-mode-map (kbd "n") 'artist-next-line)

  (evil-define-key 'emacs artist-mode-map [down-mouse-1] 'artist-down-mouse-1)
  (evil-define-key 'emacs artist-mode-map [S-down-mouse-1] 'artist-down-mouse-1)
  (evil-define-key 'emacs artist-mode-map [down-mouse-2] 'artist-mouse-choose-operation)
  (evil-define-key 'emacs artist-mode-map [S-down-mouse-2] 'artist-mouse-choose-operation)
  (evil-define-key 'emacs artist-mode-map [down-mouse-3] 'artist-down-mouse-3)
  (evil-define-key 'emacs artist-mode-map [S-down-mouse-3] 'artist-down-mouse-3)
  (evil-define-key 'emacs artist-mode-map [C-mouse-4] 'artist-select-prev-op-in-list)
  (evil-define-key 'emacs artist-mode-map [C-mouse-5] 'artist-select-next-op-in-list)
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'hydra)

  ;; Hydra lv generates a lot of garbage, disable it
  (setq hydra-lv nil)
#+END_SRC

** Window and buffer management
#+BEGIN_SRC emacs-lisp
  (defhydra my/window-hydra (:hint nil
                                   :color red)
    ;; :pre (setq exwm-input-line-mode-passthrough t)
    ;; :post (setq exwm-input-line-mode-passthrough nil))
    "movement" 

    ;; Move focus
    ("p" evil-window-up nil)
    ("n" evil-window-down nil)
    ("l" evil-window-right nil)
    ("h" evil-window-left nil)

    ;; Move focus to edge window
    ;; Frame border window
    ("|" evil-window-mru nil)

    ;; Move window
    ;; Move up
    ("P" evil-move-very-top nil)
    ;; Move down
    ("N" evil-move-very-bottom nil)
    ;; Move right
    ("L" evil-move-far-right nil)
    ;; Move left
    ("H" evil-move-far-left nil)

    ;; Switch monitor right
    ("M-l" my/switch-monitor-right nil)
    ;; Switch monitor left
    ("M-h" my/switch-monitor-left nil)

    ;; Resize window
    ;; Resize up
    ("C-p" (evil-window-increase-height 10) nil)
    ;; Resize down
    ("C-n" (evil-window-decrease-height 10) nil)
    ;; Resize right
    ("C-l" (evil-window-decrease-width 10) nil)
    ;; Resize left
    ("C-h" (evil-window-increase-width 10) nil)

    ;; Split
    ("o" split-window-right nil)
    ("v" split-window-below nil)
    ("i" clone-indirect-buffer-other-window nil)

    ;; Close window
    ("s" delete-window nil)
    ;; Focus on window
    ("d" my/delete-other-windows nil)

    ;; minimize window
    ("S" (lambda () (interactive) (evil-window-increase-height 1000) (evil-window-increase-width 1000)) nil)
    ;; maximize window
    ("D" (lambda () (interactive) (evil-window-decrease-height 1000) (evil-window-decrease-width 1000)) nil)

    ;; Buffer management
    ;; Find file
    ("e" my/find-file nil)
    ("E" dired-jump nil)

    ;; Switch buffer
    ("A" next-buffer nil)
    ("C-a" previous-buffer nil)

    ;; Switch buffer
    ("a" ivy-switch-buffer nil)
    ;; Kill buffer
    ("k" kill-current-buffer nil)

    ;; Move around in buffer
    ("C-u" evil-scroll-up nil)
    ("C-w" evil-scroll-down nil)

    ("f" counsel-M-x nil)
    ("y" counsel-linux-app nil)

    ("u" revert-buffer nil)

    ;; Switch window configuration
    ("t" my/load-window-config nil)
    ("T" my/add-window-config nil)
    ("C-t" my/delete-window-config nil)

    ("b" counsel-bookmark nil)
    ("B" my/add-bookmark nil)
    ("C-b" my/delete-bookmark nil))

    ;;  ("SPC" my/leader-map nil)

    ;; Add this to not auto exit insert mode after closing the hydra
    ;;("<escape>" nil))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (my/evil-universal-define-key my/mod-window-leader-key 'my/window-hydra/body)
  (my/evil-universal-define-key my/window-leader-key 'my/window-hydra/body)
#+END_SRC

* Image modes
** PDF view
#+BEGIN_SRC emacs-lisp
  (defun my/pdf-view-mode()
    (interactive)
    (display-line-numbers-mode -1))

  (add-hook 'pdf-view-mode-hook 'my/pdf-view-mode t)
#+END_SRC

** PDF tools
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'pdf-tools)

  (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . my/init-pdf-tools))
  ;;(add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))

  (setq my/pdf-tools-installed nil)

  (defun my/init-pdf-tools ()
    (interactive)
    (if (not my/pdf-tools-installed)
        (progn
          (require 'pdf-view)
          (pdf-tools-install)
          ;; reload buffer with everything set
          (revert-buffer :ignore-auto :noconfirm)))
    (setq my/pdf-tools-installed t)
    (pdf-view-mode))

    ;;(add-hook 'pdf-view-mode-hook 'my/init-pdf-tools)

    ;; Enable pdf-links
    (add-hook 'pdf-view-mode-hook 'pdf-links-minor-mode)

    ;; Remove default keys
    (setq pdf-view-mode-map (make-sparse-keymap))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; Disable insert mode
  (define-key pdf-view-mode-map [remap evil-insert] 'evil-force-normal-state)

  ;; Scroll half page
  (define-key pdf-view-mode-map [remap View-scroll-half-page-backward] 'pdf-view-scroll-down-or-previous-page)
  (define-key pdf-view-mode-map [remap View-scroll-half-page-forward] 'pdf-view-scroll-up-or-next-page)

  (define-key pdf-view-mode-map [remap evil-scroll-up] 'pdf-view-scroll-down-or-previous-page)
  (define-key pdf-view-mode-map [remap evil-scroll-down] 'pdf-view-scroll-up-or-next-page)
  
  ;; goto
  (define-key pdf-view-mode-map [remap evil-goto-first-line] 'pdf-view-first-page)

  ;; (kbd "G") = (evil-goto-line LAST-LINE)
  (define-key pdf-view-mode-map [remap evil-goto-line] 'pdf-view-last-page)
  ;; search
  (define-key pdf-view-mode-map [remap counsel-grep-or-swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap my/use-swiper-or-grep] 'isearch-forward)
  (define-key pdf-view-mode-map [remap swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap counsel-grep] 'isearch-forward)

  ;; Movement
  (define-key pdf-view-mode-map [remap evil-next-line] '(lambda () (interactive) (image-next-line 4)))
  (define-key pdf-view-mode-map [remap evil-previous-line] '(lambda () (interactive) (image-previous-line 4)))

  (define-key pdf-view-mode-map [remap evil-forward-char] '(lambda () (interactive) (image-forward-hscroll 8)))
  (define-key pdf-view-mode-map [remap evil-backward-char] '(lambda () (interactive) (image-backward-hscroll 8)))

  ;; Disable other modes
  (evil-define-key 'normal pdf-view-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "v") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "R") 'nil)

  ;; Zoom
  (evil-define-key 'normal pdf-view-mode-map (kbd "-") 'pdf-view-shrink)
  (evil-define-key 'normal pdf-view-mode-map (kbd "=") 'pdf-view-enlarge)
  (evil-define-key 'normal pdf-view-mode-map (kbd "_") 'pdf-view-scale-reset)
  (evil-define-key 'normal pdf-view-mode-map (kbd "+") 'pdf-view-scale-reset)

  ;; Add to leader map
  (define-prefix-command 'my/pdf-view-mode-map)
  (evil-define-key 'normal pdf-view-mode-map (kbd (concat my/leader-map-key " a")) 'my/pdf-view-mode-map)

  (define-key my/pdf-view-mode-map (kbd "o") 'pdf-occur)
  (define-key my/pdf-view-mode-map (kbd "t") 'doc-view-open-text)
  (define-key my/pdf-view-mode-map (kbd "n") 'pdf-view-midnight-minor-mode)
  (define-key my/pdf-view-mode-map (kbd "g") 'pdf-view-goto-label)
  (define-key my/pdf-view-mode-map (kbd "i") 'pdf-view-extract-region-image)
#+END_SRC

** Image mode
#+BEGIN_SRC emacs-lisp
  (require 'image-mode)

  (add-hook 'image-mode-hook '(lambda () (interactive) (display-line-numbers-mode -1)))
#+END_SRC

*** Blimp
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'blimp)

  (setq eimp-enable-undo t)

  (add-hook 'image-mode-hook 'blimp-mode)
#+END_SRC

**** Recolor
#+BEGIN_SRC emacs-lisp
  (defun my/blimp-annotate-middle()
    (interactive)
    (blimp-add-to-command-stack (list "-gravity" "Center" "-fill" "red" "-pointsize" "25" "-annotate" "0,0" (completing-read "enter text " nil)))
    (blimp-execute-command-stack)
    (sleep-for 0.2))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal image-mode-map (kbd "-") 'image-decrease-size)
  (evil-define-key 'normal image-mode-map (kbd "=") 'image-increase-size)
  (evil-define-key 'normal image-mode-map (kbd "_") 'image-transform-fit-to-height)
  (evil-define-key 'normal image-mode-map (kbd "+") 'image-transform-fit-to-width)

  (evil-define-key 'normal image-mode-map (kbd "C-u") 'image-scroll-down)
  (evil-define-key 'normal image-mode-map (kbd "C-w") 'image-scroll-up)

  (evil-define-key 'normal image-mode-map (kbd "n") '(lambda () (interactive) (image-next-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "p") '(lambda () (interactive) (image-previous-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "h") '(lambda () (interactive) (image-backward-hscroll 8)))
  (evil-define-key 'normal image-mode-map (kbd "l") '(lambda () (interactive) (image-forward-hscroll 8)))

  (evil-define-key 'normal image-mode-map (kbd "G") '(lambda () (interactive) (image-next-line 100)))
  (evil-define-key 'normal image-mode-map (kbd "g g") '(lambda () (interactive) (image-previous-line 100)))

  (evil-define-key 'normal image-mode-map (kbd "$") '(lambda () (interactive) (image-forward-hscroll 100)))
  (evil-define-key 'normal image-mode-map (kbd "0") '(lambda () (interactive) (image-backward-hscroll 100)))

  (define-prefix-command 'my/image-mode-map)
  (evil-define-key 'normal image-mode-map (kbd (concat my/leader-map-key " a")) 'my/image-mode-map)

  (define-key my/image-mode-map (kbd "i") 'blimp-interface)
  (define-key my/image-mode-map (kbd "I") 'blimp-interface-execute)

  (define-key my/image-mode-map (kbd "r") 'blimp-clear-command-stack)
  (define-key my/image-mode-map (kbd "e") 'blimp-execute-command-stack)
  (define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)
  (define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)

  (define-key my/image-mode-map (kbd "a") 'my/blimp-annotate-middle)
#+END_SRC

* Spray
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'spray)
  (require 'spray)

  (setq spray-wpm 500)

  (define-key spray-mode-map (kbd "p") 'spray-slower)
  (define-key spray-mode-map (kbd "n") 'spray-faster)

  (define-key my/leader-map (kbd "M-v") 'spray-mode)
#+END_SRC

* Ligatures
#+BEGIN_SRC emacs-lisp
  (if window-system
      (global-prettify-symbols-mode 1))
  (setq prettify-symbols-unprettify-at-point 'right-edge)

  ;; Redefine so that prettify mode is enabled even if a buffer local symbols alist isn't defined
  (defun turn-on-prettify-symbols-mode ()
    (when (not prettify-symbols-mode)
      (prettify-symbols-mode 1)))

  ;; Replace comments with symbol
  ;; "^[\s\\|\t]*;+"
  ;; \\(^ *;; \\*\\) 
#+END_SRC

** Generic
#+BEGIN_SRC emacs-lisp
  (defvar my/generic-equal-symbols 
    '(
      ("!=" . ?≠)
      (">=" . ?≥)
      ("<=" . ?≤)
      ))

  (defvar my/generic-arrow-symbols 
    '(("->" . ?→)
      ("<-" . ?←)
      ("->>" . ?↠)
      ("<<-" . ?↞)
      ("|>" . ?⊳)
      ("<|" . ?⊲)
      ("<<" . ?≪)
      (">>" . ?≫)))

  (defvar my/generic-greek-symbols 
    '(("lambda" . ?λ)
      ))
#+END_SRC

** Fsharp
#+BEGIN_SRC emacs-lisp
  (defvar my/fsharp-symbols 
    (list))
#+END_SRC

** C/CPP
#+BEGIN_SRC emacs-lisp
  (defvar my/fsharp-symbols 
    '(
      ("!=" . ?≠)
      ))
#+END_SRC

** Elisp
#+BEGIN_SRC emacs-lisp
  (setq my/elisp-symbols 
        '(
          ("defun" . ?λ)
          ))
#+END_SRC
    
** Set symbol by mode
#+BEGIN_SRC emacs-lisp
  (setq-default prettify-symbols-alist
                (append
                 my/generic-greek-symbols 
                 my/generic-equal-symbols
                 my/generic-arrow-symbols))

  (add-hook 'prog-mode-hook (lambda () (interactive)
                              (setq-local prettify-symbols-alist
                                          (pcase major-mode
                                            ('fsharp-mode (append
                                                           my/fsharp-symbols
                                                           my/generic-greek-symbols 
                                                           my/generic-equal-symbols
                                                           my/generic-arrow-symbols
                                                           ))
                                            ('emacs-lisp-mode (append
                                                               my/elisp-symbols
                                                               my/generic-greek-symbols 
                                                               my/generic-equal-symbols
                                                               my/generic-arrow-symbols
                                                               ))
                                            ('lisp-interaction-mode (append
                                                                     my/elisp-symbols
                                                                     my/generic-greek-symbols 
                                                                     my/generic-equal-symbols
                                                                     my/generic-arrow-symbols
                                                                     ))
                                            ))))

  ;; (add-hook 'prog-mode-hook
  ;; (lambda ()
  ;; (setq-local prettify-symbols-alist
  ;; (pcase major-mode
  ;; ('emacs-lisp-mode
  ;; (append
  ;; my/generic-arrow-symbols
  ;; my/generic-equal-symbols))))))

  ;; (add-hook 'emacs-lisp-mode-hook
  ;; (lambda ()
  ;; (push '(">=" . ?≥) prettify-symbols-alist)))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp
  (defun my/paper-mode()
    (interactive)
    (cl-loop for face in (face-list) do
             ;; Don't change magit faces
             (if (not (string-match "magit" (symbol-name face)))
                 (set-face-attribute face nil :foreground nil :background nil)))

    (setq my/diff-added-color "#335533") 
    (setq my/diff-changed-color "#aaaa22") 
    (setq my/diff-removed-color "#553333") 

    (if window-system
        (progn
          (setq my/mark-color my/diff-changed-color) 

          (setq my/foreground-color "#E6E1DC") 
          (setq my/foreground-color-1 (color-darken-name my/foreground-color 5))
          (setq my/foreground-color-2 (color-darken-name my/foreground-color 10))
          (setq my/foreground-color-3 (color-darken-name my/foreground-color 15))
          (setq my/foreground-color-4 (color-darken-name my/foreground-color 20))
          (setq my/foreground-color-5 (color-darken-name my/foreground-color 25))
          (setq my/foreground-color-6 (color-darken-name my/foreground-color 30))

          (setq my/background-color "#232323")
          (setq my/background-color-1 (color-lighten-name my/background-color 5))
          (setq my/background-color-2 (color-lighten-name my/background-color 10))
          (setq my/background-color-3 (color-lighten-name my/background-color 15))
          (setq my/background-color-4 (color-lighten-name my/background-color 20))
          )

      (setq my/mark-color "yellow") 

      (setq my/foreground-color "white") 
      (setq my/foreground-color-1 "white")
      (setq my/foreground-color-2 "white")
      (setq my/foreground-color-3 "white")
      (setq my/foreground-color-4 "white")
      (setq my/foreground-color-5 "white")
      (setq my/foreground-color-6 "white")

      (setq my/background-color "black")
      (setq my/background-color-1 "black")
      (setq my/background-color-2 "black")
      (setq my/background-color-3 "black")
      (setq my/background-color-4 "black")

      (setq my/diff-added-color "green") 
      (setq my/diff-changed-color "yellow") 
      (setq my/diff-removed-color "red"))

    ;;; Emacs
    (set-face-attribute 'default nil :foreground my/foreground-color :background my/background-color)
    (set-face-attribute 'link nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'highlight nil :foreground my/foreground-color :background my/mark-color)
    (set-face-attribute 'region nil :foreground my/foreground-color :background my/mark-color)
    (set-face-attribute 'error nil :foreground "#c6350b" :background)
    (set-face-attribute 'warning nil :foreground "DarkOrange" :background)

    ;; Syntax
    (set-face-attribute  'font-lock-doc-face nil :foreground my/foreground-color :background my/background-color-4)
    (defvar my/comment-face-height (floor (* my/default-face-height 1.15)))
    (set-face-attribute  'font-lock-comment-face nil :foreground my/foreground-color :background my/background-color-1 :height my/comment-face-height)
    (set-face-attribute 'font-lock-string-face nil :foreground my/foreground-color :background my/background-color-1)
    (set-face-attribute 'font-lock-function-name-face nil :weight 'bold)

    ;; (set-face-attribute  'font-lock-keyword-face nil :foreground my/foreground-color :background my/background-color-1)
    ;; (set-face-attribute  'font-lock-function-name-face nil :foreground my/foreground-color :background my/background-color-2)

    ;; Required by other face
    (set-face-attribute 'outline-4 nil :foreground my/foreground-color :background my/background-color)

    ;; Line numbers
    (set-face-attribute 'line-number-current-line nil :foreground my/foreground-color :background my/background-color)
    (set-face-attribute 'line-number nil :foreground my/foreground-color :background my/background-color)

    ;; Evil
    (setq evil-emacs-state-cursor '("purple" box))
    (setq evil-normal-state-cursor '("red" box))
    (setq evil-visual-state-cursor '("yellow" box))
    (setq evil-insert-state-cursor '("orange" box))
    (setq evil-replace-state-cursor '("green" box))
    (setq evil-operator-state-cursor '("white" hollow))

    ;; On-screen
    ;;(set-face-attribute 'on-screen-shadow nil :foreground nil :background (color-lighten-name my/background-color 2))
    ;;(set-face-attribute 'on-screen-fringe nil :foreground my/foreground-color :background my/background-color)

    ;; Hl current line
    ;; Underlines part of current line
    ;;(set-face-attribute 'hl-line nil :foreground my/foreground-color :background nil :underline t)
    (set-face-attribute 'hl-line nil :foreground my/foreground-color :background my/background-color-2 :underline nil)

    ;;;  Org
    ;; =make this bold= 
    (set-face-attribute 'org-verbatim nil :weight 'bold)
    (set-face-attribute 'org-code nil :family my/mono-font)

    (set-face-attribute 'org-quote nil :slant 'italic)

    ;;; Dired
    (set-face-attribute 'dired-directory nil :foreground my/background-color :background my/foreground-color)

    ;;; Spray
    ;;  (set-face-attribute 'spray-accent-face nil :foreground "red" :background my/background-color)
    (set-face-attribute 'spray-accent-face nil :foreground my/foreground-color :background my/background-color :underline t)

    ;;; Isearch
    (set-face-attribute 'isearch nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'lazy-highlight nil :foreground my/background-color :background my/foreground-color)

    ;;; Highlight thing
    (set-face-attribute 'highlight-thing nil :foreground my/foreground-color :background my/mark-color)

    ;;; Company
    (set-face-attribute 'company-scrollbar-bg nil :background my/background-color)
    (set-face-attribute 'company-scrollbar-fg nil :background my/foreground-color)

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background my/foreground-color :foreground my/background-color)
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground my/foreground-color :background my/background-color-1)
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground my/background-color :background my/foreground-color)

    ;;; Popup menu
    ;; Selected entry
    (require 'popup)
    (set-face-attribute 'popup-menu-selection-face nil :foreground my/background-color :background my/foreground-color)
    ;; All unmatching text
    (set-face-attribute 'popup-menu-face nil :foreground my/foreground-color :background my/background-color-1)

    ;;; Ivy
    (set-face-attribute 'ivy-current-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-cursor nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-highlight nil :foreground my/background-color :background my/foreground-color)

    (set-face-attribute 'ivy-minibuffer-match-face-1 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'ivy-minibuffer-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'ivy-minibuffer-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

    ;;; Swiper
    (set-face-attribute 'swiper-match-face-1 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'swiper-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'swiper-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'swiper-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

    ;;; Avy
    (set-face-attribute 'avy-lead-face nil :foreground my/background-color :background my/foreground-color-6)
    (set-face-attribute 'avy-lead-face-0 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'avy-lead-face-1 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'avy-lead-face-2 nil :foreground my/background-color :background my/foreground-color-6)

    ;;; Eshell
    (require 'em-prompt)
    (if window-system
        (set-face-attribute 'eshell-prompt nil :foreground "purple" :background my/background-color)
      (set-face-attribute 'eshell-prompt nil :foreground "magenta" :background my/background-color))

    ;;; Eww
    (set-face-attribute 'my/eww-code-face nil :foreground my/foreground-color :background my/background-color-2 :family my/mono-font)

    ;;(defvar my/evil-goggles-highlight-color)

    ;;; Evil-goggles
    ;;;; 2 color approach
    ;; (set-face-attribute 'evil-goggles-change-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-commentary-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-delete-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-fill-and-move-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-indent-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-join-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-paste-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-record-macro-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-replace-with-register-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-set-marker-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-shift-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-surround-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-yank-face nil :foreground my/background-color :background my/foreground-color)

    (set-face-attribute 'diff-added nil  :background my/diff-added-color)
    (set-face-attribute 'diff-changed nil :background my/diff-changed-color)
    (set-face-attribute 'diff-removed nil :background my/diff-removed-color)

    ;; (set-face-attribute 'diff-added nil  :background "green")
    ;; (set-face-attribute 'diff-changed nil :background "yellow")
    ;; (set-face-attribute 'diff-removed nil :background "red")

    ;; Diff-hl 
    (set-face-attribute 'diff-hl-change nil :background (face-attribute 'diff-changed :background))

    ;; Paren highlight
    (set-face-attribute 'show-paren-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'show-paren-mismatch nil :background "red")

    ;; Mode line separator
    ;; Set mode line height
    (set-face-attribute 'mode-line nil
                        :foreground my/foreground-color
                        :background my/foreground-color
                        :height  0.1)

    (set-face-attribute 'mode-line-inactive nil
                        :foreground my/background-color
                        :background my/background-color
                        :height  0.1)

    ;; Highlight faces
    ;;(highlight-indent-guides-auto-set-faces)
    )

  (if window-system
      (add-hook 'exwm-init-hook 'my/paper-mode)
  (add-hook 'after-init-hook 'my/paper-mode))

  ;; (counsel-faces)

  (define-key my/leader-map (kbd "M-c") 'my/paper-mode)
#+END_SRC

* Visuals
** Indicate empty lines
#+BEGIN_SRC emacs-lisp
  (setq-default indicate-empty-lines t)
#+END_SRC

** Center text
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'olivetti)

  (setq-default olivetti-body-width 150)

  (define-key my/leader-map (kbd "V") 'olivetti-mode)
#+END_SRC

** Fringe size
Used by diff-hl and flycheck
Fringe only on the left side
#+BEGIN_SRC emacs-lisp
  (fringe-mode '(6 . 0))
#+END_SRC

** Beacon
#+BEGIN_SRC emacs-lisp
  ;; (straight-use-package 'beacon)
;; 
  ;; (beacon-mode 1)
#+END_SRC
  
** Rainbow
Changes background of eg. #FF00FF to represent color
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'rainbow-mode)

  (define-key my/help-map (kbd "c") 'rainbow-mode)
#+END_SRC

** Rainbow delimiters
Changes colors of delimiters eg. {()}
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'rainbow-delimiters)

  (define-key my/help-map (kbd "d") 'rainbow-delimiters-mode)
  ;;(add-hook 'prog-mode 'rainbow-delimiters-mode)
#+END_SRC

** Minimap
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'minimap)

  (define-key my/leader-map (kbd "]") 'my/toggle-window-config-minimap)

  (setq minimap-window-location 'right)
#+END_SRC

*** Toggle minimap by window config
#+BEGIN_SRC emacs-lisp
  (defvar my/minimap-exists nil)

  (defun my/kill-minimap()
    (if my/minimap-exists
        (progn
          (minimap-kill)
          (setf my/minimap-exists nil))))

  (defun my/start-minimap()
    (if (not my/minimap-exists)
        (progn
          (minimap-create)
          (setf my/minimap-exists t))))

  (defvar my/window-configs-with-minimap (list))

  (defun my/has-current-window-config-minimap ()
    (cl-position my/current-window-configuration my/window-configs-with-minimap :test 'string=))

  (defun my/toggle-window-config-minimap()
    (interactive)
    (if (my/has-current-window-config-minimap)
        (setq my/window-configs-with-minimap (delete my/current-window-configuration my/window-configs-with-minimap))
      (push my/current-window-configuration my/window-configs-with-minimap))
    (my/window-config-minimap-refresh))

  (defun my/window-config-minimap-refresh()
    (if (my/has-current-window-config-minimap)
        (my/start-minimap)
      (my/kill-minimap)))
  (setq my/window-configs-with-minimap nil)

  (add-hook 'my/window-config-name-changed-hook 'my/window-config-minimap-refresh t)
#+END_SRC

** Highlight matching delimiters
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
#+END_SRC

** Highlight current line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

** Highlight thing
Highlight thing under cursor and all other occurrences
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'highlight-thing)

  ;; Show hits in all windows
  (setq highlight-thing-all-visible-buffers-p t)

  ;; Don't highlight the word true or false
  ;;(setq highlight-thing-ignore-list '("False" "True"))

  ;; Don't highlight thing under cursor, only matches
  (setq highlight-thing-exclude-thing-under-point 1)

  (setq highlight-thing-case-sensitive-p 1) 
  (global-highlight-thing-mode)
#+END_SRC

*** Don't highlight huge buffers
#+BEGIN_SRC emacs-lisp
  (setq highlight-thing-limit-to-region-in-large-buffers-p nil)
  (setq highlight-thing-narrow-region-lines 15)
  (setq highlight-thing-large-buffer-limit 5000)
#+END_SRC

** Hl-anything
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'hl-anything)

  (define-key my/leader-map (kbd "M") 'hl-highlight-thingatpt-local)
#+END_SRC

** Disable blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** Disable GUI
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** Faces
#+BEGIN_SRC emacs-lisp
(if window-system
    (set-face-attribute 'header-line nil
                        :foreground (face-attribute 'default :foreground)
                        :background (face-attribute 'default :background)
                        :family (face-attribute 'default :family)
                        :height (face-attribute 'default :height)))

  (set-face-attribute 'org-mode-line-clock nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-mode-line-clock-overrun nil
                      :foreground (face-attribute 'default :foreground)
                      :background "red"
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-effort nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-regexp nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-tags nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-category nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))
#+END_SRC

** Modeline
Make mode line appear in echo area instead of in the mode line area. This saves space and makes it so that the mode line can't be split

*** Mode line
Set mode line height
#+BEGIN_SRC emacs-lisp
  ;; Disable normal mode line
  ;; (setq mode-line-format nil)
  ;; (setq-default mode-line-format nil)

  (setq mode-line-format "")
  (setq-default mode-line-format "")

  (if window-system
    ;; Set mode line height
    (set-face-attribute 'mode-line nil
                        ;; :foreground (face-attribute 'window-divider :foreground)
                        ;; :background (face-attribute 'window-divider :background)
                        :foreground "white" 
                        :background "white"
                        :height  0.1
                        :family my/mono-font)

    (set-face-attribute 'mode-line-inactive nil
                        :foreground "dark gray"
                        :background "dark gray"
                        :height  0.1
                        :family my/mono-font))
#+END_SRC

*** LV-line (top modeline)
Use lv-line to create a mode line on the top of the screen
#+BEGIN_SRC emacs-lisp
  (defvar my/lv-line-format "")
  (defconst my/lv-line--buffer " *LV-line*")
  (defvar my/lv-line-window nil)
#+END_SRC

**** LV-line update
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line--update ()
    (let* ((buffer (get-buffer my/lv-line--buffer)))
      (if (not buffer)
          (progn
            (message "LV-line buffer not found - creating new one")
            (my/lv-line-create)))
      (with-current-buffer buffer
        (erase-buffer)
        (insert (format-mode-line my/lv-line-format)))))
#+END_SRC

**** Create LV-line at top
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line-set-buffer ()
    (setq truncate-lines nil)
    (setq indicate-empty-lines nil)
    (set-window-hscroll my/lv-line-window 0)
    (setq window-size-fixed t)
    (setq mode-line-format nil)

    (if window-system
        ;; Change to mono face
        (face-remap-add-relative 'default :family my/mono-font))

    ;; Disable cursor
    (setq cursor-type nil)
    (setq cursor-in-non-selected-windows nil)

    (set-window-dedicated-p my/lv-line-window t)
    (set-window-parameter my/lv-line-window 'no-other-window t))

  (defun my/lv-line-create ()
    (if (not (get-buffer my/lv-line--buffer))
        (generate-new-buffer my/lv-line--buffer))
    (if (not (window-live-p my/lv-line-window))
        (let* ((original-window (selected-window)))
          (setq my/lv-line-window
                (select-window
                 (let ((ignore-window-parameters t))
                   (split-window
                    (frame-root-window) -1 'above)
                   )))
          (switch-to-buffer my/lv-line--buffer)
          (my/lv-line-set-buffer)
          (select-window original-window))))

  ;; (defun my/lv-line-create ()
  ;; "Ensure that LV window is live and return it."
  ;; (if (window-live-p my/lv-line-window)
  ;; my/lv-line-window
  ;; (let ((ori (selected-window)) buf)
  ;; (prog1 (setq my/lv-line-window
  ;; (select-window
  ;; (let ((ignore-window-parameters t))
  ;; (split-window
  ;; (frame-root-window) -1 'above))))
  ;; (my/lv-line-create-buffer)
  ;; (select-window ori)))))
#+END_SRC
**** Update it
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line-start()
    (my/lv-line-create)
    (my/lv-line--update)
    (add-hook 'post-command-hook 'my/lv-line--update t)
    (add-hook 'my/switch-buffer-hook 'my/lv-line--update t)
    (run-with-timer 6 60 'my/lv-line--update))

  (if window-system
      (add-hook 'exwm-init-hook 'my/lv-line-start)
    (my/lv-line-start))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/mode-line-map)
  (define-key my/leader-map (kbd "M-m") 'my/mode-line-map)
#+END_SRC

**** Garbage Collection
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-show-GC-stats nil)
  (defun my/mode-line-toggle-show-GC-stats ()
    (interactive)
    (setq my/mode-line-show-GC-stats (not my/mode-line-show-GC-stats)))

  (define-key my/mode-line-map (kbd "G") 'my/mode-line-toggle-show-GC-stats)
#+END_SRC

*** Mode line modules
**** Buffer name
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-name "")
  (defvar my/max-buffer-name-length 10)

  (defun my/update-max-buffer-name-length()
    (interactive)
    (setq my/max-buffer-name-length (floor (/ (frame-width) 10))))

  (defun my/update-buffer-name-string (BUFFER)
    (interactive)
    (setq my/buffer-name
          (if (> (string-width BUFFER) my/max-buffer-name-length)
              (concat (string-trim-right (substring BUFFER 0 my/max-buffer-name-length)) "...")
            BUFFER)))

  (if window-system
      ;; At this point in the code, exwm hasn't had time to maximize the emacs frame
      (add-hook 'exwm-init-hook 'my/update-max-buffer-name-length)
    ;; If on terminal, just run it now since it's always maximized
    (my/update-max-buffer-name-length))

  ;;(add-hook 'buffer-list-update-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)
  (add-hook 'my/switch-buffer-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)

  ;;(add-hook 'window-configuration-change-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)
#+END_SRC

**** Which function
#+BEGIN_SRC emacs-lisp
  (require 'which-func)

  (setq which-func-unknown "")

  (setq which-func-current
        '(:eval
          (let ((result (gethash (selected-window) which-func-table)))
            (if result
                (concat
                 " | < "
                 (replace-regexp-in-string "%" "%%" result)
                 " >"
                 )))))

  ;;(which-function-mode 1)

  ;;(remove-hook 'my/switch-buffer-hook 'which-func-update)

  ;;(replace-regexp-in-string "%" "%%"
  ;;(or
  ;;(gethash
  ;;(selected-window)
  ;;which-func-table)
  ;;which-func-unknown)))
  ;; Could be used if doing func mode manually
  ;; (setq my/which-function-modes '(c-mode emacs-lisp-mode))
  ;; 
  ;; (defun my/enable-which-function ()
  ;; (if (member major-mode my/which-function-modes)
  ;; (which-function-mode 1)))
  ;; 
  ;; (add-hook 'prog-mode-hook 'my/enable-which-function)
#+END_SRC

**** CPU heat
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-cpu-temp t)

  (if (and
       ;; If lm_sensors is not installed
       (my/is-system-package-installed 'sensors)
       ;; If there aren't any cpu heat sensors (eg. virtual machine)
       (= 0 (string-match-p ""
                            (shell-command-to-string "sensors | grep \"Core 0:\""))))
      (setq my/mode-line-enable-cpu-temp nil))

  (defvar my/cpu-temp "")

  (defun my/update-cpu-temp ()
    (interactive)
    ;;(if my/mode-line-enable-cpu-temp))

    ;; FIXME emacs regexes are wierd, use position of temp in print insead
    (string-match "\+.*C\s" (shell-command-to-string "sensors | grep \"Core 0:\""))
    (setq my/cpu-temp (substring (match-string 0 (shell-command-to-string "sensors | grep \"Core 0:\"")) 0 -3)))

  (if my/mode-line-enable-cpu-temp
      (run-with-timer 0 60 'my/update-cpu-temp))
#+END_SRC

**** Disk space
#+BEGIN_SRC emacs-lisp
  (defvar my/disk-space nil)
  (defun my/update-disk-space ()
    (interactive)
    (setq my/disk-space (my/file-size-human-readable (floor (* 1000 (string-to-number (get-free-disk-space user-emacs-directory)))))))
#+END_SRC

**** Network traffic
***** Linux
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-network-traffic nil)

  (if (file-exists-p "/proc/net/dev")
      (setq my/mode-line-enable-network-traffic t))
#+END_SRC

****** RX
Received
#+BEGIN_SRC emacs-lisp
  (defvar my/rx 0)
  (defvar my/rx-delta-formatted "0")

  (defun my/linux-get-network-rx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((rx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (setq rx (+ rx (read (current-buffer)))))) 
        rx)))

  (defun my/linux-update-network-rx-delta ()
    (interactive)
    (setq my/rx-new (my/linux-get-network-rx))
    (setq my/rx-delta-formatted (my/file-size-human-readable (- my/rx-new my/rx)))
    (setq my/rx my/rx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 1 60 'my/linux-update-network-rx-delta))

  (my/linux-update-network-rx-delta)
#+END_SRC

****** TX
Transmitted
#+BEGIN_SRC emacs-lisp
  (setq my/tx 0)
  (defvar my/tx-delta-formatted "0")

  (defun my/linux-get-network-tx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((tx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (forward-word 8)
            (setq tx (+ tx (read (current-buffer))))))
        tx)))

  (defun my/linux-update-network-tx-delta ()
    (interactive)
    (setq my/tx-new (my/linux-get-network-tx))
    (setq my/tx-delta-formatted  (my/file-size-human-readable (- my/tx-new my/tx)))
    (setq my/tx my/tx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 2 60 'my/linux-update-network-tx-delta))

  (my/linux-update-network-tx-delta)
#+END_SRC

**** Display total line numbers
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-total-lines nil)

  (defun my/update-total-lines ()
    (save-excursion
      (setq my/buffer-total-lines (format-mode-line "%l" (goto-char (point-max))))))

  (add-hook 'my/switch-buffer-hook 'my/update-total-lines)
  (add-hook 'before-save-hook 'my/update-total-lines)
#+END_SRC

**** Mail
#+BEGIN_SRC emacs-lisp
  (defvar my/gnus-unread-string "")

  (defun my/gnus-update-unread()
    (my/gnus-scan-unread)
    (setq my/gnus-unread-string
          (concat
           "M:"
           (my/gnus-get-unread-mail-count)
           " > N:"
           (my/gnus-get-unread-news-count))))

  (add-hook 'my/sync-mail-hook 'my/gnus-update-unread)
  (add-hook 'gnus-summary-exit-map 'my/gnus-update-unread)
#+END_SRC

**** Battery
If there is a battery, display it in the mode line
#+BEGIN_SRC emacs-lisp
  (require 'battery)

  (display-battery-mode 1)
  (setq battery-mode-line-format "%th - %p")
#+END_SRC

**** Date and time
Display time and date in good format (also displays CPU load)
#+BEGIN_SRC emacs-lisp
  (defvar my/date "")
  (defvar my/time "")

  (defun my/update-date ()
    (interactive)
    (setq my/date (format-time-string "%d-%m-%Y")))

  (defun my/update-time ()
    (interactive)
    (setq my/time (format-time-string "%H:%M")))

  (run-with-timer 3 60 'my/update-time)
  (run-with-timer 0 3600 'my/update-date)

  ;; Update date now
  (my/update-time)
  (my/update-date)
#+END_SRC

**** Git branch name
#+BEGIN_SRC emacs-lisp
  (require 'vc-git)

  (defvar my/buffer-git-branch "")

  (defun my/update-buffer-git-branch ()
    (interactive)
    ;; Fixes tramp
    (if (not (string= major-mode "minibuffer-inactive-mode"))
        (setq my/buffer-git-branch (car (vc-git-branches)))))

  (add-hook 'my/switch-buffer-hook 'my/update-buffer-git-branch)
#+END_SRC

**** Git project name
When projectile-mode is on, project name is updated on every keypress, here it is fixed
#+BEGIN_SRC emacs-lisp
  (defvar my/projectile-project-name "")

  (defun my/update-projectile-project-name()
    (interactive)
    (setq my/projectile-project-name (projectile-project-name)))

  (add-hook 'my/switch-buffer-hook 'my/update-projectile-project-name)
#+END_SRC

**** Errors
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-error-list (list))
  (defvar my/mode-line-error-list-formatted nil)

  (defun my/mode-line-error-list-remove (text)
    (setq my/mode-line-error-list (remove text my/mode-line-error-list))
    (my/update-mode-line-error-list))

  (defun my/mode-line-error-list-add (text)
    (add-to-list 'my/mode-line-error-list text)
    (my/update-mode-line-error-list))

  (defun my/update-mode-line-error-list ()
    (setq my/mode-line-error-list-formatted (format "%s" my/mode-line-error-list)))
#+END_SRC

**** Config error
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda () (interactive)
                               (if (my/has-config-error)
                                   (my/alert "CONFIG ERROR!" 'high))))
#+END_SRC

**** Load average
#+BEGIN_SRC emacs-lisp
  (defvar my/load-average 0)
  (defvar my/high-load-average 2)

  (defun my/update-load-average ()
    (interactive)
    (setq my/load-average (/ (nth 0 (load-average)) 100.0)))

  (run-with-timer 4 60 'my/update-load-average)

  (my/update-load-average)
#+END_SRC

**** Ram usage
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-available-mem nil)

  (if (file-exists-p "/proc/meminfo")
      (setq my/mode-line-enable-available-mem t))

  (defvar my/available-mem-formatted "nil")
  (defvar my/available-mem 0)

  (defun my/linux-update-available-mem ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents "/proc/meminfo")
      (setq my/mem-string (buffer-string))

      (string-match "MemAvailable:.*\s" my/mem-string)
      (setq my/mem-string (match-string 0 my/mem-string))

      ;; Default returns kb, *1000 to get it to bytes
      (setq my/available-mem (* 1000(string-to-number (substring my/mem-string (string-match "[0-9]" my/mem-string) -1))))
      (setq my/available-mem-formatted (my/file-size-human-readable my/available-mem nil t))))

  (if my/mode-line-enable-available-mem
      (run-with-timer 5 60 'my/linux-update-available-mem))

  ;; Update available mem on startup
  (my/linux-update-available-mem)
#+END_SRC

**** Uptime
#+BEGIN_SRC emacs-lisp
  (defvar my/uptime-start-time (float-time))
  (defvar my/uptime-total-time-formated "0M")

  (defun my/get-uptime-formated-time ()
    (let* ((total-time  (- (float-time) my/uptime-start-time)))
      (if (> total-time (* 60 60))
          (concat (format "%0.1f"(/ total-time 3600.0)) "H")
        (concat (int-to-string (/ (floor total-time) 60)) "M"))))

  (defun my/update-uptime-timer ()
    (interactive)
    (setq my/uptime-total-time-formated (my/get-uptime-formated-time)))

  (run-with-timer 0 60 'my/update-uptime-timer)
#+END_SRC

**** Eye timer
#+BEGIN_SRC emacs-lisp
  (defvar my/eye-timer-last-break (float-time))

  ;; In seconds
  (defvar my/eye-timer-break-every (* 21 60))

  (defun my/eye-timer-add ()
    (my/alert "Eye timer" 'high)
    (setq my/eye-timer-last-break (float-time)))

  (defun my/eye-timer-update ()
    (interactive)
    (if (> (- (float-time) my/eye-timer-last-break) my/eye-timer-break-every)
        (my/eye-timer-add)))

  (run-with-timer 0 60 'my/eye-timer-update)
#+END_SRC

*** Mode line format
#+BEGIN_SRC emacs-lisp
  (defvar my/frame-width (frame-width))

  (defun my/frame-width-update()
    (setq my/frame-width (frame-width)))

  ;; Only applicable to X since terminal never stretches, etc
  (add-hook 'exwm-workspace-switch-hook 'my/frame-width-update)
  (add-hook 'exwm-init-hook (lambda () (interactive) (run-with-timer 1 nil '(lambda () (interactive) (my/frame-width-update) (my/lv-line--update)))) t)

  (defun my/mode-line-align (left right)
    "Return a string of `window-width' length containing LEFT, and RIGHT aligned respectively."
    (let* ((available-width (- my/frame-width (length left) 2)))
      (format (format "%%s %%%ds" available-width) left right)))

  ;;mode-line-format
  (setq-default my/lv-line-format
                '(:eval
                  (my/mode-line-align
                   (format-mode-line
                    (quote
                     (

                      ;; Print if recursive editing
                      "%["

                      ;; Information bar
                      mode-line-mule-info
                      mode-line-client

                      ;; If buffer is modified
                      mode-line-modified

                      ;; Turns into @ when remote
                      mode-line-remote

                      " "

                      ;; Print current line number
                      ;;"%l"
                      ;;"%p"
                      (:eval (format "%d" (/ (window-start) 0.01 (point-max))))

                      "~"
                      ;;"@" 
                      ;; Print total line number
                      (:eval my/buffer-total-lines)

                      " "

                      (:eval
                       (pcase evil-state
                         ('normal "N")
                         ('insert "I")
                         ('visual "V")
                         ('emacs "E")
                         ('replace "R")))

                      ;;"%I"

                      ;; is narrowed
                      "%n"

                      " | "

                      ;; Print error if any
                      "%e"

                      ;; Print mode
                      "%m > " 
                      ;; Print buffer name

                      ;;(:eval (buffer-name))

                      (:eval my/buffer-name)

                      ;;"%b"

                      ;; Git branch and project name
                      (:eval (if (not (string= my/projectile-project-name "-"))
                                 (progn
                                   (concat
                                    " > " 
                                    my/buffer-git-branch
                                    "@"
                                    "["
                                    my/projectile-project-name
                                    "]"))))


                      ;;which-func-current

                      ;; (:eval
                      ;; (let ((which-func (which-function)))
                      ;; (if which-func
                      ;; (concat
                      ;; " "
                      ;; which-func))))

                      ;; If memory is less than 1GB
                      (:eval (if (< my/available-mem 1000000000)
                                 "GC FULL! JUMP SHIP!"))
                      ))
                    )

                   (format-mode-line
                    (quote
                     (
                      (:eval my/past-alerts)

                      "| "

                      (:eval (if my/mode-line-show-GC-stats
                                 (concat
                                  " GC: " (number-to-string (truncate gc-elapsed))
                                  "(" (number-to-string gcs-done) ")"
                                  " |"
                                  )))

                      (:eval (if my/mode-line-enable-network-traffic
                                 (concat
                                  my/tx-delta-formatted " ↑ "
                                  my/rx-delta-formatted " ↓ |")))

                      (:eval (if my/mode-line-enable-available-mem
                                 (concat " MEM: "
                                         my/available-mem-formatted
                                         " | ")))

                      ;;(:eval (concat "Org:" org-mode-line-string))
                      (:eval (if (boundp 'org-mode-line-string)
                                 (concat "Org:" org-mode-line-string " | ")))
                      (:eval (if (not (eq battery-mode-line-string ""))
                                 (concat "BAT: " battery-mode-line-string "%%%   | ")))

                      (:eval (if my/mode-line-enable-cpu-temp
                                 (concat " - " my/cpu-temp)))

                      "C: "
                      (:eval (number-to-string my/load-average))

                      " |"

                      (:eval (concat " Up: " my/uptime-total-time-formated))

                      " | "

                      (:eval my/gnus-unread-string)


                      " | "

                      (:eval my/time)

                      " - "

                      (:eval my/date)

                      ))
                    ))))
#+END_SRC

* Restore gc mem
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold my/final-gc-mem)
#+END_SRC

* Report start time
#+BEGIN_SRC emacs-lisp
  (run-with-timer 4 nil (lambda () (interactive) (message (concat "Booted in " (emacs-init-time) " seconds"))))
#+END_SRC

* Confirm config works
#+BEGIN_SRC emacs-lisp
  (defun my/unmark-config-error ()
    (delete-file my/config-error-marker))
  (my/unmark-config-error)
#+END_SRC

