* Docs
** Requirements
*** All
=xorg-server xorg-xrandr xorg-xinit xorg-setxkbmap mlocate atool unzip mono pulseaudio pavucontrol icecat/firefox the_silver_searcher imagemagick ttf-inconsolata ttf-opensans ttf-dejavu aspell aspell-en aspell-sv mpd mpc poppler poppler-glib=
*** All optional
=msbuild dotnet-sdk godot-mono guile fsharp=

*** UTF-8 support
=ttf-dejavu= fills in the gaps where opensans doesn't have the character

*** Music
=mpd= =mpc= 
=pulse audio= if alsa, etc, edit "MPD/Create config".

*** Search
=the silver searcher/ ag=
=grep=

*** Code
**** Documentation
=zeal=

**** C#
=mono= 
=M-x omnisharp-install-server=

**** F#
=mono= (3.10.X or higher) =F#= (3.0 or higher) 
To create solution file, check github
On windows, you may need to manually point to server path, see github

**** Clojure
=leiningen= =clojure=

*** Screenshots
=imagemagick=

*** Overtone
=jack2= =leiningen= =cider=

To start =leiningen= in emacs do =cider-jack-in=

Input =(use 'overtone.live)= into leiningen to install

**** To use with pulse audio
=cadence= and =pulseaudio-jack=

*** Spelling
=aspell-en= etc

*** Gnus
Set adress in gnus.el

*** Laptop
=xorg-xbacklight=
=wpa_supplicant=

*** Switch Ctrl and Caps
=xmodmap= =xsession=

*** PDF tools
=poppler= =poppler-glib=
M-x =pdf-tools-install=

*** GPG pinentry
=gpg2= =pinentry=

*** Misc
=redshift= 

** Firefox vimium
*** Config
#+BEGIN_SRC
# Rebind up/down
unbind n
unbind N
map n scrollDown
map N previousTab
unbind p
unbind P
map p scrollUp
map P nextTab

unbind k
unbind K
map k openCopiedUrlInCurrentTab
map K openCopiedUrlInNewTab

# Rebind scroll
unbind <c-u>
unbind <c-d>
map <c-u> scrollPageUp
map <c-d> scrollPageDown

# Rebind tab close
unbind s
map s removeTab
#+END_SRC

*** Hint characters
#+BEGIN_SRC
anetoshdirgmlwyfubxcvkp,.q;j/z
#+END_SRC

** FSharp
*** File is not part of the loaded projects
Try having the =fsproj= file open in a buffer or try moving the project folder directly to the home folder

** Overtone
*** Pulse-jack
**** How to configure jack2 to work with pulse
https://wiki.archlinux.org/index.php/PulseAudio/Examples#PulseAudio_through_JACK
(The KXStudio method)

1. get =cadence= and =pulseaudio-jack=
   
2. Bridge alsa -> pulse -> jack

3. Autostart maybe???

4. Configure -> Alsa -> Good settings

**** Pauvcontrol measures sound but can't hear anything
Unmute the sound device in pauvcontrol

**** How should jack be started???
Let overtone (actually it's supercollider, since overtone is just a wrapper for using supercollider in clojure) do it (it does it automatically when inputting =(use 'overtone.live)= in leiningen)

*** Jack only
1. add =autospawn = no= in =~/.config/pulse/client.conf= 
2. kill pulseaudio with =pulseaudio -k= 
3. get =jack2= (NOT jack2-dbus, does't work)
4. start overtone

**** Still doesn't work
Get =qjackctl= and start =jack2= from there

*** Sounds only play in one ear??
https://github.com/overtone/overtone/wiki/Multi-channel-expansion,-stereo-and-panning
You have to specify sound channel in the code when using certain sounds

*** Overtone errors out all the time
Execute script up to down, put =(use 'overtone.live)= on top of file, and in leiningen

*** Shit doesn't work
just fiddle around with cadence (check if bridge type is correct, then force restart until it works)

** Dired
*** Archives in dired
Press c to compress, Z to extract
To stop dired from creating new folder when unpacking, change in section "Dired atool"

** Can't find package error
run
=package-refresh-contents=
or restart emacs
** Gnus 
*** How to setup name and password
Create authinfo.pgp file. It is auto encrypted/decrypted

Format for gmail is currently
#+BEGIN_SRC
machine imap.gmail.com login <USER> password <APP-PASSWORD> port imaps
machine smtp.gmail.com login <USER> password <APP-PASSWORD> port 587
machine imap-mail.outlook.com login my-username@hotmail.com password my-secret-password port 993
#+END_SRC

*** gnus mails are not updating
Try doing C-u M-g twice inside that inbox

*** Where are my servers/passwords stored?
=~/.authinfo.gpg=

*** How to download articles using gnus?
use =M-x gnus-agent-add-server=

*** Mail server mails aren't marked as read when marking as read in gnus, and gnus isn't marking them as read either after exit
You have to press =q= in order to save changes

** wpa supplicant
https://wiki.archlinux.org/index.php/WPA_supplicant#Connecting_with_wpa_cli

** MPD
*** "no mpd daemon running" 
Disable daemon if using systemctl with =systemctl disable mpd.service mpd.socket=

** Eww
*** Opening local file results in raw page
This is because the file isn't named =FILE.html=, when eww saves pages, it doesn't add =.html= at the end

** Keyboard setup
*** Change keyboard layout
To list keymaps, do =localectl list-keymaps=

=carpalx= is example layout
To load keymaps, in terminal do: =loadkeys carpalx=

To make permanent:
in =/etc/vconsole.conf=
#+BEGIN_SRC
KEYMAP=carpalx
FONT=lat9w-16
#+END_SRC

*** Swap Ctrl and Caps_Lock
Load correct keymap
1. Do =sudo dumpkeys | head -1 > ~/Keys.map=
2. Add this under the one line long Keys.map
#+BEGIN_SRC maps
keycode 58 = Control # Makes Caps Lock act as ctrl
keycode 29 = Caps_Lock # Makes ctrl act as caps
# alt_is_meta # Fix the alt key?
#+END_SRC
3. Do =sudo loadkeys ~/Keys.map=

** Interesting stuff
highlight-changes-mode (built in)
goto-chg (goto last change)

** Color picking
Get =gpick=

* Security
#+BEGIN_SRC emacs-lisp
  (setq network-security-level 'high)
#+END_SRC

** Make authinfo gpg file
#+BEGIN_SRC emacs-lisp
  (setq netrc-file "~/.authinfo.gpg")
#+END_SRC

* Persistent keys
#+BEGIN_SRC emacs-lisp
  (defvar my/keys-mode-map (make-sparse-keymap))

  ;; Emacs 27 doesn't support :init-value, :keymap, etc
  (if (string< emacs-version "27")
      (define-minor-mode my/keys-mode
        ;; init value t to enable it in fundamental mode
        ;; More info: http://emacs.stackexchange.com/q/16693/115
        :init-value t
        :keymap my/keys-mode-map)
    (define-minor-mode my/keys-mode nil t nil my/keys-mode-map))

  (add-to-list 'emulation-mode-map-alists `((my/keys-mode . ,my/keys-mode-map)))

  ;; Turn off the minor mode in the minibuffer
  (defun my/keys-mode-turn-off ()
    (my/keys-mode -1))

  (defun my/keys-mode-turn-on ()
    (my/keys-mode 1))
#+END_SRC

** Mode specific settings
#+BEGIN_SRC emacs-lisp
  ;; Disable keys in minibuffers such as ivy, etc
  (add-hook 'minibuffer-setup-hook 'my/keys-mode-turn-off)
  ;;(add-hook 'messages-buffer-mode-hook 'my/keys-mode-turn-on)
#+END_SRC

* Global setting
Define my mode for setting global settings in all buffers
#+BEGIN_SRC emacs-lisp
  ;; (define-minor-mode my/mode nil t nil nil)
  ;; 
  ;; (define-globalized-minor-mode my/global-mode my/mode
    ;; (lambda ()
      ;; (setq my/truncate-lines nil)))
      ;; ;;(toggle-truncate-lines -1)))
  ;; 
  ;; (my/global-mode 1)
#+END_SRC

* Generic functions and variables
** File management
*** Create directory if directory doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-dir-if-not-exist (dir)
    (if (not (file-directory-p dir))
        (progn
          (make-directory dir)
          (message (concat "dir: " dir " created!")))))
#+END_SRC

*** Create file if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-if-not-exist (file)
    (if (not (file-exists-p file))
        (progn
          (write-region "" nil file)
          (message (concat "Wrote file: " file " created!")))))
#+END_SRC

*** Create file with content if file doesn't exist
#+BEGIN_SRC emacs-lisp
  (defun my/create-file-with-content-if-not-exist (file content)
    (if (not (file-exists-p file))
        (progn
          (write-region content nil file)
          (message (concat "Wrote file: " file " with contents")))))
;;" created with content: " content
#+END_SRC

*** Add to content to file or create file with content if file doesn't exist 
#+BEGIN_SRC emacs-lisp
  (defun my/add-to-or-create-file-with-content (file content)
          (write-region (concat "\n" content) nil file t)
          (message (concat "Wrote file: " file " with contents")))
#+END_SRC

** Is external package installed
Checks variable =exec-path= for package
#+BEGIN_SRC emacs-lisp
  (defun my/is-system-package-installed (package)
    (if (executable-find (symbol-name package))
        (symbol-name package)
      (message (concat "Package: " (symbol-name package) " not installed"))
      ()))
#+END_SRC

*** Set exec-path by system
#+BEGIN_SRC emacs-lisp
  ;;(if (string-match-p "guixsd" (system-name))
      ;;(add-to-list 'exec-path "/bin/" ))
#+END_SRC

** Give buffer unique name
#+BEGIN_SRC emacs-lisp
  (defun my/give-buffer-unique-name(base-name)
    (rename-buffer base-name t))
#+END_SRC

** Is font installed
#+BEGIN_SRC emacs-lisp
  (defvar my/font-family-list (font-family-list))
  (defun my/font-installed (font)
    (if (member font my/font-family-list)
      t
      nil))
#+END_SRC

** Fold ellipsis 
#+BEGIN_SRC emacs-lisp
  (defvar my/fold-ellipsis)
  (defvar my/fold-ellipsis-char)

  (if window-system
      (progn
        (setq my/fold-ellipsis "↴")
        (setq my/fold-ellipsis-char ?↴))
    ;; The terminal probably doesn't support unicode
    (setq my/fold-ellipsis "↓")
    (setq my/fold-ellipsis-char ?↓))
#+END_SRC

** File size human readable
Default file-size-human-readable returns decimal values
#+BEGIN_SRC emacs-lisp
  (require 'files)

  (defun my/file-size-human-readable (file-size &optional flavor decimal)
    "Produce a string showing FILE-SIZE in human-readable form.

  Optional second argument FLAVOR controls the units and the display format:

   If FLAVOR is nil or omitted, each kilobyte is 1024 bytes and the produced
      suffixes are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `si', each kilobyte is 1000 bytes and the produced suffixes
      are \"k\", \"M\", \"G\", \"T\", etc.
   If FLAVOR is `iec', each kilobyte is 1024 bytes and the produced suffixes
      are \"KiB\", \"MiB\", \"GiB\", \"TiB\", etc.
   If DECIMAL is true, a decimal number is returned"
    (setq 1024Decimal (if decimal 1024.0 1024))
    (setq 1000Decimal (if decimal 1000.0 1000))

    (let ((power (if (or (null flavor) (eq flavor 'iec))
                     1024Decimal
                   1000Decimal))
          (post-fixes
           ;; none, kilo, mega, giga, tera, peta, exa, zetta, yotta
           (list "" "k" "M" "G" "T" "P" "E" "Z" "Y")))
      (while (and (>= file-size power) (cdr post-fixes))
        (setq file-size (/ file-size power)
              post-fixes (cdr post-fixes)))
      (format (if (> (mod file-size 1.0) 0.05)
                  "%.1f%s%s"
                "%.0f%s%s")
              file-size
              (if (and (eq flavor 'iec) (string= (car post-fixes) "k"))
                  "K"
                (car post-fixes))
              (if (eq flavor 'iec) "iB" ""))))
#+END_SRC

** Set font
#+BEGIN_SRC emacs-lisp
  (defvar my/default-face-height 120)
  (defun my/set-default-font(font)
    (if window-system
        (set-face-attribute 'default nil
                            :family font
                            :height my/default-face-height)))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp
  ;; (when window-system
    ;; (use-package twilight-anti-bright-theme)
    ;; (load-theme 'twilight-anti-bright t))

  (when (not window-system)
    (load-theme 'wheatgrass t))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp  
  (defvar my/is-font-mono nil)
  (defvar my/font nil)
  (defvar my/font-raw nil)

  (if (my/font-installed "FreeSans")
      (progn
        (setq my/font-raw "FreeSans")
        (setq my/font "FreeSans"))
    (if (my/font-installed "Open Sans")
        (progn
          (setq my/font-raw "Open Sans")
          (setq my/font "opensans"))
      (if (my/font-installed "dejavu sans")
          (progn
            (setq my/font-raw "dejavu sans")
            (setq my/font "DejaVuSans")))))

  (if my/font
      (my/set-default-font my/font))
#+END_SRC

** Mono font
#+BEGIN_SRC emacs-lisp
  (defun my/get-best-mono-font ()
    (if my/is-font-mono
        my/font
      (if (my/font-installed "Inconsolata")
          "Inconsolata"
        (if (my/font-installed "dejavu sans mono")
            "DejaVuSansMono"
          (if (my/font-installed "Noto Sans Mono")
              "NotoSansMono"
            (if (my/font-installed "Perfect DOS VGA 437")
                "Perfect DOS VGA 437"))))))

  (defvar my/mono-font (my/get-best-mono-font))
#+END_SRC

** Make sure mode line is disabled before any windows are created
#+BEGIN_SRC emacs-lisp
  (if window-system
      (progn
        (setq mode-line-format "")
        (setq-default mode-line-format ""))
    (setq mode-line-format nil)
    (setq-default mode-line-format nil))
#+END_SRC

* Startup processes
** Prevent async command from opening new window
#+BEGIN_SRC emacs-lisp
  ;; Buffers that I don't want popping up by default
  (add-to-list 'display-buffer-alist
               '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+END_SRC

** Check if OS is fully compatible
#+BEGIN_SRC emacs-lisp
  (defvar fully-compatible-system (or (eq system-type 'gnu/linux)(eq system-type 'gnu)(eq system-type 'gnu/kfreebsd)))
#+END_SRC

** Redshift 
#+BEGIN_SRC emacs-lisp
  (if (my/is-system-package-installed 'redshift)
      (start-process "redshift" nil "redshift"))
#+END_SRC

** Garbage collection
#+BEGIN_SRC emacs-lisp
  (setq garbage-collection-messages t)

  ;; Get 80% of memory
  (defvar my/emacs-max-ram-usage (floor (* (* (car (memory-info)) 0.8) 1024))
    "Max ram emacs can use before having to jump ship
  Is in bytes")

    (if my/emacs-max-ram-usage
        (setq gc-cons-threshold my/emacs-max-ram-usage))

  ;; (defun garbage-collect (&rest args) 
    ;; (message "Emacs is trying to garbage collect, it's time to jump ship"))
#+END_SRC

** Disable custom
Stop custom from editing init.el
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory ".emacs-custom.el"))
#+END_SRC

* Backups
Stop emacs from creating backup files on every save
#+BEGIN_SRC emacs-lisp
  ;;(setq make-backup-files nil)
  ;;(setq auto-save-default nil)
  ;; Make multiple backups
  (setq version-control t)

  ;; Backup even if file is under version control
  (setq vc-make-backup-files t)

  (setq backup-by-copying t)      ; don't clobber symlinks
  (setq delete-old-versions t)
  (setq kept-new-versions 6)
  (setq kept-old-versions 2)

  (defvar my/backup-directory (concat user-emacs-directory "backups/"))
  (defvar my/auto-saves-directory (concat user-emacs-directory "auto-saves/"))

  (my/create-dir-if-not-exist my/backup-directory)

  (my/create-dir-if-not-exist my/auto-saves-directory)

  (setq backup-directory-alist `(("." . ,my/backup-directory)))
  (setq auto-save-file-name-transforms `((".*" ,my/auto-saves-directory t)))
#+END_SRC

** Make backup on every save
https://www.emacswiki.org/emacs/ForceBackups
#+BEGIN_SRC emacs-lisp
  (defvar my/create-per-session-backups t)
  ;; Max amount of characters, 200 000 ~200kb
  (defvar my/per-session-backup-limit 200000)

  (defvar my/backup-per-session-directory (concat my/backup-directory "per-session/"))

  (my/create-dir-if-not-exist my/backup-per-session-directory)

  (defun my/force-backup-of-buffer ()
    (interactive)
    (if (and my/create-per-session-backups (< (point-max) my/per-session-backup-limit) (buffer-modified-p))
        (save-restriction (widen) (write-region (point-min) (point-max) (concat my/backup-per-session-directory (number-to-string (time-to-seconds)) (buffer-name)) nil nil nil))))
#+END_SRC

** Delete old backups
#+BEGIN_SRC emacs-lisp
  ;; Automatically delete old backup files older than a week
  (message "Deleting old backup files...")
  (let ((week (* 60 60 24 7))
        (current (float-time (current-time))))
    (dolist (file (directory-files my/backup-directory t))
      (when (and (backup-file-name-p file)
               (> (- current (float-time (nth 5 (file-attributes file))))
                  week))
        (message "%s" file)
        (delete-file file))))
#+END_SRC

** Delete per-session backups on startup
#+BEGIN_SRC emacs-lisp
  (shell-command (concat "rm " my/backup-per-session-directory "*" ))
#+END_SRC

** Disble backups for certain files
#+BEGIN_SRC emacs-lisp
  (define-minor-mode my/no-backups-mode
    "http://anirudhsasikumar.net/blog/2005.01.21.html
  For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    "no-backups"
    ;; The minor mode bindings.
    nil
    (if (symbol-value my/no-backups-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t) 
          ;; disable auto-save
          (if auto-save-default
              (progn
                (setq my/create-per-session-backups nil)
                (auto-save-mode -1))))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (progn
            (setq my/create-per-session-backups t)
            (auto-save-mode 1)))))
#+END_SRC

*** File types to not backup
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.gpg$" . my/no-backups-mode))

  (add-hook 'image-mode-hook 'my/no-backups-mode)
#+END_SRC

** Undo tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree)

  (setq global-undo-tree-mode t)

  ;; Fixes errors
  (setq undo-tree-enable-undo-in-region nil)
  (setq-default undo-tree-enable-undo-in-region nil)

  ;; (setq undo-tree-auto-save-history t)
  ;; (setq-default undo-tree-auto-save-history t)

  (setq undo-tree-visualizer-lazy-drawing nil)
  (setq-default undo-tree-visualizer-lazy-drawing nil)

  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)

  ;;(setq undo-tree-auto-save-history t)

  ;;(setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/saves")))
  ;;(make-directory (concat spacemacs-cache-directory "undo"))
#+END_SRC

* Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil)

  ;;(fset 'evil-visual-update-x-selection 'ignore)
  (evil-mode)

  (setq evil-search-module 'evil-search)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)

  ;; Makes swiper A LOT faster
  (setq evil-ex-interactive-search-highlight t)
  (setq evil-ex-search-persistent-highlight nil)
#+END_SRC

** Settings
*** Disable messages in echo area
Evil spams message area
#+BEGIN_SRC emacs-lisp
(setq
    evil-emacs-state-message nil
    evil-operator-state-message nil
    evil-insert-state-message nil
    evil-replace-state-message nil
    evil-motion-state-message nil
    evil-normal-state-message nil
    evil-visual-state-message nil)
#+END_SRC

*** Cursor states
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-cursor '("purple" box))
  (setq evil-normal-state-cursor '("white" box))
  (setq evil-visual-state-cursor '("yellow" box))
  (setq evil-insert-state-cursor '("orange" box))
  (setq evil-replace-state-cursor '("green" box))
  (setq evil-operator-state-cursor '("white" hollow))
#+END_SRC

*** Exit emacs state with esc
#+BEGIN_SRC emacs-lisp
  (define-key evil-emacs-state-map [escape] 'evil-normal-state)
#+END_SRC

*** Disable emacs mode 
#+BEGIN_SRC emacs-lisp
  (setq evil-emacs-state-modes nil)
#+END_SRC

*** Set which modes use which evil state by default
Example
#+BEGIN_SRC emacs-lisp
  (setq evil-insert-state-modes nil)

  (if (string< emacs-version "24.3")
      (error "Since emacs version is under 24.3, you need to remove cl-... in this section, and add (require 'cl) (not recommended to do in later versions)"))

  (cl-loop for (mode . state) in '(
                                   ;; So i C-leader works for exwm windows
                                   (exwm-mode . insert)
                                   ;;(eshell-mode . insert)
                                   (term-mode . insert)
                                   ;;(org-agenda-mode . insert)
                                   (magit-popup-mode . insert)
                                   (proced-mode . insert)
                                   (emms-playlist-mode . insert))
           do (evil-set-initial-state mode state))
#+END_SRC

*** Switching to normal state without moving cursor
#+BEGIN_SRC emacs-lisp
  (defun my/evil-normal-state (&optional arg)
    (if (not(eq evil-state 'normal))
        (progn
          (evil-normal-state arg)
          (move-to-column (+ 1 (current-column))))))
#+END_SRC

*** Make one space enough to end work for use with evil sentence motion
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

*** Make dd and cc act on lines
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map "D" 'evil-delete-whole-line)
  (define-key evil-normal-state-map "C" 'evil-change-whole-line)
#+END_SRC

** Text objects
*** Evil-indent-plus
Allows for using indention as text objects
#+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus)

  (define-key evil-inner-text-objects-map "i" 'evil-indent-plus-i-indent)
  (define-key evil-outer-text-objects-map "i" 'evil-indent-plus-a-indent)
  (define-key evil-inner-text-objects-map "I" 'evil-indent-plus-i-indent-up)
  (define-key evil-outer-text-objects-map "I" 'evil-indent-plus-a-indent-up)
  (define-key evil-inner-text-objects-map "C-i" 'evil-indent-plus-i-indent-up-down)
  (define-key evil-outer-text-objects-map "C-i" 'evil-indent-plus-a-indent-up-down)
#+END_SRC

*** Evil textobject block
#+BEGIN_SRC emacs-lisp
  (use-package evil-textobj-anyblock)

  (define-key evil-inner-text-objects-map "b" 'evil-textobj-anyblock-inner-block)
  (define-key evil-outer-text-objects-map "b" 'evil-textobj-anyblock-a-block)

  (define-key evil-motion-state-map "!" 'evil-textobj-anyblock-forward-open-block-start)

  ;; (add-hook 'lisp-mode-hook
  ;; (lambda ()
  ;; (setq-local evil-textobj-anyblock-blocks
  ;; '(("(" . ")")
  ;; ("{" . "}")
  ;; ("\\[" . "\\]")
  ;; ("\"" . "\"")))))
#+END_SRC

*** Evil-surround
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround)
  (global-evil-surround-mode 1)
#+END_SRC

*** Evil-args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args)

  ;; bind evil-args text objects
  (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
  (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
#+END_SRC

** Evil-lion
#+BEGIN_SRC emacs-lisp
  ;;(use-package evil-lion)

  ;;(evil-lion-mode)
#+END_SRC

** Evil-goggles
#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles)
  (evil-goggles-mode)
  ;; Disable pulse which both fixes so that you can set foreground color on the pulse font and saves on performance
  (setq evil-goggles-pulse nil)
  (setq evil-goggles-duration 60)

  (evil-goggles-use-diff-faces)
#+END_SRC

** Evil-matchit
#+BEGIN_SRC emacs-lisp
  (use-package evil-matchit)
  (global-evil-matchit-mode 1)
#+END_SRC

** Evil-multiple cursors
#+BEGIN_SRC emacs-lisp
  ;; (use-package evil-mc)
;; 
  ;; (global-evil-mc-mode 1)
;; 
  ;; (define-prefix-command 'my/evil-mc-map)
  ;; (define-key evil-normal-state-map (kbd "m") 'my/evil-mc-map)
  ;; (define-key evil-visual-state-map (kbd "m") 'my/evil-mc-map)
;; 
  ;; (define-key my/evil-mc-map (kbd "d") 'evil-mc-undo-all-cursors)
  ;; (define-key my/evil-mc-map (kbd "v") 'evil-mc-make-cursor-here)
  ;; (define-key my/evil-mc-map (kbd "V") 'evil-mc-make-all-cursors)
  ;; (define-key my/evil-mc-map (kbd "s") 'evil-mc-pause-cursors)
  ;; (define-key my/evil-mc-map (kbd "S") 'evil-mc-resume-cursors)
  ;; (define-key my/evil-mc-map (kbd "n") 'evil-mc-make-and-goto-next-cursor)
  ;; (define-key my/evil-mc-map (kbd "p") 'evil-mc-make-and-goto-prev-cursor)
;; 
  ;; (define-key my/evil-mc-map (kbd "g g") 'evil-mc-make-and-goto-first-cursor)
  ;; (define-key my/evil-mc-map (kbd "G") 'evil-mc-make-and-goto-last-cursor)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  ;; Prevent emacs state from being exited with esc, fixes exwm since it uses emacs state and to exit hydra you have to do esc
  (define-key evil-emacs-state-map (kbd "<escape>") 'keyboard-quit)

  ;; Couldn't bother to create custom evil-join
  (define-key evil-normal-state-map (kbd "P") 'delete-indentation)
#+END_SRC

*** Rebind z to case change
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "z") 'evil-downcase)
  (define-key evil-normal-state-map (kbd "Z") 'evil-upcase)
#+END_SRC

*** Add perspective movement to g
#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map "gw" 'evil-scroll-line-to-top)
(define-key evil-normal-state-map "ge" 'evil-scroll-line-to-center)
(define-key evil-normal-state-map "gu" 'evil-scroll-line-to-bottom)
#+END_SRC

*** Don't complete from all buffers
#+BEGIN_SRC emacs-lisp
(setq evil-complete-all-buffers nil)
#+END_SRC

*** Don't add pasted over thing to killring
#+BEGIN_SRC emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+END_SRC

* Leader
When changing leader, change =my/leader-map-key= and manually change all general simulate key rebinds
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/leader-map)

  (defvar my/leader-map-key "SPC")
  (defvar my/mod-leader-map-key "C-SPC")

  (defvar my/window-leader-key "C-=")
  (defvar my/mod-window-leader-key "M-C-=")

  (define-prefix-command 'my/help-map)
  (define-key my/leader-map (kbd "H") 'my/help-map)

  (evil-define-key 'normal my/keys-mode-map (kbd "U") 'undo-tree-visualize)

  (evil-define-key 'normal my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)
  (evil-define-key 'motion my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)
  (evil-define-key 'visual my/keys-mode-map (kbd my/leader-map-key) 'my/leader-map)

  ;; Enable leader even if my/keys-mode isn't active
  (define-key evil-motion-state-map (kbd my/leader-map-key) 'my/leader-map)
  (define-key evil-normal-state-map (kbd my/leader-map-key) 'my/leader-map)
#+END_SRC

* Package management
** Guix
#+BEGIN_SRC emacs-lisp
  (use-package guix)
#+END_SRC
  
*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/guix-map)
  (define-key my/leader-map (kbd "G") 'my/guix-map)

  (define-key my/guix-map (kbd "v") 'guix)
  (define-key my/guix-map (kbd "P") 'guix-profiles)
  (define-key my/guix-map (kbd "g") 'guix-generation)
  (define-key my/guix-map (kbd "G") 'guix-system-generations)
  (define-key my/guix-map (kbd "i") 'guix-installed-user-packages)
  (define-key my/guix-map (kbd "I") 'guix-installed-system-packages)

  (define-prefix-command 'my/guix-services-map)
  (define-key my/guix-map (kbd "s") 'my/guix-services-map)

  (define-key my/guix-services-map (kbd "a") 'guix-all-services)
  (define-key my/guix-services-map (kbd "n") 'guix-services-by-name)
  (define-key my/guix-services-map (kbd "l") 'guix-services-by-location)
  (define-key my/guix-services-map (kbd "d") 'guix-find-service-definition)

  (define-prefix-command 'my/guix-package-map)
  (define-key my/guix-map (kbd "p") 'my/guix-package-map)

  (define-key my/guix-package-map (kbd "a") 'guix-all-packages)
  (define-key my/guix-package-map (kbd "n") 'guix-packages-by-name)
  (define-key my/guix-package-map (kbd "l") 'guix-packages-by-location)
  (define-key my/guix-package-map (kbd "c") 'guix-packages-from-system-config-file)
  (define-key my/guix-package-map (kbd "d") 'guix-find-package-definition)

  (define-prefix-command 'my/guix-store-map)
  (define-key my/guix-map (kbd "S") 'my/guix-store-map)

  (define-key my/guix-store-map (kbd "l") 'guix-store-live-items)
  (define-key my/guix-store-map (kbd "d") 'guix-store-dead-items)
  (define-key my/guix-store-map (kbd "D") 'guix-store-item-derivers)
  (define-key my/guix-store-map (kbd "f") 'guix-store-failures)
  (define-key my/guix-store-map (kbd "r") 'guix-store-item-references)
  (define-key my/guix-store-map (kbd "R") 'guix-store-item-referrers)
  (define-key my/guix-store-map (kbd "C-r") 'guix-store-item-requisites)
#+END_SRC

** Local packages
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name (concat user-emacs-directory "local-packages")))
#+END_SRC

* Write config map
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/write-config-map)
  (define-key my/leader-map (kbd "C-c") 'my/write-config-map)
#+END_SRC

** Write .gnus.el
Create =.gnus.el=, which gnus reads from 
#+BEGIN_SRC emacs-lisp
  (defun my/write-gnus ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.gnus.el" "
  AddYourEmailHereThenDeleteThis
  (setq mail-host-address \"MyAdress\")
  ")))

  (define-key my/write-config-map (kbd "g") 'my/write-gnus)
#+END_SRC

** Write .Xdefaults
emacs. commands to disable scrollbar, etc before launching emacs, improving startup time
#+BEGIN_SRC emacs-lisp
  (defun my/write-xdefaults ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.Xdefaults" " 
  emacs.toolBar: 0
  emacs.menuBar: 0
  emacs.verticalScrollBars: off" )))

  (define-key my/write-config-map (kbd "d") 'my/write-xdefaults)
#+END_SRC

** Write .xinitrc
=xset s= disables screen saver
setxkbmap to select keyboard layout

#+BEGIN_SRC emacs-lisp
  (defun my/write-xinitrc ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xinitrc" "
  xset s off
  xset s noblank
  xset s off
  xset s off -dpms

  setxkbmap -layout us -variant altgr-intl
  # setxkbmap -layout carpalx -variant qgmlwy

  xmodmap ~./xmodmap

  # Fix java windows in exwm
  export _JAVA_AWT_WM_NONREPARENTING=1

  exec emacs")))

  (define-key my/write-config-map (kbd "i") 'my/write-xinitrc)
#+END_SRC

** Write .xmodmap
This swaps capslock and ctrl
#+BEGIN_SRC emacs-lisp
  (defun my/write-xmodmap ()
    (interactive)
    (if(eq fully-compatible-system t)
        (my/create-file-with-content-if-not-exist "~/.xmodmap" " 
  ! Swap Caps_Lock and Control_L
  remove Lock = Caps_Lock
  remove Control = Control_L
  keysym Control_L = Caps_Lock
  keysym Caps_Lock = Control_L
  add Lock = Caps_Lock
  add Control = Control_L
  ")))

  (define-key my/write-config-map (kbd "m") 'my/write-xmodmap)
#+END_SRC

** Write mpd
#+BEGIN_SRC emacs-lisp
  (defun my/setup-mpd ()
    (interactive)
    (setq my/config-directory "~/.config/")
    (my/create-dir-if-not-exist my/config-directory)

    (setq my/mpd-directory (concat my/config-directory "mpd/"))
    (my/create-dir-if-not-exist my/mpd-directory)

    (setq my/mpd-conf-file (concat my/mpd-directory "mpd.conf"))
    (my/create-file-with-content-if-not-exist my/mpd-conf-file "
  music_directory \"~/Music\"
  playlist_directory  \"~/.config/mpd/playlists\"
  db_file \"~/.config/mpd/mpd.db\"
  log_file \"~/.config/mpd/mpd.log\"
  bind_to_address \"127.0.0.1\"
  port \"6600\"

  # For pulse audio
  audio_output {
  type \"pulse\"
  name \"pulse audio\"
  }
                   ")

    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.log"))
    (my/create-file-if-not-exist (concat my/mpd-directory "mpd.db"))
    (my/create-dir-if-not-exist (concat my/mpd-directory "playlists/")))

  (define-key my/write-config-map (kbd "m") 'my/setup-mpd)
#+END_SRC

** Write GPG pinentry
#+BEGIN_SRC emacs-lisp
  (defun my/setup-gpg-agent ()
    (interactive)
    (setq my/gpg-directory "~/.gnupg/")
    (my/create-dir-if-not-exist my/gpg-directory)

    (setq my/gpg-agent-conf-file (concat my/gpg-directory "gpg-agent.conf"))
    (my/create-file-with-content-if-not-exist my/gpg-agent-conf-file "allow-emacs-pinentry")
    (shell-command "gpgconf --reload gpg-agent"))

  (define-key my/write-config-map (kbd "C-g") 'my/setup-gpg-agent)
#+END_SRC

** Write all configs
#+BEGIN_SRC emacs-lisp
  (defun my/write-all-config ()
    (interactive)
    (my/write-xdefaults)
    (my/write-xinitrc)
    (my/write-gnus)
    (my/setup-mpd))

  (define-key my/write-config-map (kbd "a") 'my/write-all-config)
#+END_SRC

* Install software
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/software-install-map)
  (define-key my/leader-map (kbd "I") 'my/software-install-map)
#+END_SRC

** Install eclipse java language server
For use with lsp-java
#+BEGIN_SRC emacs-lisp
  (defun my/install-eclipse-java-language-server()
    (interactive)
    (shell-command "
  rm -rf ~/.emacs.d/eclipse.jdt.ls/server/
  mkdir -p ~/.emacs.d/eclipse.jdt.ls/server/
  wget http://download.eclipse.org/jdtls/snapshots/jdt-language-server-latest.tar.gz -O /tmp/jdt-latest.tar
  tar xf /tmp/jdt-latest.tar -C ~/.emacs.d/eclipse.jdt.ls/server/
  "))

  (define-key my/software-install-map (kbd "j") 'my/install-eclipse-java-language-server)
#+END_SRC

** Install pdf tools
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "p") 'pdf-tools-install)
#+END_SRC

** Install omnisharp
#+BEGIN_SRC emacs-lisp
  (define-key my/software-install-map (kbd "o") 'omnisharp-install-server)
#+END_SRC

** Compile config
#+BEGIN_SRC emacs-lisp
  (defun my/compile-config ()
    (interactive)
    (byte-compile-file my/config-exported-location nil))

  (define-key my/software-install-map (kbd "C-c") 'my/compile-config)
#+END_SRC

* Minor
** Startup
Disable startup message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

** Scratch buffer
*** Disable initial scratch buffer message
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

** Encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

** Line wrapping
*** Enable truncate lines mode
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines nil)
  (setq truncate-lines nil)

  ;; Always truncate lines
  (setq truncate-partial-width-windows nil)
  (setq-default truncate-partial-width-windows nil)
#+END_SRC

*** Visual-line mode
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 0)

  (define-key my/leader-map (kbd "C-v") 'visual-line-mode)

#+END_SRC
*** Fringe indicators of wrapped line
#+BEGIN_SRC emacs-lisp
  (setq visual-line-fringe-indicators '(right-triangle nil))
#+END_SRC

** Disable useless functionallity
#+BEGIN_SRC emacs-lisp
  (mouse-wheel-mode -1)
  (tooltip-mode -1)
#+END_SRC

** 1 letter prompts
Convert yes or no prompt to y or n prompt
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
  
** Smooth scroll
Scroll 1 line at a time when cursor goes outside screen
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Bell
Disable bell
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Subword (camel case movement)
 #+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
 #+END_SRC

** Change max killring size
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** Pixel scroll mode
In org mode when displaying images pixel scroll mode can be useful maybe
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'org-mode-hook 'pixel-scroll-mode)
#+END_SRC

** Increase and decrease brightness
#+BEGIN_SRC emacs-lisp
  (defun my/increase-brightness ()
    (interactive)
    (shell-command "xbacklight +5"))

  (defun my/decrease-brightness ()
    (interactive)
    (shell-command "xbacklight -5"))

  (global-set-key (kbd "<XF86MonBrightnessUp>") 'my/increase-brightness)
  (global-set-key (kbd "<XF86MonBrightnessDown>") 'my/decrease-brightness)
#+END_SRC

** Update packages
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-u") 'list-packages)
#+END_SRC

** Sudo edit
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :defer t)

  (define-key my/leader-map (kbd "~") 'sudo-edit)
#+END_SRC

** With-editor
#+BEGIN_SRC emacs-lisp
  (use-package with-editor
    :defer t)
#+END_SRC

** Disable all colors
#+BEGIN_SRC emacs-lisp
  (defun my/paper-mode()
    (interactive)
    (cl-loop for face in (face-list) do
            ;; Don't change magit faces
            (if (not (string-match "magit" (symbol-name face)))
             (set-face-attribute face nil :foreground nil :background nil)))
    ;;(setq my/foreground-color "#8b4513")
    ;;(setq my/foreground-color "brown")
    ;;(setq my/background-color "black")

    ;; (setq  my/background-color "#2a1f1f")
    ;; (setq my/foreground-color "#d15120")

    ;; Night theme
    (setq my/foreground-color "gray")
    (setq my/background-color "#14191F")

    ;; Day theme
    (setq my/mark-color "yellow4")
    (setq my/foreground-color "black")
    ;;(setq my/background-color "white") 
    (setq my/background-color "#4682b4") 
    ;;(setq my/background-color "#87cefa") 

    ;; Dark theme 2 - spacemacs  - https://github.com/nashamri/spacemacs-theme/blob/master/spacemacs-common.el
    ;;(setq my/foreground-color "#b2b2b2")
    ;;(setq my/background-color "#292b2e") 

    (setq my/background-color "#f0f0f0")
    (setq my/foreground-color "#232323") 

    (setq my/background-color "#232323")
    (setq my/foreground-color "#E6E1DC") 

    (if window-system
        (progn
          (setq my/foreground-color-1 (color-darken-name my/foreground-color 5))
          (setq my/foreground-color-2 (color-darken-name my/foreground-color 10))
          (setq my/foreground-color-3 (color-darken-name my/foreground-color 15))
          (setq my/foreground-color-4 (color-darken-name my/foreground-color 20))
          (setq my/foreground-color-5 (color-darken-name my/foreground-color 25))
          (setq my/foreground-color-6 (color-darken-name my/foreground-color 30))

          (setq my/background-color-1 (color-lighten-name my/background-color 5))
          (setq my/background-color-2 (color-lighten-name my/background-color 10))
          (setq my/background-color-3 (color-lighten-name my/background-color 15))
          (setq my/background-color-4 (color-lighten-name my/background-color 20)))

      (setq my/foreground-color-1 "brown")
      (setq my/foreground-color-2 "brown")
      (setq my/foreground-color-3 "orange")
      (setq my/foreground-color-4 "orange")
      (setq my/foreground-color-5 "yellow")
      (setq my/foreground-color-6 "yellow")

      (setq my/background-color-1 "black")
      (setq my/background-color-2 "black")
      (setq my/background-color-3 "gray")
      (setq my/background-color-4 "gray"))

    ;;; Emacs
    (set-face-attribute 'default nil :foreground my/foreground-color :background my/background-color)
    (set-face-attribute 'link nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'highlight nil :foreground my/foreground-color :background my/mark-color)
    (set-face-attribute 'region nil :foreground my/foreground-color :background my/mark-color)
    (set-face-attribute 'error nil :foreground "#c6350b" :background)
    (set-face-attribute 'warning nil :foreground "DarkOrange" :background)

    ;; Font lock
    (set-face-attribute  'font-lock-doc-face nil :foreground my/foreground-color :background my/background-color-4)
    (defvar my/comment-face-height (floor (* my/default-face-height 1.15)))
    (set-face-attribute  'font-lock-comment-face nil :foreground my/foreground-color :background my/background-color-1 :height my/comment-face-height)
    (set-face-attribute 'font-lock-string-face nil :foreground my/foreground-color :background my/background-color-1)
    ;; (set-face-attribute  'font-lock-keyword-face nil :foreground my/foreground-color :background my/background-color-1)
    ;; (set-face-attribute  'font-lock-function-name-face nil :foreground my/foreground-color :background my/background-color-2)

    ;; Required by other face
    (set-face-attribute 'outline-4 nil :foreground my/foreground-color :background my/background-color)

    ;; Line numbers
    (set-face-attribute 'line-number-current-line nil :foreground my/foreground-color :background my/background-color)
    (set-face-attribute 'line-number nil :foreground my/foreground-color :background my/background-color)

    ;; Evil
    (setq evil-emacs-state-cursor '("purple" box))
    (setq evil-normal-state-cursor '("red" box))
    (setq evil-visual-state-cursor '("yellow" box))
    (setq evil-insert-state-cursor '("orange" box))
    (setq evil-replace-state-cursor '("green" box))
    (setq evil-operator-state-cursor '("white" hollow))

    ;; On-screen
    ;;(set-face-attribute 'on-screen-shadow nil :foreground nil :background (color-lighten-name my/background-color 2))
    ;;(set-face-attribute 'on-screen-fringe nil :foreground my/foreground-color :background my/background-color)

    ;; Hl current line
    ;; Underlines part of current line
    ;;(set-face-attribute 'hl-line nil :foreground my/foreground-color :background nil :underline t)
    (set-face-attribute 'hl-line nil :foreground my/foreground-color :background my/background-color-2 :underline nil)

    ;;; Dired
    (set-face-attribute 'dired-directory nil :foreground my/background-color :background my/foreground-color)

    ;;; Isearch
    (set-face-attribute 'isearch nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'lazy-highlight nil :foreground my/background-color :background my/foreground-color)

    ;;; Highlight thing
    (set-face-attribute 'highlight-thing nil :foreground my/foreground-color :background my/mark-color)

    ;;; Company
    (set-face-attribute 'company-scrollbar-bg nil :background my/background-color)
    (set-face-attribute 'company-scrollbar-fg nil :background my/foreground-color)

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background my/foreground-color :foreground my/background-color)
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground my/foreground-color :background my/background-color)
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground my/background-color :background my/foreground-color)

    ;;; Ivy
    (set-face-attribute 'ivy-current-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-cursor nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-highlight nil :foreground my/background-color :background my/foreground-color)

    (set-face-attribute 'ivy-minibuffer-match-face-1 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'ivy-minibuffer-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'ivy-minibuffer-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'ivy-minibuffer-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

    ;;; Swiper
    (set-face-attribute 'swiper-match-face-1 nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'swiper-match-face-2 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'swiper-match-face-3 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'swiper-match-face-4 nil :foreground my/background-color :background my/foreground-color-6)

    ;;; Avy
    (set-face-attribute 'avy-lead-face nil :foreground my/background-color :background my/foreground-color-6)
    (set-face-attribute 'avy-lead-face-0 nil :foreground my/background-color :background my/foreground-color-2)
    (set-face-attribute 'avy-lead-face-1 nil :foreground my/background-color :background my/foreground-color-4)
    (set-face-attribute 'avy-lead-face-2 nil :foreground my/background-color :background my/foreground-color-6)

    ;; Eww
    (set-face-attribute 'my/eww-code-face nil :foreground my/foreground-color :background my/background-color-2 :family my/mono-font)

    ;;(defvar my/evil-goggles-highlight-color)
    ;;; Evil-goggles
    ;;; 2 color approach
    ;; (set-face-attribute 'evil-goggles-change-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-commentary-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-delete-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-fill-and-move-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-indent-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-join-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-paste-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-record-macro-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-replace-with-register-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-set-marker-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-shift-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-surround-face nil :foreground my/background-color :background my/foreground-color)
    ;; (set-face-attribute 'evil-goggles-yank-face nil :foreground my/background-color :background my/foreground-color)

    (set-face-attribute 'diff-added nil  :background "#335533")
    (set-face-attribute 'diff-changed nil :background "#aaaa22")
    (set-face-attribute 'diff-removed nil :background "#553333")

    ;; (set-face-attribute 'diff-added nil  :background "green")
    ;; (set-face-attribute 'diff-changed nil :background "yellow")
    ;; (set-face-attribute 'diff-removed nil :background "red")

    ;; Diff-hl 
    (set-face-attribute 'diff-hl-change nil :background (face-attribute 'diff-changed :background))

    ;; Paren highlight
    (set-face-attribute 'show-paren-match nil :foreground my/background-color :background my/foreground-color)
    (set-face-attribute 'show-paren-mismatch nil :background "red")

    ;; Mode line separator
    ;; Set mode line height
    (set-face-attribute 'mode-line nil
                        :foreground my/foreground-color
                        :background my/foreground-color
                        :height  0.1)

    (set-face-attribute 'mode-line-inactive nil
                        :foreground my/background-color
                        :background my/background-color
                        :height  0.1)

    ;; Highlight faces
    ;;(highlight-indent-guides-auto-set-faces)
    )

  (if window-system
      (add-hook 'exwm-init-hook 'my/paper-mode)
    (add-hook 'after-init-hook 'my/paper-mode))

  ;; (counsel-faces)

  (define-key my/leader-map (kbd "M-c") 'my/paper-mode)
#+END_SRC

** Enable disabled commands
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-defun 'disabled nil)
#+END_SRC

** Async
#+BEGIN_SRC emacs-lisp
  (use-package async)

  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode 1)
#+END_SRC

** Zoom
#+BEGIN_SRC emacs-lisp
  ;; (defun my/increase-volume ()
    ;; (interactive)
    ;; (text-scale-set 0))
  ;; (define-key my/leader-map (kbd "+") ')
  ;; (define-key my/leader-map (kbd "_") '(lambda () (interactive) (text-scale-set 0)))
;; 
  (define-key my/leader-map (kbd "-") '(lambda () (interactive) (text-scale-decrease 1)))
  (define-key my/leader-map (kbd "=") '(lambda () (interactive) (text-scale-increase 1)))
#+END_SRC

** Toggle mono-font
#+BEGIN_SRC emacs-lisp
  ;;(font-get "opensans" :spacing)
  (defun my/toggle-mono-font()
    (interactive)
    (if window-system
      (if (not my/is-font-mono)
          (if  (string= (face-attribute 'default :family) my/font-raw)
              (my/set-default-font my/mono-font)
          (my/set-default-font my/font)))))

  (define-key my/leader-map (kbd "C-f") 'my/toggle-mono-font)
#+END_SRC

*** Toggle local mono font
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-local-mono-font()
    (interactive)
    (if window-system
      (if (not my/is-font-mono)
          (if  (string= (face-attribute 'default :family) my/font-raw)
              (face-remap-add-relative 'default :family my/mono-font)
          (face-remap-add-relative 'default :family my/font-raw)))))

  (define-key my/leader-map (kbd "M-f") 'my/toggle-local-mono-font)
#+END_SRC

** Exit emacs
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-z") 'save-buffers-kill-emacs)
#+END_SRC

** Help mode
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "C-h") help-map)
#+END_SRC

** Prefer loading newest lisp source file
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** Revert buffer bind
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "r") 'revert-buffer)
#+END_SRC

* File options
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/file-options-map)
  (define-key my/leader-map (kbd "`") 'my/file-options-map)
#+END_SRC

** Revert
#+BEGIN_SRC emacs-lisp
  (define-key my/file-options-map (kbd "r") 'revert-buffer)
#+END_SRC

** Statistics
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/statistics-map)
  (define-key my/file-options-map (kbd "s") 'my/statistics-map)

  (define-key my/statistics-map (kbd "w") 'count-words)
  (define-key my/statistics-map (kbd "r") 'count-words-region)
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/indentation-map)
  (define-key my/file-options-map (kbd "i") 'my/indentation-map)

  (defun my/change-tab-width ()
    (interactive)
    (setq-default tab-width (string-to-number (completing-read "Enter tab width" nil))))

  ;; Applies only to region
  (define-key my/indentation-map (kbd "t") 'tabify)
  (define-key my/indentation-map (kbd "SPC") 'untabify)

  (define-key my/indentation-map (kbd "w") 'my/change-tab-width)
#+END_SRC

* Browser
** Eww
#+BEGIN_SRC emacs-lisp
  (require 'eww)
  (require 'shr)
  (defun my/eww-browse-url (URL &optional NEW-WINDOW)
    (interactive)
    (eww-browse-url URL NEW-WINDOW)
    (my/give-buffer-unique-name "eww"))
#+END_SRC

*** Highlight code
#+BEGIN_SRC emacs-lisp
  (defface my/eww-code-face
    '((t
       :family my/mono-font
       ))
    "Eww code face"
    :group 'eww-mode)

  (defun my/eww-tag-code (dom)
    (let ((start (point))
          (text (dom-text dom)))
      (insert text)
      (message text)
      (add-face-text-property start (point) 'my/eww-code-face)
      (insert " ")))
  (setq shr-external-rendering-functions '((code . my/eww-tag-code)))

  (defun my/eww-toggle-code-highlighting ()
    (interactive)
    (if (member '(code . my/eww-tag-code) shr-external-rendering-functions)
        (setq shr-external-rendering-functions (remove '(code . my/eww-tag-code) shr-external-rendering-functions))
      (add-to-list 'shr-external-rendering-functions '(code . my/eww-tag-code))))
#+END_SRC

*** Fix background colors shr
#+BEGIN_SRC emacs-lisp
  (setq shr-color-visible-luminance-min 80)
  (setq shr-color-visible-distance-min 5)

  ;; Fully disables colors
  ;;(advice-add #'shr-colorize-region :around (defun shr-no-colourise-region (&rest ignore)))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; (define-key eww-mode-map [?\d] 'eww-back-url)
  ;; (evil-define-key 'normal eww-mode-map [?\d] 'eww-back-url)
  ;; (evil-define-key 'visual eww-mode-map [?\d] 'eww-back-url)

  (evil-define-key 'normal eww-mode-map (kbd "H") 'eww-back-url)
  (evil-define-key 'normal eww-mode-map (kbd "L") 'eww-forward-url)

  (define-prefix-command 'my/eww-mode-map)
  (evil-define-key 'normal eww-mode-map (kbd (concat my/leader-map-key " a")) 'my/eww-mode-map)

  (define-key my/eww-mode-map (kbd "d") 'eww-download)
  (define-key my/eww-mode-map (kbd "h") 'eww-history-browse)
  (define-key my/eww-mode-map (kbd "o") 'eww-open-in-new-buffer)
  (define-key my/eww-mode-map (kbd "r") 'eww-reload)
  (define-key my/eww-mode-map (kbd "f") 'eww-open-file)
  (define-key my/eww-mode-map (kbd "C-c") 'my/eww-toggle-code-highlighting)
#+END_SRC

** Set default browser
#+BEGIN_SRC emacs-lisp
  (setq-default browse-url-browser-function 'my/eww-browse-url)
#+END_SRC

* Visit file hotkeys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/open-map)
  (define-key my/leader-map (kbd "o") 'my/open-map)

  (defvar my/open-map-hook nil
    "Hook called after a buffer is visited through my/open-map")
#+END_SRC

** Scratch
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-scratch()
    (interactive)
    (switch-to-buffer "*scratch*")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "s") 'my/switch-to-scratch)
#+END_SRC

** Backup
#+BEGIN_SRC emacs-lisp
  (defun my/backups-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "backups")))
    (run-hooks 'my/open-map-hook))

  (defun my/backups-per-session-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "backups/per-session")))
    (run-hooks 'my/open-map-hook))


  (define-key my/open-map (kbd "b") 'my/backups-per-session-visit)
  (define-key my/open-map (kbd "B") 'my/backups-visit)
#+END_SRC

** Visit config
#+BEGIN_SRC emacs-lisp
  (defun my/config-visit ()
    (interactive)
    (find-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
    (define-key my/open-map (kbd "c") 'my/config-visit)
#+END_SRC
  
** Reload config
#+BEGIN_SRC emacs-lisp
  (defun my/config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name (concat user-emacs-directory "config.org")))
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "C-r") 'my/config-reload)

#+END_SRC

** Open trash
#+BEGIN_SRC emacs-lisp
  (defun my/trash-visit ()
    (interactive)
    (find-file "~/.local/share/Trash/files/")
    (run-hooks 'my/open-map-hook))
      (define-key my/open-map (kbd "t") 'my/trash-visit)

#+END_SRC

** Open agenda
#+BEGIN_SRC emacs-lisp
  (defun my/org-agenda-show-agenda-and-todo (&optional arg)
    (interactive "P")
    (org-agenda arg "a")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "a") 'my/org-agenda-show-agenda-and-todo)
#+END_SRC

** Open downloads
#+BEGIN_SRC emacs-lisp
  (defun my/open-downloads ()
    (interactive)
    (find-file "~/Downloads")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "d") 'my/open-downloads)
#+END_SRC

** Open password file
#+BEGIN_SRC emacs-lisp
  (defun my/open-passwords ()
    (interactive)
    (find-file espy-password-file)
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "p") 'my/open-passwords)
#+END_SRC

** Open activity reports
#+BEGIN_SRC emacs-lisp
  (defun my/open-activity-reports ()
    (interactive)
    (find-file (concat user-emacs-directory "ActivityReports.org"))
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "r") 'my/open-activity-reports)
#+END_SRC

** Visit agenda file
#+BEGIN_SRC emacs-lisp
  (defun my/agenda-file-visit ()
    (interactive)
    (find-file "~/Notes/Agenda.org")
    (run-hooks 'my/open-map-hook))

  (define-key my/open-map (kbd "A") 'my/agenda-file-visit)
#+END_SRC

** Open firefox
#+BEGIN_SRC emacs-lisp
  (defvar my/gui-browser
    (if (my/is-system-package-installed 'icecat)
        "icecat"
      (if (my/is-system-package-installed 'iceweasel)
          "iceweasel"
        "firefox")))

  (defvar my/temp-firefox-title-name "")
  (defvar my/browser-bookmarks '(
                                 "youtube.com"
                                 "discordapp.com/channels/@me"
                                 "github.com"
                                 "steamcommunity.com/chat"
                                 ))
  (defun my/launch-firefox ()
    (interactive)
    (let* (
           (adress-raw (completing-read "url " my/browser-bookmarks))
           (adress (if (cl-member adress-raw my/browser-bookmarks :test #'string=)
                       (progn
                         (setq my/temp-firefox-title-name adress-raw)
                         adress-raw)
                     (setq my/temp-firefox-title-name (completing-read "set title " '(
                                                                                      ("dev")
                                                                                      ("docs"))))
                     (concat "https://www.google.com/search?q=" adress-raw))))

      (start-process (concat my/gui-browser my/temp-firefox-title-name) nil my/gui-browser "--new-window" adress)
      (run-with-timer 0.5 nil
                      (lambda () (interactive)
                        (exwm-workspace-rename-buffer (concat my/temp-firefox-title-name " - firefox"))))))

  (define-key my/leader-map (kbd "C-b") 'my/launch-firefox)
#+END_SRC
** Open eww
#+BEGIN_SRC emacs-lisp
  (defun my/launch-eww ()
    (interactive)
    (my/eww-browse-url (concat "https://www.google.com/search?q=" (completing-read "search " nil))))

  (define-key my/leader-map (kbd "b") 'my/launch-eww)
#+END_SRC

* Folding
** Narrowing
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/narrow-map)
  (define-key my/leader-map (kbd "n") 'my/narrow-map)

  (define-key my/narrow-map (kbd "w") 'widen)
  (define-key my/narrow-map (kbd "r") 'narrow-to-region)

  (define-key my/narrow-map (kbd "p") 'narrow-to-page)
  (define-key my/narrow-map (kbd "d") 'narrow-to-defun)
#+END_SRC

** Origami
#+BEGIN_SRC emacs-lisp
   ;;(use-package origami)
;; 
   ;;(global-origami-mode)
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
;;  (setq origami-fold-replacement my/fold-ellipsis)
#+END_SRC

*** Keys
Vim bindings to change fold
#+BEGIN_SRC emacs-lisp
  ;; (define-key evil-motion-state-map (kbd "z n") 'origami-forward-fold)
  ;; (define-key evil-motion-state-map (kbd "z p") 'origami-previous-fold)
;; 
  ;; (define-key evil-motion-state-map (kbd "z C-o") 'origami-open-all-nodes)
  ;; (define-key evil-motion-state-map (kbd "z C-c") 'origami-close-all-nodes)
#+END_SRC

* Completion
** Ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy)

  (ivy-mode 1)

  ;; Buffer history
;;  (setq ivy-use-virtual-buffers t)
  (setq ivy-use-virtual-buffers nil)

  ;; Allows calling new minibuffer commands while in the minibuffer. So for example C-s M-x works
  (setq enable-recursive-minibuffers t)

  ;; Make user intput selectable
  (setq ivy-use-selectable-prompt t)

  ;;Disable fuzzy search for swiper
  ;;(setq ivy-re-builders-alist
  ;;      '((swiper . ivy--regex-plus)
  ;;       (t      . ivy--regex-fuzzy)))
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
  ;; Height of minibuffer
  ;; (setq ivy-height 10)

  ;; Highlight whole row in minibuffer
  (setq ivy-format-function 'ivy-format-function-line)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-/") 'ivy-resume)

  ;; Enable avy movements in ivy buffer
  (define-key ivy-minibuffer-map (kbd "M-p") 'ivy-avy)
  (define-key ivy-minibuffer-map (kbd "M-n") 'ivy-avy)

  (define-key ivy-minibuffer-map (kbd "<escape>") 'minibuffer-keyboard-quit)

  (define-key ivy-minibuffer-map (kbd "C-u") 'ivy-scroll-down-command)
  (define-key ivy-minibuffer-map (kbd "C-w") 'ivy-scroll-up-command)
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel)

  (counsel-mode 1)

  ;;(setq-default counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
  (setq counsel-grep-base-command "grep -i -E -n -e %s %s")
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-find-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)

  (global-set-key (kbd "M-k") 'counsel-yank-pop)

  (define-key my/help-map (kbd "C-c") 'counsel-colors-emacs)
  (define-key my/help-map (kbd "C") 'counsel-colors-web)

  (define-key my/leader-map (kbd "i") 'counsel-imenu)
  (define-key my/leader-map (kbd "h") 'counsel-outline)
#+END_SRC

** Counsel flycheck
  https://github.com/nathankot/dotemacs/blob/master/init.el
#+BEGIN_SRC emacs-lisp

  (defvar counsel-flycheck-history nil
    "History for `counsel-flycheck'")

  (defun counsel-flycheck ()
    (interactive)
    (if (not (bound-and-true-p flycheck-mode))
        (message "Flycheck mode is not available or enabled")
      (ivy-read "Error: "
                (let ((source-buffer (current-buffer)))
                  (with-current-buffer (or (get-buffer flycheck-error-list-buffer)
                                          (progn
                                            (with-current-buffer
                                                (get-buffer-create flycheck-error-list-buffer)
                                              (flycheck-error-list-mode)
                                              (current-buffer))))
                    (flycheck-error-list-set-source source-buffer)
                    (flycheck-error-list-reset-filter)
                    (revert-buffer t t t)
                    (split-string (buffer-string) "\n" t " *")))
                :action (lambda (s &rest _)
                          (-when-let* ( (error (get-text-property 0 'tabulated-list-id s))
                                        (pos (flycheck-error-pos error)) )
                            (goto-char (flycheck-error-pos error))))
                :history 'counsel-flycheck-history)))


  (define-key my/leader-map (kbd "J") 'counsel-flycheck)
#+END_SRC

** Swiper 
#+BEGIN_SRC emacs-lisp
  (use-package swiper)

  (defun my/use-swiper-or-grep(&optional input case-sensative)
    (interactive)
    (if (and buffer-file-name (not (bound-and-true-p org-src-mode)) (not (string= "gz" (file-name-extension buffer-file-name))))
        (counsel-grep input)
      (swiper input)))

  ;; Checks for if case sensative search
  ;; (if case-sensative
  ;; (setq counsel-grep-base-command "grep -E -n -e %s %s")
  ;; (setq-default counsel-grep-base-command "grep -i -E -n -e %s %s"))

  (global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
  (global-set-key (kbd "C-s") 'my/use-swiper-or-grep)
  (global-set-key (kbd "M-s") 'swiper-all)
  ;;(global-set-key (kbd "M-s") (lambda () (interactive) (my/use-swiper-or-grep nil t)))

  ;;  (setq swiper-use-visual-line t)
#+END_SRC

*** Search for thing-at-point
#+BEGIN_SRC emacs-lisp
  (defun my/swiper-thing-at-point ()
    "jump to word under cursor"
    (interactive)
    (my/use-swiper-or-grep (thing-at-point 'evil-WORD)))

  (define-key evil-normal-state-map (kbd "#") 'my/swiper-thing-at-point)
  (define-key evil-normal-state-map (kbd "*") 'my/swiper-thing-at-point)
  ;;(define-key evil-normal-state-map (kbd "/") 'my/swiper-thing-at-point)
#+END_SRC

** Ivy rich
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich)
  (ivy-rich-mode 1)

  ;;(ivy-set-display-transformer 'ivy-switch-buffer 'ivy-switch-buffer)
  ;;(setq ivy-rich-path-style 'abbrev)
  '(ivy-switch-buffer
  (:columns
   ((ivy-rich-candidate (:width 30))  ; return the candidate itself
    (ivy-rich-switch-buffer-size (:width 7))  ; return the buffer size
    (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
    (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
    (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
    (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
   :predicate
   (lambda (cand) (get-buffer cand)))
  counsel-M-x
  (:columns
   ((counsel-M-x-transformer (:width 40))  ; thr original transfomer
    (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the command
  counsel-describe-function
  (:columns
   ((counsel-describe-function-transformer (:width 40))  ; the original transformer
    (ivy-rich-counsel-function-docstring (:face font-lock-doc-face))))  ; return the docstring of the function
  counsel-describe-variable
  (:columns
   ((counsel-describe-variable-transformer (:width 40))  ; the original transformer
    (ivy-rich-counsel-variable-docstring (:face font-lock-doc-face))))  ; return the docstring of the variable
  counsel-recentf
  (:columns
   ((ivy-rich-candidate (:width 0.8)) ; return the candidate itself
    (ivy-rich-file-last-modified-time (:face font-lock-comment-face))))) ; return the last modified time of the file
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
  (use-package company)

  (setq company-idle-delay 0)
  (setq company-echo-delay 0)

  ;; Don't downcase result
  (setq company-dabbbrev-downcase nil)

  ;; Make tooltim margin minimal
  (setq company-tooltip-margin 2)

  ;; Start searching for candidates when 2 letters has been written
  (setq company-minimum-prefix-length 2)

  (add-to-list 'company-transformers 'company-sort-prefer-same-case-prefix)

  (setq company-show-numbers t)

  ;; Make sure only 10 candidates are shown at a time
  (setq company-tooltip-limit 10)

  ;; Align annotations to right side
  (setq company-tooltip-align-annotations t)

  ;; Makes it possible to exit company without a candidate selected
  (setq company-require-match nil)

  ;; Enable scrollbar
  (setq company-tooltip-offset-display 'scrollbar) ;;'line

  (global-company-mode t)

  ;; Remove dabbrev because evil has a better alternative and dabbrev is slow with long files
  (setq company-backends (delete 'company-dabbrev company-backends))
#+END_SRC

*** Company doc buffer
Company doc mode disables visual line mode for whatever reason, enable it inside this redefinition of company-show-doc-buffer
#+BEGIN_SRC emacs-lisp
  (defun my/company-show-doc-buffer ()
    "Temporarily show the documentation buffer for the selection."
    (interactive)
    (let (other-window-scroll-buffer)
      (company--electric-do
        (let* ((selected (nth company-selection company-candidates))
               (doc-buffer (or (company-call-backend 'doc-buffer selected)
                               (user-error "No documentation available")))
               start)
          (with-current-buffer doc-buffer
            (setq truncate-lines nil))
          (when (consp doc-buffer)
            (setq start (cdr doc-buffer)
                  doc-buffer (car doc-buffer)))
          (setq other-window-scroll-buffer (get-buffer doc-buffer))
          (let ((win (display-buffer doc-buffer t)))
            (set-window-start win (if start start (point-min))))))))

  (define-key company-active-map (kbd "C-h") 'my/company-show-doc-buffer)

  (defun my/company-show-doc-buffer-keep-open ()
    "Temporarily show the documentation buffer for the selection."
    (interactive)
    (let (other-window-scroll-buffer)
      (let* ((selected (nth company-selection company-candidates))
             (doc-buffer (or (company-call-backend 'doc-buffer selected)
                             (user-error "No documentation available")))
             start)
        (with-current-buffer doc-buffer
          (setq truncate-lines nil))
        (when (consp doc-buffer)
          (setq start (cdr doc-buffer)
                doc-buffer (car doc-buffer)))
        (setq other-window-scroll-buffer (get-buffer doc-buffer))
        (let ((win (display-buffer doc-buffer t)))
          (set-window-start win (if start start (point-min)))))))

  (define-key company-active-map (kbd "M-h") 'my/company-show-doc-buffer-keep-open)
#+END_SRC

*** Company-show-numbers but with letters
Need to implement
Letters, etc for autocomplete
line 2769, might also need to change more lines due to "company show numbers" being at a few more places
#+BEGIN_SRC emacs-lisp
;;  (setq right (concat (format " %s" (nth numbered '(a s d f g h j k l i r))) right)))

#+END_SRC

**** Find function that gets hotkey
name "company-complete-number"

*** Disable quickhelp for good
fsharp mode auto-enables quickhelp by default, disable it
#+BEGIN_SRC emacs-lisp
  (setq company-quickhelp-delay nil)
#+END_SRC

*** Visuals
Make company mode inherit colors from theme, change later maybe
#+BEGIN_SRC emacs-lisp
  (require 'color)

  ;; Compatibility with 16 color terminals
  (if (not (string= (face-attribute 'default :background) "unspecified-bg"))
      (let* ((my/background-color (face-attribute 'default :background)))
        (set-face-attribute 'company-scrollbar-bg nil :background (color-lighten-name my/background-color 10))
        (set-face-attribute 'company-scrollbar-fg nil :background (color-lighten-name my/background-color 5))

        ;; Selected entry
        (set-face-attribute 'company-tooltip-selection nil :background (face-attribute 'font-lock-function-name-face :background) :foreground  (face-attribute 'font-lock-function-name-face :foreground))
        ;; All unmatching text
        (set-face-attribute 'company-tooltip nil :foreground (face-attribute 'default :foreground) :background (color-lighten-name my/background-color 10))
        ;; All matching text
        (set-face-attribute 'company-tooltip-common nil :foreground (face-attribute 'font-lock-constant-face :foreground) :background (face-attribute 'font-lock-constant-face :background)))
    (set-face-attribute 'company-scrollbar-bg nil :background "black")
    (set-face-attribute 'company-scrollbar-fg nil :background "white")

    ;; Selected entry
    (set-face-attribute 'company-tooltip-selection nil :background "black" :foreground "red")
    ;; All unmatching text
    (set-face-attribute 'company-tooltip nil :foreground "white" :background "black")
    ;; All matching text
    (set-face-attribute 'company-tooltip-common nil :foreground "orange" :background "black"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)

  (define-key company-active-map (kbd "C-u") 'company-previous-page)
  (define-key company-active-map (kbd "C-w") 'company-next-page)

  ;; using C-h is better in every way 
  (define-key company-active-map (kbd "<f1>") 'nil)


  ;; Show full doc buffer
  (define-key evil-normal-state-map  (kbd "C-,") 'my/company-show-doc-buffer)
  (define-key evil-insert-state-map  (kbd "C-,") 'my/company-show-doc-buffer)

  ;; Force autocomplete
  (define-key evil-normal-state-map  (kbd "C-.") 'company-complete)
  (define-key evil-insert-state-map  (kbd "C-.") 'company-complete)
#+END_SRC

*** Disable persistent binds
#+BEGIN_SRC emacs-lisp
  (add-hook 'company-mode-map 'my/keys-mode-turn-off)
#+END_SRC

** Company-box
Company with icons
Doesn't work with my setup right now
#+BEGIN_SRC emacs-lisp
;;(when window-system
;;  (use-package company-box)
;;
;;  (add-hook 'company-mode-hook 'company-box-mode)
;;
;;  ;;(setq company-box-minimum-width 100)
;;  ;;(setq company-box--height 500)
;;  ;;(setq company-tooltip-minimum 10)
;;
;;  (remove-hook 'company-box-selection-hook 'company-box-doc)
;;  (remove-hook 'company-box-hide-hook 'company-box-doc--hide))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)

  ;; Use new buffer if message is longer than 1 line, can't get it to expand the minibuffer instead
  (setq max-mini-window-height 1)

  ;; Decrease delay
  (setq flycheck-display-errors-delay 0.1)

  (global-flycheck-mode)
#+END_SRC

** Flycheck-package
Flycheck with extra correction for elisp packages
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-package)

  (eval-after-load 'flycheck
    '(flycheck-package-setup))
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key)

  (which-key-mode)

  (setq which-key-idle-delay 1)

  (if window-system
    (set-face-attribute 'which-key-command-description-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-docstring-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-group-description-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-highlighted-command-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-key-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-local-map-description-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-note-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-separator-face nil
                        :family my/mono-font)

    (set-face-attribute 'which-key-special-key-face nil
                        :family my/mono-font))
#+END_SRC

*** Bind
#+BEGIN_SRC emacs-lisp
  (define-key my/help-map (kbd "m") 'which-key-show-major-mode)
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet)

  (use-package yasnippet-snippets)

  ;;(yas-reload-all)

  (add-hook 'prog-mode-hook 'yas-minor-mode-on)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "S") 'yas-insert-snippet)

  (define-key my/help-map (kbd "y") 'yas-describe-tables)
#+END_SRC

* Movement
** Marks
#+BEGIN_SRC emacs-lisp
  (setq mark-ring-max 100)

  (defvar my/current-mark 0)
  (defvar my/current-mark-reference nil)

  (defun my/reset-current-marks-if-mark-ring-change ()
    (if (and my/current-mark-reference (ignore-errors (= my/current-mark-reference (car mark-ring))))
        nil
      ;; Reset all mark counters
      (setq my/current-mark-reference (car mark-ring))
      (setq my/current-mark 0)
      ;;(push-mark)
      t))

  (defun my/mark-move (jump-distance)
    "Moves between marks"
    (interactive)
    (or mark-ring
        (error "No mark set"))
    (or (my/reset-current-marks-if-mark-ring-change)
        (setq my/current-mark
              (if (and (>= (+ my/current-mark jump-distance) 0) (< (+ my/current-mark jump-distance) (length mark-ring)))
                  (+ my/current-mark jump-distance)
                my/current-mark)))
    (let* ((marker (nth my/current-mark mark-ring))
           (position (marker-position marker)))
      ;; (if (and (= my/current-mark 1) (not (= position (point))))
      ;; (progn (push-mark)
      ;; (setq my/current-mark-reference (car mark-ring))))
      (message (concat "At mark: " (number-to-string my/current-mark)))
      (or (and (>= position (point-min))
               (<= position (point-max)))
          (if widen-automatically
              (widen)
            (error "Global mark position is outside accessible part of buffer")))
      (goto-char position)))

  (define-key evil-normal-state-map (kbd "C-b") '(lambda () (interactive) (my/mark-move 1)))
  (define-key evil-normal-state-map (kbd "C-f") '(lambda () (interactive) (my/mark-move -1)))

  (define-key my/keys-mode-map (kbd "M-h") 'previous-buffer)
  (define-key my/keys-mode-map (kbd "M-l") 'next-buffer)
#+END_SRC

** Relative line numbers
#+BEGIN_SRC emacs-lisp
  (when (version<= "26.0.50" emacs-version )
    (global-display-line-numbers-mode)

    (setq display-line-numbers-type 'relative)
    (setq-default display-line-numbers-type 'relative)
    (setq display-line-numbers-current-absolute nil)
    (setq-default display-line-numbers-current-absolute nil)

    ;; Fixes org headings not 
    (add-hook 'org-mode-hook (lambda ()(interactive) (setq-local display-line-numbers-type 'visual)))

    (if window-system
        (progn
          (set-face-attribute 'line-number-current-line nil :family my/mono-font)
          (set-face-attribute 'line-number nil :family my/mono-font))))
#+END_SRC

** Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy)

  (setq avy-keys '(
                   ;; Easy
                   ?a ?n ?e ?t ?o ?s ?h ?d ?i ?r
                   ;; Med
                   ?g ?m ?l ?w ?y ?f ?u ?b ?x ?c ?v ?k ?p ?, ?.
                   ;; Hard
                   ?q ?\; ?j ?\/ ?z

                   ;; Shifted

                   ;; Easy
                   ?A ?N ?E ?T ?O ?S ?H ?D
                   ;; Med
                   ?R ?I ?G ?M ?L ?W ?Y ?F ?U ?B ?X ?C ?V ?K ?P
                   ;; Hard
                   ?Q ?\: ?J ?\? ?Z

                   ;; Digits
                   ?7 ?4 ?8 ?3 ?9 ?2 ?0 ?1
                   ))

  ;; Disable highlighting when avy is used. Doesn't work on 16 color terminals
  (if window-system (setq avy-background t))
#+END_SRC

*** Avy-goto-line
**** Above
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-above-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-above 2 t)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

**** Below
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-line-below-keep-horizontal-position (&optional arg)
    (interactive "p")
    (setq cursor-horizontal-pos (current-column))

    ;; Fixes problem with goto-line and visual line mode
    (if (eq evil-state 'visual) 
        (if (eq (evil-visual-type) 'line)
            (progn
              (setq was-visual-line t)
              (evil-visual-char)))
      (progn
        (setq was-visual-line nil)
        (my/evil-normal-state arg)))

    (avy-goto-line-below 2)

    (if (eq was-visual-line t)
        (evil-visual-line))

    (move-to-column cursor-horizontal-pos))
#+END_SRC

*** Avy-goto-word
#+BEGIN_SRC emacs-lisp
  (defun my/avy-goto-word-0-in-line(&optional arg)
    (interactive "p")

    (if (not (eq evil-state 'visual))
        (my/evil-normal-state arg))

    (avy-goto-subword-0 t nil (line-beginning-position) (line-end-position)))
#+END_SRC

** Avy flycheck
#+BEGIN_SRC emacs-lisp
  (use-package avy-flycheck
    :defer t)

  (define-key my/leader-map (kbd "j") 'avy-flycheck-goto-error)
#+END_SRC

** Link-hint
#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :defer t)
#+END_SRC

** Scroll
#+BEGIN_SRC emacs-lisp
  ;;(require 'view)

  (evil-define-key 'normal my/keys-mode-map (kbd "C-u") 'evil-scroll-up)
  (evil-define-key 'normal my/keys-mode-map (kbd "C-w") 'evil-scroll-down)
  ;;(evil-define-key 'normal my/keys-mode-map (kbd "C-u") 'View-scroll-half-page-backward)
  ;;(evil-define-key 'normal my/keys-mode-map (kbd "C-w") 'View-scroll-half-page-forward)

  (evil-define-key 'visual my/keys-mode-map (kbd "C-u") 'evil-scroll-up)
  (evil-define-key 'visual my/keys-mode-map (kbd "C-w") 'evil-scroll-down)

  (evil-define-key 'insert my/keys-mode-map (kbd "C-u") 'evil-scroll-up)
  (evil-define-key 'insert my/keys-mode-map (kbd "C-w") 'evil-scroll-down)

  ;;(evil-define-key 'insert my/keys-mode-map (kbd "C-u") '(lambda () (interactive) (evil-normal-state) (View-scroll-half-page-backward)))
  ;;(evil-define-key 'insert my/keys-mode-map (kbd "C-w") '(lambda () (interactive) (evil-normal-state) (View-scroll-half-page-forward)))
#+END_SRC
*** On-screen
#+BEGIN_SRC emacs-lisp
  ;; (use-package on-screen)
  ;; (on-screen-global-mode)
  ;; (setq on-screen-highlight-method 'fringe)
#+END_SRC

** Jammer
#+BEGIN_SRC emacs-lisp
  ;; (use-package jammer)
;; 
  ;; (setq jammer-repeat-delay 0.5)
  ;; (setq jammer-repeat-window 1)
;; 
  ;; (setq jammer-type 'repeat)
  ;; (setq jammer-block-type 'blacklist)
  ;; (setq jammer-block-list '(
                            ;; ;; Backward/forward
                            ;; evil-backward-char evil-forward-char evil-previous-line evil-next-line previous-line next-line
                            ;; ;; Dired
                            ;; dired-next-line dired-previous-line
;; 
;; 
;; 
                            ;; ;; word movements
                            ;; evil-forward-word evil-forward-word-begin evil-forward-word-end evil-backward-word-begin
;; 
                            ;; ;; WORD movements
                            ;; evil-forward-WORD evil-forward-WORD-begin evil-forward-WORD-end evil-backward-WORD-begin
;; 
                            ;; evil-backward-word-begin evil-backward-word-end))
  ;; (jammer-mode)
#+END_SRC

** goto change
g-; and g-,
#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :defer t)
#+END_SRC

** My find file
#+BEGIN_SRC emacs-lisp
  (defun my/find-file ()
    (interactive)
    (find-file (let ((dir (ignore-errors (dired-current-directory))))
                 (if dir 
                     (read-file-name "Find file: " dir)
                   (read-file-name "Find file: " default-directory)))))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "f") 'avy-goto-char-in-line)
  (define-key my/leader-map (kbd "w") 'my/avy-goto-word-0-in-line)
  (define-key my/leader-map (kbd "g") 'avy-goto-char-2)

  ;; (define-key my/leader-map (kbd "n") 'my/avy-goto-line-below-keep-horizontal-position)
  ;; (define-key my/leader-map (kbd "p") 'my/avy-goto-line-above-keep-horizontal-position)

  ;;(define-key my/keys-mode-map (kbd "M-l") 'link-hint-open-link)
  (define-key my/leader-map (kbd "l") 'link-hint-open-link)
  ;;(define-key my/keys-mode-map (kbd "M-???") 'link-hint-copy-link)
#+END_SRC

* Bookmark management 
#+BEGIN_SRC emacs-lisp
  (defun my/select-bookmark (message)
    (ivy-read message (bookmark-all-names)))

  (defun my/add-bookmark ()
    (interactive)
    (bookmark-set (my/select-bookmark "Add bookmark ")))

  (defun my/delete-bookmark ()
    (interactive)
    (bookmark-delete (my/select-bookmark "Delete bookmark ")))

  ;; doesn't work
  ;; (defun my/load-bookmark-file ()
  ;; (interactive)
  ;; (bookmark-load (ivy-read "load bookmark file " nil)))
#+END_SRC

* Window management
#+BEGIN_SRC emacs-lisp
  (defvar my/window-config-name-changed-hook nil
    "Hook called after user has loaded a window configuration")

  (defvar my/window-configurations nil)
  (defvar my/current-window-configuration "None")

  (defun my/get-window-config-names ()
    (mapcar #'car my/window-configurations))

  (defun my/select-window-config (message)
    (ivy-read message (my/get-window-config-names)))

  (defun my/get-selected-window-config-position (selected-config)
    (cl-position selected-config (my/get-window-config-names) :test 'string=))

  (defun my/update-current-window-config ()
    (setq my/current-window-configuration my/selected-window-config)
    (run-hooks 'my/window-config-name-changed-hook))

  (defun my/add-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Add window config "))

    (setq my/selected-window-config-position (my/get-selected-window-config-position my/selected-window-config))

    (if (eq my/selected-window-config-position nil)
        (push (list my/selected-window-config (current-window-configuration)) my/window-configurations)
      (setf (nth my/selected-window-config-position my/window-configurations) (list my/selected-window-config (current-window-configuration))))

    (my/update-current-window-config))

  (defun my/load-window-config ()
    (interactive)
    (setq my/selected-window-config (my/select-window-config "Load window config "))
    (set-window-configuration (nth 1 (nth (my/get-selected-window-config-position my/selected-window-config) my/window-configurations)))

    (my/update-current-window-config))

  (defun my/delete-window-config ()
    (interactive)
    (setq my/window-configurations (delete (nth (my/get-selected-window-config-position (my/select-window-config "Delete window config ")) my/window-configurations) my/window-configurations)))
#+END_SRC

** Switch to minibuffer
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-minibuffer ()
    "Switch to minibuffer window."
    (interactive)
    (if (active-minibuffer-window)
        (select-window (active-minibuffer-window))
      (error "Minibuffer is not active")))

  (define-key my/keys-mode-map (kbd "M-TAB") 'my/switch-to-minibuffer)
#+END_SRC

* Window and buffer settings
** Delete other windows
#+BEGIN_SRC emacs-lisp
  (defun my/delete-other-windows()
    (interactive)
    (delete-other-windows)
    (my/lv-line-create)
    (run-hooks 'my/switch-buffer-hook))
#+END_SRC

** Switch window hook
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Switch buffer hook
#+BEGIN_SRC emacs-lisp
  (defvar my/switch-buffer-hook nil
    "Hook called after user has switched buffer")
  (add-hook 'window-configuration-change-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))
  (add-hook 'minibuffer-exit-hook (lambda () (interactive) (run-with-timer 0.1 nil (lambda () (interactive) (run-hooks 'my/switch-buffer-hook)))))
  (add-hook 'my/switch-window-hook (lambda () (interactive) (run-hooks 'my/switch-buffer-hook) t))

  (defadvice evil-window-up (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-down (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-left (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
  (defadvice evil-window-right (after evil-window-up-after activate) (run-hooks 'my/switch-buffer-hook))
#+END_SRC

** Window settings 
*** Make cursor auto move to new split window
#+BEGIN_SRC emacs-lisp
  (defun my/split-and-follow-horozontally ()
    (interactive)
    (split-window-below)
    ;;(balance-windows)
    (other-window 1))

  (defun my/split-and-follow-vertically()
    (interactive)
    (split-window-right)
    ;;(balance-windows)
    (other-window 1))
#+END_SRC

*** Don't ask for confirmation when killing window
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC


*** Kill all buffers
#+BEGIN_SRC emacs-lisp
  (defun my/kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'my/kill-all-buffers)
#+END_SRC

*** Unique names for identical buffer names
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'nil)
;;(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
#+END_SRC

* Dired
#+BEGIN_SRC emacs-lisp
  (require 'dired)

  (defun my/dired-mode ()
    (rainbow-delimiters-mode-disable)
    (dired-hide-details-mode))

  (add-hook 'dired-mode-hook 'my/dired-mode)
#+END_SRC

** Use only one dired buffer
Fix this later
#+BEGIN_SRC emacs-lisp

  ;; (defun my/find-file-dired-same-buffer ()
  ;; (interactive)
  ;; (my/insert-subdir-or-open-file (read-file-name "Find file: ")))
  ;; 
  ;; (defun my/insert-subdir-or-open-file (&optional file switches no-error-if-not-dir-p)
  ;; (interactive)
  ;; (let* ((file-name (or file (dired-get-filename))))
  ;; (if (file-directory-p file-name)
  ;; (if (get-buffer "dired")
  ;; (progn
  ;; (switch-to-buffer "dired")
  ;; (dired-maybe-insert-subdir file-name switches no-error-if-not-dir-p))
  ;; (dired "/")
  ;; (dired-maybe-insert-subdir file-name switches no-error-if-not-dir-p)
  ;; (my/give-buffer-unique-name "dired"))
  ;; (find-file file-name))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;; (defun my/find-file ()
    ;; (let ((file (ignore-errors (dired-current-directory))))
      ;; (if file
          ;; (find-file file)
    
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my/find-file-dired-same-buffer ()
    (interactive)
    (my/insert-subdir-or-open-file (read-file-name "Find file: ")))

  (defun my/insert-subdir-or-open-file (&optional file switches no-error-if-not-dir-p)
    (interactive)
    (let* ((file-name (or file (dired-get-filename))))
      (if (file-directory-p file-name)
          (dired-maybe-insert-subdir file-name switches no-error-if-not-dir-p)
        (find-file file-name))))
#+END_SRC

** Human readable file sizes
Make file sizes human readable
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
#+END_SRC

** Put deleted files into trash folder
#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Dired async
*** Better async confirmation messages
#+BEGIN_SRC emacs-lisp
  (setq dired-async-message-function
        (lambda (text face &rest args)
          (shell-command (format "echo '%s'" (apply #'format text args)))))
#+END_SRC

** Dired atool
#+BEGIN_SRC emacs-lisp
  (use-package dired-atool)

  (dired-atool-setup)

  (define-key dired-mode-map "c" 'dired-atool-do-pack)
  (define-key dired-mode-map "Z" 'dired-atool-do-unpack-with-subdirectory)
#+END_SRC

** Wdired
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/wdired-mode-map)
  (evil-define-key 'normal wdired-mode-map (kbd (concat my/leader-map-key " a")) 'my/wdired-mode-map)

  (define-key my/wdired-mode-map (kbd "s") 'wdired-finish-edit)
  (define-key my/wdired-mode-map (kbd "u") 'wdired-abort-changes)
#+END_SRC

** Dired collapse
#+BEGIN_SRC emacs-lisp
  ;; (use-package dired-collapse)
;; 
  ;; (add-hook 'dired-mode-hook 'dired-collapse-mode)
#+END_SRC

** Subtree
#+BEGIN_SRC emacs-lisp
  ;;(use-package dired-subtree)
#+END_SRC

** Sorting
Sort dired dir listing in different ways. Modified to work with ivy
URL `http://ergoemacs.org/emacs/dired_sort.html'
Version 2015-07-30"
#+BEGIN_SRC emacs-lisp
  (defun my/dired-sort-menu ()
    (interactive)
    (let ($sort-by $arg)
      (setq $sort-by (completing-read "Sort by:" '( "date" "size" "name" "dir")))
      (cond
       ((equal $sort-by "name") (setq $arg "-Al --si --time-style long-iso "))
       ((equal $sort-by "date") (setq $arg "-Al --si --time-style long-iso -t"))
       ((equal $sort-by "size") (setq $arg "-Al --si --time-style long-iso -S"))
       ((equal $sort-by "dir") (setq $arg "-Al --si --time-style long-iso --group-directories-first"))
       (t (error "logic error 09535" )))
      (dired-sort-other $arg )))

  (define-key dired-mode-map (kbd "s") 'my/dired-sort-menu)

#+END_SRC

*** Bind
#+BEGIN_SRC emacs-lisp
#+END_SRC

** Recursive folder size
#+BEGIN_SRC emacs-lisp
  (use-package dired-du
    :defer t)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (defun my/toggle-delete-to-trash ()
    (interactive)
    (if (eq delete-by-moving-to-trash nil)
        (progn
          (setq delete-by-moving-to-trash t)
          (message "Delete to trash enabled"))
      (progn
        (setq delete-by-moving-to-trash nil)
        (message "Delete to trash disabled"))))

  (define-prefix-command 'my/dired-mode-map)
  (evil-define-key 'normal dired-mode-map (kbd (concat my/leader-map-key " a")) 'my/dired-mode-map)

  (define-key my/dired-mode-map (kbd "t") 'my/toggle-delete-to-trash)
  (define-key my/dired-mode-map (kbd "w") 'dired-toggle-read-only)
  (defun my/image-dired ()
    (interactive)
    (image-dired default-directory))
  (define-key my/dired-mode-map (kbd "i") 'my/image-dired)
  (define-key my/dired-mode-map (kbd "h") 'dired-hide-details-mode)

  ;; Make dired work good with evil normal mode
  (evil-define-key 'normal dired-mode-map (kbd "i") 'evil-insert)
  ;;(evil-define-key 'normal dired-mode-map (kbd "RET") 'dired-find-file)
  ;;(evil-define-key 'normal dired-mode-map (kbd "RET") 'my/insert-subdir-or-open-file)
  ;;(evil-define-key 'normal dired-mode-map (kbd "RET") 'dired-subtree-insert)
  (evil-define-key 'normal dired-mode-map (kbd "a") 'evil-append)
  (evil-define-key 'normal dired-mode-map (kbd "0") 'evil-digit-argument-or-evil-beginning-of-line)
  (evil-define-key 'normal dired-mode-map (kbd "$") 'evil-end-of-line)
  (evil-define-key 'normal dired-mode-map (kbd "G") 'evil-goto-line)
  (evil-define-key 'normal dired-mode-map (kbd "gg") 'evil-goto-first-line)
  (evil-define-key 'normal dired-mode-map (kbd "y") 'evil-yank)
  (evil-define-key 'normal dired-mode-map (kbd "v") 'evil-visual-char)
  (evil-define-key 'normal dired-mode-map (kbd "V") 'evil-visual-line)
  (evil-define-key 'normal dired-mode-map (kbd "C-v") 'evil-visual-block)

  ;; Bind =Backspace= to go up one directory
  (define-key dired-mode-map [?\d] 'dired-up-directory)
#+END_SRC

* Org
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-mode-map)
  (evil-define-key 'normal org-mode-map (kbd (concat my/leader-map-key " a")) 'my/org-mode-map)

  (use-package org)
#+END_SRC

** Babel
*** Supported runnable languages
  ;; (org-babel-do-load-languages
   ;; 'org-babel-load-languages
   ;; '((R . t)
     ;; (ditaa . t)
     ;; (dot . t)
     ;; (emacs-lisp . t)
     ;; (gnuplot . t)
     ;; (haskell . nil)
     ;; (ocaml . nil)
     ;; (python . t)
     ;; (ruby . t)
     ;; (screen . nil)
     ;; (sh . t)
     ;; (sql . nil)
     ;; (sqlite . t)))

** Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets)
  (when window-system

    (add-hook 'org-mode-hook (lambda () (interactive) (org-bullets-mode))))
#+END_SRC

** Visuals
*** Change face of levels
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'org-level-1 nil :inherit 'outline-1 :height 1.9)
  (set-face-attribute 'org-level-2 nil :inherit 'outline-2 :height 1.6)
  (set-face-attribute 'org-level-3 nil :inherit 'outline-3 :height 1.4)
  (set-face-attribute 'org-level-4 nil :inherit 'outline-4 :height 1.3)
  (set-face-attribute 'org-level-5 nil :inherit 'outline-5 :height 1.25)
  (set-face-attribute 'org-level-6 nil :inherit 'outline-6 :height 1.2)
  (set-face-attribute 'org-level-7 nil :inherit 'outline-7 :height 1.15)
  (set-face-attribute 'org-level-8 nil :inherit 'outline-8 :height 1.10)
#+END_SRC

*** Ellipsis face
#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis my/fold-ellipsis)
#+END_SRC

*** Always truncate lines
#+BEGIN_SRC emacs-lisp
  (setq org-startup-truncated nil)
#+END_SRC

** Indent mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Org SRC
*** Make c-' open in current window
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

*** Don't save window layout
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-src-mode-hook '(lambda () (interactive) (setq org-src--saved-temp-window-config nil)))
#+END_SRC
   
*** SRC region templates
**** Emacs lisp
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

**** R export to image
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("ri" "#+BEGIN_SRC R :results output graphics :file test.png\n?\n#+END_SRC"))
#+END_SRC

** Export
TODO
ox-html5slide
org-html-themes
*** Syntax highlighting for HTML export
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :defer t)
#+END_SRC

*** Twitter bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :defer t)
#+END_SRC

** Agenda
Give agenda file to use
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/Notes/Agenda.org")
      (setq org-agenda-files (quote ("~/Notes/Agenda.org"))))
#+END_SRC
*** Stop agenda from messing with windows
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

*** Display at startup
Spawn agenda buffer
#+BEGIN_SRC emacs-lisp
  (org-agenda-list)
#+END_SRC

**** Declare switch function
Because just giving "*Org Agenda*" to "initial-buffer-choice" doesn't work
#+BEGIN_SRC emacs-lisp
  (defun my/switch-to-agenda()
    (interactive)
    (switch-to-buffer "*Org Agenda*"))
#+END_SRC

**** Run switch function as initial buffer choice
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice 'my/switch-to-agenda)
#+END_SRC

**** Close all other open windows at start
#+BEGIN_SRC emacs-lisp
  (delete-other-windows)
#+END_SRC

** Clock
#+BEGIN_SRC emacs-lisp
;;(setq org-clock-mode-line-total today)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; (define-prefix-command 'my/clock-map)
  ;; (define-key my/leader-map (kbd "c") 'my/clock-map)
;; 
  ;; (define-key my/clock-map (kbd "s") 'org-clock-in)
  ;; (define-key my/clock-map (kbd "S") 'org-clock-out)
  ;; (define-key my/clock-map (kbd "C-s") 'org-clock-in-last)
;; 
  ;; (define-key my/clock-map (kbd "e") 'org-clock-modify-effort-estimate)
#+END_SRC

** Export
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-map)
  (define-key my/org-mode-map (kbd "E") 'my/org-export-map)
#+END_SRC

*** ASCII
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-ascii-map)
  (define-key my/org-export-map (kbd "a") 'my/org-export-ascii-map)

  (define-key my/org-export-ascii-map (kbd "a") 'org-ascii-export-to-ascii)
#+END_SRC

*** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-html-map)
  (define-key my/org-export-map (kbd "h") 'my/org-export-html-map)

  (define-key my/org-export-html-map (kbd "h") 'org-html-export-to-html)
  (define-key my/org-export-html-map (kbd "t") 'org-twbs-export-to-html)
#+END_SRC

*** PDF
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-pdf-map)
  (define-key my/org-export-map (kbd "p") 'my/org-export-pdf-map)

  (define-key my/org-export-pdf-map (kbd "p") 'org-latex-export-to-pdf)
#+END_SRC

*** Beamer presentation
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-slides-map)
  (define-key my/org-export-map (kbd "s") 'my/org-export-slides-map)

  (define-key my/org-export-slides-map (kbd "b") 'org-beamer-export-to-pdf)
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-markdown-map)
  (define-key my/org-export-map (kbd "m") 'my/org-export-markdown-map)

  (define-key my/org-export-markdown-map (kbd "m") 'org-md-export-to-markdown)
#+END_SRC

*** ODT
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-odt-map)
  (define-key my/org-export-map (kbd "o") 'my/org-export-odt-map)

  (define-key my/org-export-odt-map (kbd "o") 'org-odt-export-to-odt)
#+END_SRC

*** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-export-latex-map)
  (define-key my/org-export-map (kbd "l") 'my/org-export-latex-map)

  (define-key my/org-export-latex-map (kbd "l") 'org-latex-export-to-latex)
#+END_SRC

** Key
#+BEGIN_SRC emacs-lisp
  ;;(evil-define-key 'normal org-mode-map (kbd "TAB") 'org-cycle)
  (evil-define-key 'normal org-mode-map (kbd "C-s") 'swiper)

  (define-key my/org-mode-map (kbd "i") 'org-toggle-inline-images)
  (define-key my/org-mode-map (kbd "f") 'org-insert-link)
  (define-key my/org-mode-map (kbd "e") 'org-babel-execute-src-block)

  (define-key my/org-mode-map (kbd "p") 'org-shiftup)
  (define-key my/org-mode-map (kbd "n") 'org-shiftdown)
  (define-key my/org-mode-map (kbd "l") 'org-shiftright)
  (define-key my/org-mode-map (kbd "h") 'org-shiftleft)

  (define-key my/org-mode-map (kbd "P") 'org-metaup)
  (define-key my/org-mode-map (kbd "N") 'org-metadown)
  (define-key my/org-mode-map (kbd "L") 'org-metaright)
  (define-key my/org-mode-map (kbd "H") 'org-metaleft)

  (define-key my/org-mode-map (kbd "|") 'org-table-create-or-convert-from-region)

  (define-key my/org-mode-map (kbd "z") 'org-shifttab)

  (define-prefix-command 'my/org-show-mode-map)
  (define-key my/org-mode-map (kbd "s") 'my/org-show-mode-map)

  (define-key my/org-show-mode-map (kbd "l") 'org-toggle-link-display)
#+END_SRC

*** Macros
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-macros-map)
  (define-key my/org-mode-map (kbd "m") 'my/org-macros-map)
#+END_SRC

**** Org
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-org-macros-map)
  (define-key my/org-macros-map (kbd "o") 'my/org-org-macros-map)

  ;; Center text, doesn't work for all exports
  (define-key my/org-org-macros-map (kbd "c") (lambda () (interactive) (insert "#+BEGIN_CENTER") (newline) (newline) (insert "#+END_CENTER")))

  ;; Comment
  (define-key my/org-org-macros-map (kbd "C") (lambda () (interactive) (insert "#+BEGIN_COMMENT") (newline) (newline) (insert "#+END_COMMENT")))
#+END_SRC

**** Latex
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-latex-macros-map)
  (define-key my/org-macros-map (kbd "l") 'my/org-latex-macros-map)

  ;;Literal latex code for export
  (define-key my/org-latex-macros-map (kbd "i") (lambda () (interactive) (insert "#+LATEX: ")))

  ;; Header
  (define-key my/org-latex-macros-map (kbd "h") (lambda () (interactive) (insert "#+LATEX_HEADER: ")))

  ;; Newline
  (define-key my/org-latex-macros-map (kbd "RET") (lambda () (interactive) (insert "#+LATEX: \\newpage")))

  ;; Fix huge margins
  (define-key my/org-latex-macros-map (kbd "4") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage[a4paper, total={6in, 8in}]{geometry}")))

  ;; Make lists compact
  (define-key my/org-latex-macros-map (kbd "C-l") (lambda () (interactive) (insert "#+LATEX_HEADER: \\usepackage{enumitem}") (newline) (insert "#+LATEX_HEADER: \\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}")))
#+END_SRC

**** HTML
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/org-html-macros-map)
  (define-key my/org-macros-map (kbd "h") 'my/org-html-macros-map)

  ;;Literal HTML code for export
  (define-key my/org-html-macros-map (kbd "i") (lambda () (interactive) (insert "#+HTML: ")))

  ;;HTML break line
  (define-key my/org-html-macros-map (kbd "RET") (lambda () (interactive) (insert "#+HTML: <br><br />")))
#+END_SRC

* Code
** Generic
*** Jump to definition
#+BEGIN_SRC emacs-lisp
  (defun my/jump-to-definition ()
    (interactive
     (if (string= major-mode "fsharp-mode")
         (fsharp-ac/gotodefn-at-point)
       (dumb-jump-go))))

  (define-key my/leader-map (kbd "t") 'my/jump-to-definition)
#+END_SRC

*** Smartparens
#+BEGIN_SRC emacs-lisp
  ;; (use-package smartparens)
;; 
  ;; (smartparens-global-mode)
#+END_SRC
    
*** Eldoc
Shows information in echo area
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (setq eldoc-echo-area-use-multiline-p 't)
  (setq-default eldoc-echo-area-use-multiline-p 't)
  (setq eldoc-idle-delay 0)
#+END_SRC

*** Aggressive indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent)

  (global-aggressive-indent-mode)
  ;;(add-hook 'prog-mode-hook 'aggressive-indent-mode)
#+END_SRC
    
*** Whitespace cleanup
#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode)

  (global-whitespace-cleanup-mode)
#+END_SRC

*** indent guide
#+BEGIN_SRC emacs-lisp
  ;; (use-package highlight-indent-guides)
;; 
  ;; (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
;; 
  ;; ;;(setq highlight-indent-guides-method 'column)
  ;; (setq highlight-indent-guides-method 'fill)
;; 
  ;; (setq highlight-indent-guides-responsive 'top)
  ;; (setq highlight-indent-guides-delay 0)
#+END_SRC

*** Auto eval target
#+BEGIN_SRC emacs-lisp
  (defun my/auto-eval ()
    (interactive)
    (if (not (cond
              ((string= major-mode "scheme-mode") (geiser-eval-last-sexp nil)) 
              ((string= major-mode "clojure-mode") (cider-eval-last-sexp)) 
              ((string= major-mode "fsharp-mode") (fsharp-eval-phrase))))
        (eval-last-sexp nil)))

  (defun my/auto-eval-buffer ()
    (interactive)
    (if (not (cond
              ((string= major-mode "scheme-mode") (geiser-eval-buffer nil)) 
              ((string= major-mode "clojure-mode") (cider-eval-buffer)) 
              ((string= major-mode "fsharp-mode") (fsharp-eval-region (point-min) (point-max)))))
        (eval-buffer nil)))

  (defun my/auto-eval-print ()
    (interactive)
    (if (not (cond
              ((string= major-mode "scheme-mode") (geiser-eval-last-sexp t)) 
              ((string= major-mode "clojure-mode") (cider-eval-print-last-sexp))))
        (eval-print-last-sexp nil)))


  (define-key my/leader-map (kbd "e") 'my/auto-eval)
  (define-key my/leader-map (kbd "E") 'my/auto-eval-buffer)
  (define-key my/leader-map (kbd "M-e") 'my/auto-eval-print)
#+END_SRC

** Documentation
#+BEGIN_SRC emacs-lisp
  ;; (use-package zeal-at-point
    ;; :defer t)

  ;;(define-key my/leader-map (kbd "d") 'zeal-at-point)
#+END_SRC

** LSP mode
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode)
#+END_SRC

*** Company LSP
#+BEGIN_SRC emacs-lisp
  (use-package company-lsp)

  ;; Requested by lsp java
  (setq company-lsp-enable-snippe t)
  (setq company-lsp-cache-candidates t)
  ;;(push 'java-mode company-global-modes)
  (add-hook 'java-mode-hook (lambda () (push 'company-lsp company-backends)))
#+END_SRC

*** LSP-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui)
#+END_SRC

** Common lisp
*** Slime
#+BEGIN_SRC emacs-lisp
  (use-package slime)

  (setq inferior-lisp-program "/usr/bin/sbcl")
  (setq slime-contribs '(slime-fancy))
#+END_SRC

**** Slime comany
#+BEGIN_SRC emacs-lisp
  (use-package slime-company)

  (slime-setup '(slime-fancy slime-company))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/common-lisp-mode-map)
  (evil-define-key 'normal lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/common-lisp-mode-map)

  (define-key my/common-lisp-mode-map (kbd "d") 'slime-inspect-definition)

#+END_SRC

** Scheme
#+BEGIN_SRC emacs-lisp
  (use-package geiser)

  (define-prefix-command 'my/scheme-mode-map)
  (evil-define-key 'normal scheme-mode-map (kbd (concat my/leader-map-key " a")) 'my/scheme-mode-map)

  (define-key my/scheme-mode-map (kbd "s") 'geiser-set-scheme)
  (define-key my/scheme-mode-map (kbd "C-s") 'run-geiser)
#+END_SRC

** Emacs-lisp
*** Enable debugging on error
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
#+END_SRC

*** Suggest
#+BEGIN_SRC emacs-lisp
  (use-package suggest)
#+END_SRC


*** Formatting
#+BEGIN_SRC emacs-lisp
  (use-package elisp-format
    :defer t)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/emacs-lisp-mode-map)
  (evil-define-key 'normal emacs-lisp-mode-map (kbd (concat my/leader-map-key " a")) 'my/emacs-lisp-mode-map)

  (define-key my/emacs-lisp-mode-map (kbd "d") 'find-function)
  (define-key my/emacs-lisp-mode-map (kbd "D") 'find-variable)

  (define-key my/emacs-lisp-mode-map (kbd "c") 'emacs-lisp-byte-compile)

  (define-key my/emacs-lisp-mode-map (kbd "s") 'suggest)

  (define-prefix-command 'my/emacs-lisp-formatting-map)
  (define-key my/emacs-lisp-mode-map (kbd "f") 'my/emacs-lisp-formatting-map)

  (define-key my/emacs-lisp-formatting-map (kbd "b") 'elisp-format-buffer)
  (define-key my/emacs-lisp-formatting-map (kbd "r") 'elisp-format-region)
  (define-key my/emacs-lisp-formatting-map (kbd "f") 'elisp-format-file)
  (define-key my/emacs-lisp-formatting-map (kbd "C-d") 'elisp-format-directory)
  ;; Format marked files in dired
  ;;elisp-format-dired-mark-files
#+END_SRC

** Java
Try
https://github.com/mopemope/meghanada-emacs
or
=ENSIME= 
#+BEGIN_SRC emacs-lisp
  (use-package lsp-java)

  (add-hook 'java-mode-hook 'lsp-java-enable)
  (add-hook 'java-mode-hook (lambda () (lsp-ui-flycheck-enable t)))
  (add-hook 'java-mode-hook 'lsp-ui-sideline-mode)

  ;; set the projects that are going to be imported into the workspace.
  (setq lsp-java--workspace-folders 
        (list 
         "~/eclipse-workspace/"
         "~/workspace"))

  (defun my/java-mode ()
    (aggressive-indent-mode 0)

    ;; TODO right now these are permanently set if you start lsp-java mode
    ;; Taken from lsp-java readme
    (setq lsp-inhibit-message t)
    (setq lsp-eldoc-render-all nil)
    (setq lsp-highlight-symbol-at-point nil)

    (setq lsp-ui-sideline-enable t)
    (setq lsp-ui-sideline-show-symbol t)
    (setq lsp-ui-sideline-show-hover t)
    (setq lsp-ui-sideline-show-code-actions t)
    (setq lsp-ui-sideline-update-mode 'point))

  (add-hook 'java-mode-hook 'my/java-mode)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/java-mode-map)
  (evil-define-key 'normal java-mode-map (kbd (concat my/leader-map-key " a")) 'my/java-mode-map)

  (define-key my/java-mode-map (kbd "r") 'lsp-rename)
  (define-key my/java-mode-map (kbd "C-r") 'lsp-workspace-restart)
  (define-key my/java-mode-map (kbd "f") 'lsp-format-buffer)
  (define-key my/java-mode-map (kbd "i") 'lsp-java-organize-imports)
  (define-key my/java-mode-map (kbd "C-b") 'lsp-java-build-project)

  (define-key my/java-mode-map (kbd "d") 'xref-find-definitions)
  (define-key my/java-mode-map (kbd "f") 'xref-find-references)
  (define-key my/java-mode-map (kbd "a") 'xref-find-apropos)

  (define-prefix-command 'my/java-refractor-map)
  (define-key my/java-mode-map (kbd "R") 'my/java-refractor-map)

  (define-key my/java-refractor-map (kbd "c") 'lsp-java-extract-to-constant)
  (define-key my/java-refractor-map (kbd "u") 'lsp-java-add-unimplemented-methods)
  (define-key my/java-refractor-map (kbd "p") 'lsp-java-create-parameter)
  (define-key my/java-refractor-map (kbd "f") 'lsp-java-create-field)
  (define-key my/java-refractor-map (kbd "l") 'lsp-java-create-local)
  (define-key my/java-refractor-map (kbd "m") 'lsp-java-extract-method)
  (define-key my/java-refractor-map (kbd "i") 'lsp-java-add-import)
#+END_SRC

** Python
*** Jedi
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi)

  (add-to-list 'company-backends 'company-jedi)
#+END_SRC

** C#
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode)
#+END_SRC

*** Omnisharp-emacs
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp)

  (add-hook 'csharp-mode-hook 'omnisharp-mode)
  (add-hook 'csharp-mode-hook (lambda () (push 'company-omnisharp company-backends)))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/csharp-mode-map)
  (evil-define-key 'normal csharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/csharp-mode-map)

  (define-key my/csharp-mode-map (kbd "r") 'omnisharp-run-code-action-refactoring)
  (define-key my/csharp-mode-map (kbd "f") 'omnisharp-code-format-entire-file)
  (define-key my/csharp-mode-map (kbd "R") 'omnisharp-rename-interactively)
  (define-key my/csharp-mode-map (kbd "s") 'omnisharp-reload-solution)
  (define-key my/csharp-mode-map (kbd "d") 'omnisharp-go-to-definition-other-window)
  (define-key my/csharp-mode-map (kbd "u") 'omnisharp-find-usages)
  (define-key my/csharp-mode-map (kbd "i") 'omnisharp-find-implementations)
  (define-key my/csharp-mode-map (kbd "p") 'omnisharp-navigate-to-solution-file)
  (define-key my/csharp-mode-map (kbd "a") 'omnisharp-solution-actions)
  (define-key my/csharp-mode-map (kbd "e") 'omnisharp-solution-errors)
#+END_SRC

**** Write formatting settings to omnisharp server config
omnisharp.json should be in ~/.omnisharp on all OSs
#+BEGIN_SRC emacs-lisp
;; if(not(file-directory-p "~/.omnisharp")
;;     (make-directory "~/.omnisharp"))
;;
;; (if(not(file-exists-p "~/.omnisharp/omnisharp.json"))
;;     (progn
;;       (write-region "
;;         {
;;             \"formattingOptions\": {
;;                 PUT OPTIONS HERE
;;             }
;;         }
;;        " nil "~/.omnisharp/omnisharp.json")
;;
;;       (message "~/.omnisharp/omnisharp.json created")
;;       )
;;   )
#+END_SRC

** F#
#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode
    :defer t
    :mode ("\\.fs\\'" . fsharp-mode))

  (setq fsharp-doc-idle-delay 0)

  ;;(setq-default fsharp-indent-offset 2)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (add-hook 'fsharp-mode-hook 'my/fsharp-keys-init)

  (define-prefix-command 'my/fsharp-mode-map)

  (defun my/fsharp-keys-init()
    (interactive)
    (evil-define-key 'normal fsharp-mode-map (kbd (concat my/leader-map-key " a")) 'my/fsharp-mode-map))

  (define-key my/fsharp-mode-map (kbd "d") 'fsharp-ac/gotodefn-at-point)
  (define-key my/fsharp-mode-map (kbd "v") 'fsharp-mark-phrase)
  (define-key my/fsharp-mode-map (kbd "b") 'fsharp-goto-block-up)
  (define-key my/fsharp-mode-map (kbd "C-r") 'fsharp-ac-status)
  (define-key my/fsharp-mode-map (kbd "C-k") 'fsharp-ac/stop-process)
  (define-key my/fsharp-mode-map (kbd "C-s") 'fsharp-ac/start-process)

#+END_SRC

*** Settings
#+BEGIN_SRC emacs-lisp
  (defun my/fsharp-mode()
    ;; Disable not so helpful modes
    ;; 
    (aggressive-indent-mode 0)
    ;; Fsharp has built in intellisense highlight thing at point
    (highlight-thing-mode -1)
    ;; Visual line mode in fsharp mode is broken, makes swiper take years to start, use truncate lines mode instead
    (visual-line-mode 0)
)

  ;; Autostart
  (add-hook 'fsharp-mode-hook 'my/fsharp-mode)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode)
#+END_SRC

*** Cider
#+BEGIN_SRC emacs-lisp
  (use-package cider)
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/clojure-mode-map)
  (evil-define-key 'normal clojure-mode-map (kbd (concat my/leader-map-key " a")) 'my/clojure-mode-map)

  (define-key my/clojure-mode-map (kbd "C-s") 'cider-jack-in)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

** Web mode
TODO: Fix settings, grab them from package site 
#+BEGIN_SRC emacs-lisp
   (use-package web-mode
    :defer t)

   (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
   ;; Messes with .cs files???
   ;;(add-to-list 'auto-mode-alist '("\\.css?\\'" . web-mode))
   (add-to-list 'auto-mode-alist '("\\.xml?\\'" . web-mode))
#+END_SRC

* Encryption
** GPG  
*** Pinentry
#+BEGIN_SRC emacs-lisp
  (use-package pinentry)

  ;; Takes 0.000273s, autorun
  (add-hook 'exwm-init-hook 'pinentry-start)
#+END_SRC

*** Reset GPG agent
#+BEGIN_SRC emacs-lisp
  (defun my/reset-gpg-agent ()
    (interactive)
    (shell-command "gpgconf --kill gpg-agent")
    (pinentry-stop)
    (pinentry-start))
#+END_SRC
** Passwords
Enable org mode for .org.gpg files
#+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.org.gpg\\'" . org-mode))
#+END_SRC

*** Espy
#+BEGIN_SRC emacs-lisp
  (use-package espy)

  (setq espy-password-file "~/pass.org.gpg")

  (define-prefix-command 'my/password-map)
  (define-key my/leader-map (kbd "p") 'my/password-map)

  (define-key my/password-map (kbd "r") 'my/reset-gpg-agent)
  (define-key my/password-map (kbd "u") 'espy-get-user)
  (define-key my/password-map (kbd "p") 'espy-get-pass)
#+END_SRC

*** Auto-clean kill ring
#+BEGIN_SRC emacs-lisp
  ;;(defvar my/pass-in-killring nil)

  ;; (defun my/ivy-pass ()
  ;; (interactive)
  ;; (setq my/pass-in-killring t)
  ;; (ivy-pass))
  ;; 
  ;; (defun my/pass-pop-killring ()
  ;; (if (eq my/pass-in-killring t)
  ;; (progn
  ;; (progn (pop kill-ring) 
  ;; (message "Password removed"))
  ;; (setq my/pass-in-killring nil))))

  (defun my/pop-killring ()
    (pop kill-ring)
    (setq my/pass-in-killring nil))

  (define-key my/leader-map (kbd "C-k") 'my/pop-killring)
  ;;(advice-add 'evil-goggles--paste-advice :before (lambda () (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-goggles--paste-advice :before 
  ;;(advice-add 'evil-paste-after :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
  ;;(advice-add 'evil-paste-before :after (lambda (&rest r) (interactive) (my/pass-pop-killring)))
#+END_SRC

* Shell
 ;https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org
#+BEGIN_SRC emacs-lisp
  ;; Change to temporary name before renaming
  (setq eshell-buffer-name "eshell")

  (setq eshell-highlight-prompt t)
  (setq eshell-hist-ignoredups t)
  (setq eshell-history-size 1000)

  (setq-default eshell-status-in-mode-line nil)
  (defun my/eshell ()
    (interactive)
    (eshell)
    (my/give-buffer-unique-name "*eshell*"))

  (defun my/eshell-insert-history ()
    (interactive)
    (insert (completing-read "Eshell history: "
                             (delete-dups
                              (ring-elements eshell-history-ring)))))
#+END_SRC

** Term
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "{") 'ansi-term)
#+END_SRC

** Disable minor modes
Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

** Use ansi term for certain applications
#+BEGIN_SRC emacs-lisp
  (require 'em-term)
  (add-to-list 'eshell-visual-commands "vim")
#+END_SRC

** Remove banner
#+BEGIN_SRC emacs-lisp
(setq eshell-banner-message "")
#+END_SRC

** Custom prompt
#+BEGIN_SRC emacs-lisp
(defvar my/eshell-prompt-symbol)
  (if window-system
    (setq my/eshell-prompt-symbol "λ")
   (setq my/eshell-prompt-symbol "$"))

(setq eshell-prompt-function
             (lambda ()
     (concat (abbreviate-file-name (eshell/pwd))
	     (if (= (user-uid) 0) " # " (concat " " my/eshell-prompt-symbol " ")))))
             
        (setq eshell-prompt-regexp
             (concat "^[^#$\n]* [#" my/eshell-prompt-symbol "] "))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/eshell-mode-map)
  (evil-define-key 'normal eshell-mode-map (kbd (concat my/leader-map-key " a")) 'my/eshell-mode-map)

  (define-key my/eshell-mode-map (kbd "k") 'my/eshell-insert-history)

  (define-key my/leader-map (kbd "[") 'my/eshell)
#+END_SRC

* Keys
** Key rebinds
#+BEGIN_SRC emacs-lisp
  (require 'evil-maps)
#+END_SRC

*** General
More rebind options and more reliable
#+BEGIN_SRC emacs-lisp
  (use-package general)

  (general-evil-setup)
#+END_SRC

*** k(Move up) <--> p(Paste)
**** k
#+BEGIN_SRC emacs-lisp
   (define-key evil-normal-state-map "k" 'evil-paste-after)
   (define-key evil-normal-state-map "K" 'evil-paste-before)

  (define-key evil-visual-state-map "k" 'evil-visual-paste)

  ;; Universal paste key
  (global-set-key (kbd "C-k") 'evil-paste-after)
  (global-set-key (kbd "C-K") 'evil-paste-before)
  (define-key evil-insert-state-map (kbd "C-k") 'evil-paste-after)
  (define-key evil-insert-state-map (kbd "C-K") 'evil-paste-before)

  (define-key evil-window-map "k" 'evil-window-mru)
#+END_SRC

**** p
#+BEGIN_SRC emacs-lisp
(define-key evil-window-map "p" 'evil-window-up)
(define-key evil-window-map "P" 'evil-window-move-very-top)

(define-key evil-normal-state-map "p" 'evil-previous-line)
(define-key evil-motion-state-map "p" 'evil-previous-line)

(define-key evil-normal-state-map "P" 'evil-lookup)
(define-key evil-motion-state-map "P" 'evil-lookup)

(define-key evil-window-map (kbd "C-S-p") 'evil-window-move-very-top)

(define-key evil-normal-state-map "gp" 'evil-previous-visual-line)
(define-key evil-motion-state-map "gp" 'evil-previous-visual-line)
#+END_SRC

*** n(Move up) <--> j(search-next)
**** n
#+BEGIN_SRC emacs-lisp
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "N" 'evil-window-move-very-bottom)

  (define-key evil-normal-state-map "n" 'evil-next-line)
  (define-key evil-motion-state-map "n" 'evil-next-line)

  (define-key evil-normal-state-map "N" 'evil-join)


  ;; ex
  ;;  (evil-ex-define-cmd "j[oin]" 'evil-ex-join)
  ;;  (evil-ex-define-cmd "ju[mps]" 'evil-show-jumps)

  (define-key evil-normal-state-map "gN" 'evil-join-whitespace)

  (define-key evil-normal-state-map "gn" 'evil-next-visual-line)
  (define-key evil-motion-state-map "gn" 'evil-next-visual-line)

  (define-key evil-window-map (kbd "C-S-n") 'evil-window-move-very-bottom)
#+END_SRC

**** j 
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map "j" 'evil-search-next)
  (define-key evil-motion-state-map "j" 'evil-search-next)

  (define-key evil-normal-state-map "J" 'evil-search-previous)
  (define-key evil-motion-state-map "J" 'evil-search-previous)

  ;; ex
  ;;(evil-ex-define-cmd "new" 'evil-window-new)
  ;;(evil-ex-define-cmd "norm[al]" 'evil-ex-normal)
  ;;(evil-ex-define-cmd "noh[lsearch]" 'evil-ex-nohighlight)

  (define-key evil-motion-state-map "gj" 'evil-next-match)
  (define-key evil-motion-state-map "gJ" 'evil-previous-match)
#+END_SRC

*** Rebind save key
#+BEGIN_SRC emacs-lisp
  (general-simulate-key "C-x C-s")

  (defun my/save-and-backup-session()
    (interactive)
    (my/force-backup-of-buffer)
    (general-simulate-C-x_C-s))

  (define-key my/leader-map (kbd "s") 'my/save-and-backup-session)
  (define-key my/leader-map (kbd "C-s") 'write-file)
#+END_SRC

*** Rebind C-d
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-d") nil)
  (define-key evil-motion-state-map (kbd "C-d") nil)
#+END_SRC

*** Rebind esc
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "<escape>") (kbd "C-e"))
  (define-key key-translation-map (kbd "C-e") (kbd "<escape>"))
#+END_SRC

*** Rebind enter
#+BEGIN_SRC emacs-lisp
  (define-key key-translation-map (kbd "RET") (kbd "C-a"))
  (define-key key-translation-map (kbd "C-a") (kbd "RET"))
#+END_SRC

*** Rebind tab
Use C-i instead
#+BEGIN_SRC emacs-lisp
  ;;(define-key my/keys-mode-map (kbd "C-e") 'my/simulate-esc)
  ;;(define-key key-translation-map (kbd "?\\t") (kbd "C-="))
  (define-key key-translation-map (kbd "TAB") (kbd "C-="))
  (define-key key-translation-map (kbd "<tab>") (kbd "C-="))
  (define-key key-translation-map (kbd "C-t") (kbd "TAB"))
  (define-key key-translation-map (kbd "M-C-t") (kbd "C-TAB"))
#+END_SRC

*** Rebind backspace
#+BEGIN_SRC emacs-lisp
  ;; (define-key key-translation-map (kbd "C-e") (kbd "TAB"))
  ;; (define-key key-translation-map (kbd "M-C-i") (kbd "C-TAB"))
#+END_SRC

* exwm
#+BEGIN_SRC emacs-lisp
  (use-package exwm)

  (require 'exwm)
  ;; necessary to configure exwm manually
  (require 'exwm-config)

  ;; Fix magit ediff
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; enable exwm
  (exwm-enable)

  (add-hook 'exwm-manage-finish-hook 'my/exwm-mode)
  (defun my/exwm-mode ()
    (interactive)
    (my/keys-mode-turn-off)
    (evil-emacs-state))
#+END_SRC

** Set exwm buffer name 
*** Manually set buffer name
#+BEGIN_SRC emacs-lisp
  (defun my/exwm-set-window-name ()
    (interactive)
    (exwm-workspace-rename-buffer (completing-read "set title " nil)))

  (define-key my/file-options-map (kbd "r") 'my/exwm-set-window-name)
#+END_SRC

*** Auto set buffer name
We use class names for all windows expect for Java applications and GIMP (because of problems with those).
#+BEGIN_SRC emacs-lisp
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                         (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or
                     (not exwm-instance-name)
                     (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                     (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC

** Multi-screen
#+BEGIN_SRC emacs-lisp
  (defvar my/monitor-amount 1)

  (if (file-exists-p (concat user-emacs-directory "randr-home"))
      (progn
        ;; We need 3 frames to fill up monitors
        (setq exwm-workspace-number 3)
        (setq my/monitor-amount 3)
        (setq exwm-randr-workspace-output-plist '(1 "DVI-D-1" 0 "DP-1" 2 "DVI-I-1"))))

  (if (> my/monitor-amount 1)
      (progn
        (require 'exwm-randr)
        (exwm-randr-enable)))
#+END_SRC

*** Switch monitor (workspace) functions
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'focus-out-hook 'exwm-layout--refresh)
  (defun my/switch-monitor-left ()
    (interactive)
    (if (>= exwm-workspace-current-index (- my/monitor-amount 1))
        (exwm-workspace-switch-create 0)
      (exwm-workspace-switch-create (+ exwm-workspace-current-index 1))))

  (defun my/switch-monitor-right ()
    (interactive)
    (if (= exwm-workspace-current-index 0)
        (exwm-workspace-switch-create (- my/monitor-amount 1))
      (exwm-workspace-switch-create (- exwm-workspace-current-index 1))))

  ;;(define-key my/keys-mode-map (kbd "M-l") 'my/switch-monitor-right)
  ;;(define-key my/keys-mode-map (kbd "M-h") 'my/switch-monitor-left)
#+END_SRC

** Setting
#+BEGIN_SRC emacs-lisp
  ;; Garbage collect when entering x window (because x is not in sync with emacs)
  ;;(add-hook 'exwm-mode-hook 'garbage-collect)

  (setq exwm-workspace-show-all-buffers t)

  (setq exwm-workspace-minibuffer-position 'top)

  (add-hook 'exwm-init-hook (lambda () (interactive) (exwm-workspace-attach-minibuffer)))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key evil-emacs-state-map (kbd "TAB") 'nil)
  (global-unset-key (kbd "TAB"))
  ;; Rebind keys in exwm bufffers
  (setq exwm-input-simulation-keys
        '(
          ;; movement
          ([?\C-h] . [left])
          ([?\C-l] . [right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])

          ;; ([?\C-u] . [prior])
          ;; ([?\C-w] . [next])
          ([?\C-w] . [?\C-d])

          ([?\C-s] . [?\C-f])

          ([?\C-a] . [return])
          ([?\r] . [return])

          ;;([?\C-e] . [?\C-[])
          ;; ([?\C-e] . [escape])
          ;; ([?\e] . [escape])

          ([?\C-t] . [tab])
          ([?\t] . [tab])

          ([?\C-g] . [escape])
          ;;([?\e] . [escape])

          ;; Firefox hard-coded open url hotkey
          ([?\C-o] . [f6])

          ;; Redo
          ([?\C-r] . [?\C-y])
          ;; Undo
          ([?\M-u] . [?\C-z])

          ;; cut/paste.
          ([?\C-y] . [?\C-c])
          ([?\C-k] . [?\C-v])))

  (setq exwm-input-prefix-keys nil)
  ;; Exwm don't send back these keys
  (dolist (k '(
               XF86AudioLowerVolume
               XF86AudioRaiseVolume
               XF86PowerOff
               XF86AudioMute
               XF86AudioPlay
               XF86AudioStop
               XF86AudioPrev
               XF86AudioNext
               XF86ScreenSaver
               XF68Back
               XF86Forward
               Scroll_Lock
               print
               ))
    (cl-pushnew k exwm-input-prefix-keys))

  ;; Some keys have to be defined using "exwm-input-set-key" in order to be usable if they are in "exwm-input-prefix-keys"
  (exwm-input-set-key (kbd my/mod-leader-map-key) 'my/leader-map)

  (exwm-input-set-key (kbd "M-<tab>") 'my/switch-to-minibuffer)
  ;;(exwm-input-set-key (kbd "C-M-=") 'my/switch-to-minibuffer)

  ;;(exwm-input-set-key (kbd "C-M-i") 'my/switch-to-minibuffer)

  (exwm-input-set-key (kbd "C-e") 'keyboard-quit)
  (exwm-input-set-key (kbd "<tab>") 'my/window-hydra/body)
  (exwm-input-set-key (kbd "C-=") 'my/window-hydra/body)
  (exwm-input-set-key (kbd "M-x") 'counsel-M-x)

  (exwm-input-set-key (kbd "M-h") 'previous-buffer)
  (exwm-input-set-key (kbd "M-l") 'next-buffer)

  ;; Enter and exit char mode
  ;; (exwm-input-set-key (kbd "M-a") 'exwm-input-grab-keyboard)
  ;; (exwm-input-set-key (kbd "M-i") 'exwm-input-release-keyboard)

  ;; Notes
  ;; (defun my/send-key(event)
  ;; (interactive "e")
  ;; (exwm-input--fake-key event))
  ;; (define-key 'my/leader-map (kbd "C-q") 'my/send-key)
  ;; 
  ;; (exwm-input--fake-key (event-basic-type ?\C-a))
#+END_SRC

* Version control
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile)

  ;; Disable projectile mode so that CPU isn't taken by projectile wating to refresh git project directory all the time
  (projectile-mode 0)
#+END_SRC

** Counsel projectile
If enabled it auto enables projectile, which has high CPU usage
#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :defer t)

  (setq git-commit-summary-max-length 50)
#+END_SRC

** diff-hl
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl)

  (global-diff-hl-mode)

  ;; If there is no fringe (terminal), use margin instead
  (unless (display-graphic-p) (diff-hl-margin-mode))

  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)

  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)

  ;;(diff-hl-flydiff-mode)
#+END_SRC

** Keys 
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'insert magit-mode-map (kbd "a") 'evil-append)

  (define-prefix-command 'my/vc-map)
  (define-key my/leader-map (kbd "v") 'my/vc-map)

  (define-key my/vc-map (kbd "o") 'counsel-git-grep)
  (define-key my/vc-map (kbd "a") 'counsel-projectile-ag)
  (define-key my/vc-map (kbd "d") 'projectile-dired)
  (define-key my/vc-map (kbd "D") 'counsel-projectile-find-dir)
  (define-key my/vc-map (kbd "f") 'counsel-projectile-find-file)

  (define-key my/vc-map (kbd "K") 'projectile-kill-buffers)
  (define-key my/vc-map (kbd "f") 'counsel-projectile-switch-to-buffer)
  (define-key my/vc-map (kbd "F") 'projectile-ibuffer)

  (define-key my/vc-map (kbd "S") 'projectile-save-project-buffers)
  (define-key my/vc-map (kbd "C") 'projectile-compile-project)

  (define-key my/vc-map (kbd "!") 'projectile-run-shell-command-in-root)
  (define-key my/vc-map (kbd "&") 'projectile-run-async-shell-command-in-root)

  (define-key my/vc-map (kbd "s") 'magit-status)
#+END_SRC

* Media
** Volume keys
#+BEGIN_SRC emacs-lisp
  (defvar my/audio-sink nil)
  ;; Pulse sometimes first starts when a video, etc starts
  (defun my/pulse-update-audio-sink ()
    (if (not my/audio-sink)
        (setq my/audio-sink (substring  (shell-command-to-string "pacmd list-sinks | grep \"index\"") (string-match "[0-9]" (shell-command-to-string "pacmd list-sinks | grep \"index\"")) -1))))

  (defun my/pulse-mute-toggle ()
    (interactive)
    (my/pulse-update-audio-sink)
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " toggle")))

  (global-set-key (kbd "<XF86AudioMute>") 'my/pulse-mute-toggle)
  (global-set-key (kbd "s-`") 'my/pulse-mute-toggle)

  (defun my/pulse-raise-volume ()
    (interactive)
    (my/pulse-update-audio-sink)
    ;; Unmute
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
    (shell-command (concat "pactl set-sink-volume " my/audio-sink " +2.5%")))

  (global-set-key (kbd "<XF86AudioRaiseVolume>") 'my/pulse-raise-volume)
  (global-set-key (kbd "s-=") 'my/pulse-raise-volume)

  (defun my/pulse-lower-volume ()
    (interactive)
    (my/pulse-update-audio-sink)
    ;; Unmute
    (shell-command (concat "pactl set-sink-mute " my/audio-sink " 0"))
    (shell-command (concat "pactl set-sink-volume " my/audio-sink " -2.5%")))

  (global-set-key (kbd "<XF86AudioLowerVolume>") 'my/pulse-lower-volume)

  (global-set-key (kbd "s--") 'my/pulse-lower-volume)
#+END_SRC

** Music
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/music-map)
  (define-key my/leader-map (kbd "m") 'my/music-map)
#+END_SRC

*** EMMS
Setup emms
#+BEGIN_SRC emacs-lisp
  (defvar my/emms-has-init nil)

  (defvar my/emms-init-hook nil
    "Hook called when emms has to init fully")

  (use-package emms)


  (add-hook 'my/emms-init-hook (lambda () (interactive)
                                 (unless my/emms-has-init
                                   (setq my/emms-has-init t)
                                   (require 'emms-setup)
                                   (require 'emms-player-mpd)

                                   (emms-all) 
                                   ;; Disable name of playing track in modeline (time is kept though)
                                   (emms-mode-line-disable))))

  (setq emms-mode-line-format nil)

  (setq emms-seek-seconds 5)
  (setq emms-player-list '(emms-player-mpd))
  (setq emms-info-functions '(emms-info-mpd))

  (setq emms-player-mpd-server-name "localhost")
  (setq emms-player-mpd-server-port "6600")

  ;;(setq mpc-host "localhost:6600")
#+END_SRC

**** Sort by directory name instead of metadata
#+BEGIN_SRC emacs-lisp
  (setq emms-browser-get-track-field-function 'emms-browser-get-track-field-use-directory-name)
#+END_SRC

**** Open playlist
emms doesn't automatically connect to mpd when loading playlist, results in empty playlist
#+BEGIN_SRC emacs-lisp
  (defun my/open-emms-and-connect()
    "Reconnect to MPD and open emms playlist"
    (interactive)
    (run-hooks 'my/emms-init-hook)
    (emms-player-mpd-connect)
    (emms-smart-browse))
#+END_SRC

**** Sync MPD and emms
#+BEGIN_SRC emacs-lisp
  (defun my/sync-mpd-and-emms ()
    "Updates the MPD and emms database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (emms-player-mpd-update-all-reset-cache)
    (emms-cache-set-from-mpd-all)
    (emms-player-mpd-connect)
    (message "MPD database and emms updated!"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (require 'emms-browser)
  (define-key my/music-map (kbd "u") 'my/sync-mpd-and-emms) 

  (define-key my/music-map (kbd "o") 'my/open-emms-and-connect)
  (define-key my/music-map (kbd "g") 'emms-seek-to)
  (define-key my/music-map (kbd "s") 'emms-pause)

  (define-key emms-browser-mode-map (kbd "s") 'emms-pause)

  (evil-define-key 'normal emms-browser-mode-map (kbd "RET") 'emms-browser-add-tracks)

  (evil-define-key 'normal emms-playlist-mode-map (kbd "RET") 'emms-playlist-mode-play-smart)

  (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause)
  (global-set-key (kbd "<XF86AudioStop>") 'emms-stop)
#+END_SRC

*** MPD
**** Start MPD
#+BEGIN_SRC emacs-lisp
  (defun my/start-mpd ()
    "Start MPD, connect to it and sync the metadata cache."
    (interactive)
    (start-process "mpd" nil "mpd")
    (message "MPD started and synced!"))
#+END_SRC

**** Kill daemon
#+BEGIN_SRC emacs-lisp
 (defun my/kill-music-daemon ()
   "Stops playback and kill the music daemon."
   (interactive)
   (emms-stop)
   (call-process "killall" nil nil nil "mpd")
   (message "MPD killed!"))
#+END_SRC

**** View MPD info
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-info ()
    "Runs mpc, showing info in message field"
    (interactive)
    (shell-command "mpc"))
#+END_SRC

**** Shuffle playlist random
***** Random on
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-on ()
    "Turns on MPD random play"
    (interactive)
    (shell-command "mpc random on"))
#+END_SRC

***** Random off
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-random-off ()
    "Turns off MPD random play"
    (interactive)
    (shell-command "mpc random off"))
#+END_SRC

**** Volume control
***** Raise volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-raise-volume()
  (interactive)
  (shell-command "mpc volume +4"))
#+END_SRC

***** Lower volume
#+BEGIN_SRC emacs-lisp
(defun my/mpd-lower-volume ()
  (interactive)
  (shell-command "mpc volume -4"))
#+END_SRC

**** Change song
***** Next song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-next-song()
  (interactive)
  (shell-command "mpc next"))
#+END_SRC

***** Previous song
#+BEGIN_SRC emacs-lisp
(defun my/mpd-previous-song()
  (interactive)
  (shell-command "mpc prev"))
#+END_SRC

**** Change time on track
***** Forward
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-forward()
    (interactive)
    (shell-command "mpc seek +10"))
#+END_SRC

***** Forward far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-forward()
    (interactive)
    (shell-command "mpc seek +60"))
#+END_SRC

***** Backwards
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-backward()
    (interactive)
    (shell-command "mpc seek -10"))
#+END_SRC

***** Backwards far
#+BEGIN_SRC emacs-lisp
  (defun my/mpd-wind-far-backward()
    (interactive)
    (shell-command "mpc seek -60"))
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/music-map (kbd "C-s") 'my/start-mpd)
  (define-key my/music-map (kbd "C-k") 'my/kill-music-daemon)
  (define-key my/music-map (kbd "i") 'my/mpd-info)

  (define-key my/music-map (kbd "r") 'my/mpd-random-on)
  (define-key my/music-map (kbd "C-r") 'my/mpd-random-off)

  (define-key my/music-map (kbd "=") 'my/mpd-raise-volume)
  (define-key my/music-map (kbd "-") 'my/mpd-lower-volume)

  (define-key my/music-map (kbd "n") 'my/mpd-next-song)
  (define-key my/music-map (kbd "p") 'my/mpd-previous-song)

  (define-key my/music-map (kbd "l") 'my/mpd-wind-forward)
  (define-key my/music-map (kbd "h") 'my/mpd-wind-backward)
  (define-key my/music-map (kbd "L") 'my/mpd-wind-far-forward)
  (define-key my/music-map (kbd "H") 'my/mpd-wind-far-backward)

  (global-set-key (kbd "<XF86AudioNext>") 'my/mpd-next-song)
  (global-set-key (kbd "<XF86AudioPrev>") 'my/mpd-previous-song)
#+END_SRC

* Screenshots
** Functions
*** Entire screen
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
      (sit-for 1)
      (start-process "screenshot" nil "import" "-window" "root" 
                     (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))))
#+END_SRC

*** Region
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/Pictures/Screenshots/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC 

*** Region ask for name
#+BEGIN_SRC emacs-lisp
  (defun my/take-screenshot-region-and-ask-for-name ()
    "Takes a screenshot of a region selected by the user and asks for file path"
    (interactive)
    (when window-system

      ;; Check if there is a directory called "images" in current dir, if so start read-file-name inside that directory
      (if(file-exists-p (concat default-directory "images/"))
          (setq screenshot-base-path (concat default-directory "images/"))
        (setq screenshot-base-path default-directory))

      ;; If screenshot path is not empty
      (call-process "import" nil nil nil ".newScreen.png")

      ;; Ask for path
      (setq screenshot-path (read-file-name "Screenshot file (.png already added) " screenshot-base-path))

      (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1" (concat screenshot-path ".png"))
      (call-process "rm" nil nil nil ".newScreen.png")))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<print>") 'my/take-screenshot-region-and-ask-for-name)

  ;;  (define-key my/leader-map (kbd "p r") 'my/take-screenshot-region)
  ;;  (define-key my/leader-map (kbd "p w") 'my/take-screenshot)
#+END_SRC

* Gnus
.gnus.el is written in =write config map=
#+BEGIN_SRC emacs-lisp
  (require 'gnus)
  (define-key my/open-map (kbd "g") 'gnus)

  (setq gnus-use-full-window nil)
#+END_SRC

** Agent
#+BEGIN_SRC emacs-lisp
  (setq gnus-agent-cache t)

  ;; auto go online????
  ;;(setq gnus-agent-go-online t)

  ;; ???
  ;;(setq gnus-agent-consider-all-articles nil)


  ;; Topic prompts
  ;;(setq gnus-server-unopen-status VALUE)
  ;; Message prompts
  ;;(setq gnus-auto-goto-ignores VALUE)

  ;; never que mail if sent when offline, change later
  (setq gnus-agent-queue-mail nil)

  (require 'gnus-agent)
  (add-to-list 'gnus-category-alist '(gmail (agent-predicate . short)))
#+END_SRC

** Global
#+BEGIN_SRC emacs-lisp
  ;;Fix bug in gnus, Replace [ and ] with _ in ADAPT file names
  (setq nnheader-file-name-translation-alist '((?[ . ?_) (?] . ?_)) )
#+END_SRC

** Minor settings
#+BEGIN_SRC emacs-lisp

  ;; Maybe disable later
  ;;(setq gnus-save-killed-list nil)

  (setq gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))

  ;; '(gnus-always-force-window-configuration t)

  ;; Disable signatures
  (setq message-signature nil)

  ;; never split messages
  (setq message-send-mail-partially-limit nil)

  ;; Disable gnus expiration
  (setq gnus-agent-enable-expiration 'DISABLE)

  ;; Create two connections to the server for faster fetching
  (setq gnus-asynchronous t)

  ;; Disable .newsrc file (file can be read by other newsreaders)
  (setq gnus-read-newsrc-file nil)
  (setq gnus-save-newsrc-file nil)

  ;; Replace with ivy later. Default value: "gnus-emacs-completing-read"
  (setq gnus-completing-read-function (quote gnus-ido-completing-read))

  ;; Don't mark unread after download
  (setq gnus-agent-mark-unread-after-downloaded nil)

  ;; Maybe need to enable again
  ;; '(gnus-article-date-lapsed-new-header t)
#+END_SRC

** Group mode
Mode for choosing server
#+BEGIN_SRC emacs-lisp
(defun my/gnus-group-mode ()
  ;; Tree view for groups.
  (gnus-topic-mode)
  ;; List all groups over level 5
  (gnus-group-list-all-groups 5))

(add-hook 'gnus-group-mode-hook 'my/gnus-group-mode)

;; Always show inbox
;; (setq gnus-permanently-visible-groups "INBOX")

;; Apparently only some servers support using 'some
;;(setq gnus-read-active-file 't)
 (setq gnus-read-active-file 'some)
 (setq gnus-check-new-newsgroups 'ask-server)
#+END_SRC

*** Methods
#+BEGIN_SRC emacs-lisp
(setq gnus-select-method '(nntp "news.gmane.org"))

(add-to-list 'gnus-secondary-select-methods
             '(nnimap "Gmail"
                      (nnimap-address "imap.gmail.com")
                      (nnimap-server-port "imaps")
                      (nnimap-stream ssl)
                      ;; Don't want to delete mails on server
                      ;; (nnmail-expiry-target "nnimap+gmail:[Gmail]/Trash")  ;; Move expired messages to Gmail's trash.
                      (nnmail-expiry-wait 90)))
                      
(setq smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      ;; Make Gnus NOT ignore [Gmail] mailboxes
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
#+END_SRC

*** Topic mode
Adds headers to each server, tree view
#+BEGIN_SRC emacs-lisp
      (defun my/gnus-topic-mode ()
        ;; Tree view for groups.
        ;; List all groups over level 5
        (my/gnus-topic-setup))

  (add-hook 'gnus-topic-mode-hook 'my/gnus-topic-mode)


  (defun my/gnus-topic-setup ()
    "Hides non-relevant servers and puts them into categories. To show all servers, disable my/gnus-topic-mode"

    ;; "Gnus" is the root folder, and there are three mail accounts, "misc", "hotmail", "gmail"
    (setq gnus-topic-topology '(("Gnus" visible)
                                (("hotmail" visible nil nil))
                                (("gmail" visible nil nil))))

    (setq gnus-topic-alist '(("hotmail"
                              "nnimap+hotmail:Inbox"
                              "nnimap+hotmail:Drafts"
                              "nnimap+hotmail:Sent"
                              "nnimap+hotmail:Junk"
                              "nnimap+hotmail:Deleted")
                             ("gmail"
                              "nnimap+Gmail:INBOX"
                              "nnimap+Gmail:[Gmail]/Sent Mail"
                              "nnimap+Gmail:[Gmail]/Spam"
                              "nnimap+Gmail:[Gmail]/Trash"
                              "nnimap+Gmail:[Gmail]/Drafts"
                              )
                             ("Gnus"))))

  ;; (eval-after-load 'gnus-topic
    ;; '(progn
       ;; (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
       ;; (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/Mail/archive")
                                  ;; (nnfolder-active-file "~/Mail/archive/active")
                                  ;; (nnfolder-get-new-mail nil)
                                  ;; (nnfolder-inhibit-expiry t))
                                 ;; ))))

#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal gnus-group-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-group-mode-map (kbd "RET") 'gnus-topic-select-group)

  (define-prefix-command 'my/gnus-group-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-group-map)

  (defun my/gnus-group-list-all-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 5))

  (define-key 'my/gnus-group-map (kbd "a") 'my/gnus-group-list-all-subscribed-groups)
#+END_SRC

** Summary mode
Mode for choosing which mail to open
#+BEGIN_SRC emacs-lisp
  (defun my/gnus-summary-mode ()
    (toggle-truncate-lines 1))

   ;; '(gnus-summary-mode-line-format "U%U %S" )
  (setq-default gnus-summary-line-format "%U%R%d %-5,5L %-20,20n %B%-80,80S\n")
  (add-hook 'gnus-summary-mode-hook 'my/gnus-summary-mode)

  (setq-default gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references)

  (setq-default gnus-sum-thread-tree-false-root "")
  (setq-default gnus-sum-thread-tree-indent " ")
  (setq-default gnus-sum-thread-tree-leaf-with-other "├► ")
  (setq-default gnus-sum-thread-tree-root "")
  (setq-default gnus-sum-thread-tree-single-leaf "╰► ")
  (setq-default gnus-sum-thread-tree-vertical "│")


   ;; '(gnus-summary-thread-gathering-function (quote gnus-gather-threads-by-references))

   ;; '(gnus-thread-hide-subtree t)
   ;; '(gnus-thread-sort-functions (quote gnus-thread-sort-by-most-recent-date))
   ;; '(gnus-treat-hide-citation t)
   ;; '(gnus-unread-mark 42)
   ;; '(gnus-ancient-mark 32)
#+END_SRC

*** Thread sorting
#+BEGIN_SRC emacs-lisp
;; Sort by date
(setq gnus-thread-sort-functions
      '(gnus-thread-sort-by-most-recent-date
        (not gnus-thread-sort-by-number)))
#+END_SRC

*** Visuals
#+BEGIN_SRC emacs-lisp
 ;; '(gnus-summary-high-unread ((t (:foreground "green"))))
 ;; '(gnus-summary-low-read ((t (:foreground "magenta"))))
 ;; '(gnus-summary-normal-read ((t (:foreground "red"))))
 ;; '(gnus-summary-selected ((t (:background "yellow"))))
 ;; '(gnus-summary-normal-unread ((t (:foreground "white"))))
#+END_SRC

*** Scoring
#+BEGIN_SRC emacs-lisp
(setq gnus-parameters
      '(("nnimap.*"
         (gnus-use-scoring nil)) ;scoring is annoying when I check latest email
        ))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-summary-map)
  (evil-define-key 'normal gnus-summary-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-summary-map)

  (evil-define-key 'normal gnus-summary-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal gnus-summary-mode-map (kbd "RET") (lambda () (interactive) (gnus-summary-scroll-up 1)))

  (defun my/gnus-summary-show-all-mail ()
    "Show all mail"
    (interactive)
    (gnus-summary-rescan-group 1))

  (define-key 'my/gnus-summary-map (kbd "a") 'my/gnus-summary-show-all-mail)
#+END_SRC

** Article mode
Mode for reading contents of mail
#+BEGIN_SRC emacs-lisp
(defun my/gnus-article-mode ()
  ;; Font lock mode disables colors in html mail for whatever reason
  (font-lock-mode -1))

(add-hook 'gnus-article-mode-hook 'my/gnus-article-mode)

(defun my/gnus-article-display-mode ()
  ;;  (gnus-article-de-quoted-unreadable)
  ;;  (gnus-article-emphasize)
  ;;  (gnus-article-hide-boring-headers)
  ;;  (gnus-article-hide-headers-if-wanted)
  ;;  (gnus-article-hide-pgp)
  ;;  (gnus-article-highlight)
  ;;  (gnus-article-highlight-citation)
  ;;  (gnus-article-date-local)
  )

(add-hook 'gnus-article-display-hook 'my/gnus-article-display-mode)

 ;; '(gnus-article-mode-line-format "U%U %S" )
#+END_SRC

*** Date headers
Make date headers better with timezone calculation and time passed
#+BEGIN_SRC emacs-lisp

(setq gnus-article-date-headers '(user-defined)
      gnus-article-time-format
      (lambda (time)
        (let* ((date (format-time-string "%a, %d %b %Y %T %z" time))
               (local (article-make-date-line date 'local))
               (combined-lapsed (article-make-date-line date
                                                        'combined-lapsed))
               (lapsed (progn
                         (string-match " (.+" combined-lapsed)
                         (match-string 0 combined-lapsed))))
          (concat local lapsed))))
#+END_SRC

*** Mail renderers, etc
#+BEGIN_SRC emacs-lisp
;; html renderer
(setq mm-text-html-renderer 'shr)
;; Inline images?
(setq mm-attachment-override-types '("image/.*"))
;; No HTML mail
(setq mm-discouraged-alternatives '("text/html" "text/richtext"))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-article-map)
  (evil-define-key 'normal gnus-article-mode-map (kbd (concat my/leader-map-key " a")) 'my/gnus-article-map)
#+END_SRC

** Message mode
Mode for writing mail

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/gnus-message-map)
  (evil-define-key 'normal gnus-group-mode-map (kbd (concat my/leader-map-key "a")) 'my/gnus-message-map)
#+END_SRC

** Misc
*** Random color gnus logo
#+BEGIN_SRC emacs-lisp
(random t) ; Randomize sequence of random numbers
(defun my/random-hex (&optional num)
  (interactive "P")
  (let (($n (if (numberp num) (abs num) 6 )))
    (format  (concat "%0" (number-to-string $n) "x" ) (random (1- (expt 16 $n))))))

(setq gnus-logo-colors (list (concat "#" (my/random-hex 6)) (concat "#" (my/random-hex 6))))
#+END_SRC

* System
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-commands-map)
  (define-key my/leader-map (kbd "~") 'my/system-commands-map)
#+END_SRC

** Suspend
  #+BEGIN_SRC emacs-lisp
    (define-prefix-command 'my/system-suspend-map)
    (define-key my/system-commands-map (kbd "s") 'my/system-suspend-map)

    (defun my/systemd-suspend-PC()
      (interactive)
      (shell-command "systemctl suspend"))
    (define-key my/system-suspend-map (kbd "C-s") 'my/systemd-suspend-PC)

    (defun my/systemd-hibernate-PC()
      (interactive)
      (shell-command "systemctl hibernate"))
    (define-key my/system-suspend-map (kbd "C-h") 'my/systemd-hibernate-PC)
#+END_SRC

** Multi-monitor
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/system-monitor-map)
  (define-key my/system-commands-map (kbd "m") 'my/system-monitor-map)

  (defun my/x-suspend-monitor()
    (interactive)
    (shell-command "xset dpms force suspend"))
  (define-key my/system-monitor-map (kbd "s") 'my/x-suspend-monitor)

  (defun my/print-monitors ()
    (interactive)
    (shell-command "xrandr"))
  (define-key my/system-monitor-map (kbd "p") 'my/print-monitors)

  (defun my/monitor-home-setup ()
    (interactive)
    (shell-command "xrandr --output DP-1 --mode 2560x1440 --rate 60 --left-of DVI-I-1 --output DVI-D-1 --mode 1280x800 --rate 59.81 --left-of DP-1 --output DVI-I-1 --mode 1280x800 --rate 59.81"))
  (define-key my/system-monitor-map (kbd "h") 'my/monitor-home-setup)

  (defun my/auto-connect-screen ()
    (interactive)
    (with-temp-buffer
      (call-process "xrandr" nil t nil)
      (beginning-of-buffer)
      (if (search-forward "VGA1 connected" nil 'noerror)
          (start-process-shell-command
           "xrandr" nil "xrandr --output VGA1 --primary --auto --output LVDS1 --off")
        (start-process-shell-command
         "xrandr" nil "xrandr --output LVDS1 --auto"))))
  (define-key my/system-monitor-map (kbd "a") 'my/auto-connect-screen)
#+END_SRC

** Process monitors
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/processes-map)
  (define-key my/system-commands-map (kbd "p") 'my/processes-map)
#+END_SRC

*** Top - proced
#+BEGIN_SRC emacs-lisp
  (define-key my/processes-map (kbd "t") 'proced)
#+END_SRC

**** Disable rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (add-hook 'proced-mode-hook 'rainbow-delimiters-mode-disable)
#+END_SRC

**** Disable line wrapping
#+BEGIN_SRC emacs-lisp
  (defun my/proced-mode ()
    (interactive)
    (toggle-truncate-lines 1))

  ;;(add-hook 'proced-post-display-hook 'my/proced-mode)
  (add-hook 'proced-mode-hook 'my/proced-mode)
#+END_SRC

*** Profiler
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/profiler-map)
  (define-key my/processes-map (kbd "p") 'my/profiler-map)

  (define-key my/profiler-map (kbd "s") 'profiler-start)
  (define-key my/profiler-map (kbd "e") 'profiler-stop)
  (define-key my/profiler-map (kbd "r") 'profiler-report)
#+END_SRC

* Networking
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/net-utils-map)
  (define-key my/system-commands-map (kbd "n") 'my/net-utils-map)
#+END_SRC

TODO counsel-tramp

** Tramp
#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC

** Netstat
#+BEGIN_SRC emacs-lisp
  (defun my/net-utils-mode ()
    (interactive)
    (toggle-truncate-lines 1))

  (add-hook 'net-utils-mode-hook 'my/net-utils-mode)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/net-utils-map (kbd "s") 'netstat)
  (define-key my/net-utils-map (kbd "p") 'ping)
  (define-key my/net-utils-map (kbd "i") 'ifconfig)
#+END_SRC

* Hardware
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/hardware-info-map)
  (define-key my/system-commands-map (kbd "h") 'my/hardware-info-map)

  ;; Memory
  (defun my/unix-get-memory-available()
    (interactive)
    (shell-command "grep \"MemAvailable\" /proc/meminfo"))
  (define-key my/hardware-info-map (kbd "m") 'my/unix-get-memory-available)

  ;; GPU
  (defun my/unix-get-gpu()
    (interactive)
    (shell-command "lspci | grep ' VGA ' | cut -d\" \" -f 1 | xargs -i lspci -v -s {}"))
  (define-key my/hardware-info-map (kbd "g") 'my/unix-get-gpu)

  ;; Blocked devices
  (defun my/rfkill-get-blocked-devices()
    (interactive)
    (shell-command "rfkill list"))
  (define-key my/hardware-info-map (kbd "b") 'my/rfkill-get-blocked-devices)

  ;; Get devices
  (defun my/rfkill-get-devices()
    (interactive)
    (shell-command "cat /proc/devices"))
  (define-key my/hardware-info-map (kbd "d") 'my/rfkill-get-devices)
#+END_SRC

** CPU
#+BEGIN_SRC emacs-lisp
  ;; Linux temps
  (if (file-exists-p "/proc/cpuinfo") (progn
                                        (define-prefix-command 'my/cpu-info-map)
                                        (define-key my/hardware-info-map (kbd "c") 'my/cpu-info-map)

                                        (defun my/unix-cpu-get-clock()
                                          (interactive)
                                          (shell-command "grep \"cpu MHz\" /proc/cpuinfo"))
                                        ;; Clock speed
                                        (define-key my/cpu-info-map (kbd "f") 'my/unix-cpu-get-clock)
                                        ;; Model name
                                        (defun my/unix-cpu-get-name()
                                          (interactive)
                                          (shell-command "grep \"model name\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "n") 'my/unix-cpu-get-name)
                                        ;; Core count
                                        (defun my/unix-cpu-get-core-count()
                                          (interactive)
                                          ;; Linux
                                          (shell-command "grep \"cores\" /proc/cpuinfo"))

                                        (define-key my/cpu-info-map (kbd "c") 'my/unix-cpu-get-core-count)
                                        ;; Flags
                                        (defun my/unix-cpu-get-flags()
                                          (interactive)
                                          (shell-command "grep \"flags\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "F") 'my/unix-cpu-get-flags)
                                        ;; Vendor
                                        (defun my/unix-cpu-get-vendor-id()
                                          (interactive)
                                          (shell-command "grep \"vendor_id\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "v") 'my/unix-cpu-get-vendor-id)
                                        ;; Bugs (Bugs that has affected CPU model)
                                        (defun my/unix-cpu-get-bugs()
                                          (interactive)
                                          (shell-command "grep \"bugs\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "b") 'my/unix-cpu-get-bugs)
                                        ;; Cache size
                                        (defun my/unix-cpu-get-cache-size()
                                          (interactive)
                                          (shell-command "grep \"cache size\" /proc/cpuinfo"))
                                        (define-key my/cpu-info-map (kbd "C") 'my/unix-cpu-get-cache-size)))

  ;; Windows cpu core count
  ;; (if (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
      ;; (let ((number-of-processors (getenv "NUMBER_OF_PROCESSORS")))
        ;; (if number-of-processors
            ;; (string-to-number number-of-processors))))
#+END_SRC

* Find
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/find-map)
  (define-key my/leader-map (kbd "F") 'my/find-map)

  (define-key my/find-map (kbd "l") 'counsel-locate)

  (define-key my/find-map (kbd "g") 'counsel-ag)
#+END_SRC

* Spelling
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/spell-map)
  (define-key my/leader-map (kbd "C-l") 'my/spell-map)

  (defun my/toggle-company-ispell ()
    (interactive)
    (cond
     ((memq 'company-ispell company-backends)
      (setq company-backends (delete 'company-ispell company-backends))
      (message "company-ispell disabled"))
     (t
      (add-to-list 'company-backends 'company-ispell)
      (message "company-ispell enabled!"))))

  (define-key my/spell-map (kbd "l") 'ispell-change-dictionary)
  (define-key my/spell-map (kbd "s") 'flyspell-mode)
  (define-key my/spell-map (kbd "c") 'my/toggle-company-ispell)
#+END_SRC

* Calc
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "c") 'calc)

  (defun my/calc-kill-current-line ()
    (interactive)
    (calc-kill-region (line-beginning-position) (line-end-position)))

  (evil-define-key 'normal calc-mode-map (kbd "d d") 'my/calc-kill-current-line)
  (evil-define-key 'visual calc-mode-map (kbd "d") 'calc-kill-region)
#+END_SRC

* Artist mode
https://www.emacswiki.org/emacs/FacesPerBuffer
#+BEGIN_SRC emacs-lisp
  (defvar my/artist-mode-highlight-thing-restore nil)
  (defvar my/artist-mode-aggressive-indent-restore nil)
  ;;(defvar my/artist-mode-highlight-indent-restore nil)
  (defvar my/artist-mode-restore-buffer nil)

  (defun my/artist-mode ()
    (if (eq major-mode 'picture-mode)
        (progn
          (setq my/artist-mode-restore-buffer (current-buffer))
          (if highlight-thing-mode
              (progn
                (highlight-thing-mode -1)
                (setq my/artist-mode-highlight-thing-restore t))
            (setq my/artist-mode-highlight-thing-restore nil))

          (if aggressive-indent-mode
              (progn
                (aggressive-indent-mode -1)
                (setq my/artist-mode-aggressive-indent-restore t))
            (setq my/artist-mode-aggressive-indent-restore nil))

          ;; (if highlight-indent-guides-mode
              ;; (progn
                ;; (highlight-indent-guides-mode -1)
                ;; (setq my/artist-mode-highlight-indent-restore t))
            ;; (setq my/artist-mode-highlight-indent-restore nil))

          (evil-emacs-state)

          (if (not my/is-font-mono)
              (set-face-attribute 'default nil
                                  :family my/mono-font)))

      ;; Turn everything back on
      (if (eq my/artist-mode-restore-buffer (current-buffer))
          (progn
            (if my/artist-mode-highlight-thing-restore
                (progn
                  (setq my/artist-mode-highlight-thing-restore nil)
                  (highlight-thing-mode 1)))

            (if my/artist-mode-aggressive-indent-restore
                (progn
                  (setq my/artist-mode-aggressive-indent-restore nil)
                  (aggressive-indent-mode 1)))

            ;;(if my/artist-mode-highlight-indent-restore
                ;;(progn
                  ;;(setq my/artist-mode-highlight-indent-restore nil)
                  ;;(highlight-indent-guides-mode 1)))

            (evil-exit-emacs-state)
            (if (and (not my/is-font-mono) window-system)
                (set-face-attribute 'default nil
                                    :family my/font)))
        )
      (setq my/artist-mode-restore-buffer nil)))

  (add-hook 'artist-mode-hook 'my/artist-mode)
#+END_SRC

** Completing read
https://www.emacswiki.org/emacs/ArtistMode
#+BEGIN_SRC emacs-lisp
  (defun my/artist-select-operation (type)
    "Use ido to select a drawing operation in artist-mode"
    (interactive (list (completing-read "Drawing operation: " 
                                        (list "Pen" "Pen Line" "line" "straight line" "rectangle" 
                                              "square" "poly-line" "straight poly-line" "ellipse" 
                                              "circle" "text see-thru" "text-overwrite" "spray-can" 
                                              "erase char" "erase rectangle" "vaporize line" "vaporize lines" 
                                              "cut rectangle" "cut square" "copy rectangle" "copy square" 
                                              "paste" "flood-fill"))))
    (artist-select-operation type))

  (defun my/artist-select-settings (type)
    "Use ido to select a setting to change in artist-mode"
    (interactive (list (completing-read "Setting: " 
                                        (list "Set Fill" "Set Line" "Set Erase" "Spray-size" "Spray-chars" 
                                              "Rubber-banding" "Trimming" "Borders"))))
    (if (equal type "Spray-size") 
        (artist-select-operation "spray set size")
      (call-interactively (artist-fc-get-fn-from-symbol 
                           (cdr (assoc type '(("Set Fill" . set-fill)
                                              ("Set Line" . set-line)
                                              ("Set Erase" . set-erase)
                                              ("Rubber-banding" . rubber-band)
                                              ("Trimming" . trimming)
                                              ("Borders" . borders)
                                              ("Spray-chars" . spray-chars))))))))
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/leader-map (kbd "A") 'artist-mode)

  (define-prefix-command 'my/artist-mode-map)
  (evil-define-key 'normal artist-mode-map (kbd (concat my/leader-map-key " a")) 'my/artist-mode-map)

  (define-key my/artist-mode-map (kbd "o") 'my/artist-select-operation)
  (define-key my/artist-mode-map (kbd "s") 'my/artist-select-settings)
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra)

  ;; Hydra lv generates a lot of garbage, disable it
  (setq hydra-lv nil)
#+END_SRC

** Window and buffer management
#+BEGIN_SRC emacs-lisp
  (defhydra my/window-hydra (:hint nil
                                   :color red)
    ;; :pre (setq exwm-input-line-mode-passthrough t)
    ;; :post (setq exwm-input-line-mode-passthrough nil))
    "movement" 

    ;; Move focus
    ("p" evil-window-up nil)
    ("n" evil-window-down nil)
    ("l" evil-window-right nil)
    ("h" evil-window-left nil)

    ;; Move focus to edge window
    ;; Frame border window
    ("|" evil-window-mru nil)

    ;; Move window
    ;; Move up
    ("P" evil-move-very-top nil)
    ;; Move down
    ("N" evil-move-very-bottom nil)
    ;; Move right
    ("L" evil-move-far-right nil)
    ;; Move left
    ("H" evil-move-far-left nil)

    ;; Switch monitor right
    ("M-l" my/switch-monitor-right nil)
    ;; Switch monitor left
    ("M-h" my/switch-monitor-left nil)

    ;; Resize window
    ;; Resize up
    ("C-p" (evil-window-increase-height 10) nil)
    ;; Resize down
    ("C-n" (evil-window-decrease-height 10) nil)
    ;; Resize right
    ("C-l" (evil-window-decrease-width 10) nil)
    ;; Resize left
    ("C-h" (evil-window-increase-width 10) nil)

    ;; Split
    ("o" split-window-horizontally nil)
    ("v" split-window-vertically nil)

    ;; Close window
    ("s" delete-window nil)
    ;; Focus on window
    ("d" my/delete-other-windows nil)

    ;; minimize window
    ("S" (lambda () (interactive) (evil-window-increase-height 1000) (evil-window-increase-width 1000)) nil)
    ;; maximize window
    ("D" (lambda () (interactive) (evil-window-decrease-height 1000) (evil-window-decrease-width 1000)) nil)

    ;; Buffer management
    ;; Find file
    ("e" my/find-file nil)
    ("E" dired-jump nil)

    ;; Switch buffer
    ("A" next-buffer nil)
    ("C-a" previous-buffer nil)

    ;; Switch buffer
    ("a" ivy-switch-buffer nil)
    ;; Kill buffer
    ("k" kill-current-buffer nil)

    ;; Move around in buffer
    ("C-u" evil-scroll-up nil)
    ("C-w" evil-scroll-down nil)

    ("f" counsel-M-x nil)
    ("y" counsel-linux-app nil)

    ("u" revert-buffer nil)

    ;; Switch window configuration
    ("t" my/load-window-config nil)
    ("T" my/add-window-config nil)
    ("C-t" my/delete-window-config nil)

    ("b" counsel-bookmark nil)
    ("B" my/add-bookmark nil)
    ("C-b" my/delete-bookmark nil))

    ;;  ("SPC" my/leader-map nil)

    ;; Add this to not auto exit insert mode after closing the hydra
    ;;("<escape>" nil))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/keys-mode-map (kbd my/mod-window-leader-key) 'my/window-hydra/body)
  (define-key my/keys-mode-map (kbd my/window-leader-key) 'my/window-hydra/body)
#+END_SRC

* Image modes
** PDF view
#+BEGIN_SRC emacs-lisp
  (defun my/pdf-view-mode()
    (interactive)
    (display-line-numbers-mode -1))

  (add-hook 'pdf-view-mode-hook 'my/pdf-view-mode t)
#+END_SRC

** PDF tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :defer t)

  (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . my/init-pdf-tools))
  ;;(add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))

  (setq my/pdf-tools-installed nil)

  (defun my/init-pdf-tools ()
    (interactive)
    (if (not my/pdf-tools-installed)
        (progn
          (require 'pdf-view)
          (pdf-tools-install)
          ;; reload buffer with everything set
          (revert-buffer :ignore-auto :noconfirm)))
    (setq my/pdf-tools-installed t)
    (pdf-view-mode))

    ;;(add-hook 'pdf-view-mode-hook 'my/init-pdf-tools)

    ;; Enable pdf-links
    (add-hook 'pdf-view-mode-hook 'pdf-links-minor-mode)

    ;; Remove default keys
    (setq pdf-view-mode-map (make-sparse-keymap))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  ;; Disable insert mode
  (define-key pdf-view-mode-map [remap evil-insert] 'evil-force-normal-state)

  ;; Scroll half page
  (define-key pdf-view-mode-map [remap View-scroll-half-page-backward] 'pdf-view-scroll-down-or-previous-page)
  (define-key pdf-view-mode-map [remap View-scroll-half-page-forward] 'pdf-view-scroll-up-or-next-page)

  (define-key pdf-view-mode-map [remap evil-scroll-up] 'pdf-view-scroll-down-or-previous-page)
  (define-key pdf-view-mode-map [remap evil-scroll-down] 'pdf-view-scroll-up-or-next-page)
  
  ;; goto
  (define-key pdf-view-mode-map [remap evil-goto-first-line] 'pdf-view-first-page)

  ;; (kbd "G") = (evil-goto-line LAST-LINE)
  (define-key pdf-view-mode-map [remap evil-goto-line] 'pdf-view-last-page)
  ;; search
  (define-key pdf-view-mode-map [remap counsel-grep-or-swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap my/use-swiper-or-grep] 'isearch-forward)
  (define-key pdf-view-mode-map [remap swiper] 'isearch-forward)
  (define-key pdf-view-mode-map [remap counsel-grep] 'isearch-forward)

  ;; Movement
  (define-key pdf-view-mode-map [remap evil-next-line] '(lambda () (interactive) (image-next-line 4)))
  (define-key pdf-view-mode-map [remap evil-previous-line] '(lambda () (interactive) (image-previous-line 4)))

  (define-key pdf-view-mode-map [remap evil-forward-char] '(lambda () (interactive) (image-forward-hscroll 8)))
  (define-key pdf-view-mode-map [remap evil-backward-char] '(lambda () (interactive) (image-backward-hscroll 8)))

  ;; Disable other modes
  (evil-define-key 'normal pdf-view-mode-map (kbd "i") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "v") 'nil)
  (evil-define-key 'normal pdf-view-mode-map (kbd "R") 'nil)

  ;; Zoom
  (evil-define-key 'normal pdf-view-mode-map (kbd "-") 'pdf-view-shrink)
  (evil-define-key 'normal pdf-view-mode-map (kbd "=") 'pdf-view-enlarge)
  (evil-define-key 'normal pdf-view-mode-map (kbd "_") 'pdf-view-scale-reset)
  (evil-define-key 'normal pdf-view-mode-map (kbd "+") 'pdf-view-scale-reset)

  ;; Add to leader map
  (define-prefix-command 'my/pdf-view-mode-map)
  (evil-define-key 'normal pdf-view-mode-map (kbd (concat my/leader-map-key " a")) 'my/pdf-view-mode-map)

  (define-key my/pdf-view-mode-map (kbd "o") 'pdf-occur)
  (define-key my/pdf-view-mode-map (kbd "t") 'doc-view-open-text)
  (define-key my/pdf-view-mode-map (kbd "n") 'pdf-view-midnight-minor-mode)
  (define-key my/pdf-view-mode-map (kbd "g") 'pdf-view-goto-label)
  (define-key my/pdf-view-mode-map (kbd "i") 'pdf-view-extract-region-image)
#+END_SRC

** Image mode
#+BEGIN_SRC emacs-lisp
  (require 'image-mode)

  (add-hook 'image-mode-hook '(lambda () (interactive) (display-line-numbers-mode -1)))
#+END_SRC

*** Blimp
#+BEGIN_SRC emacs-lisp
  (use-package blimp)

  (setq eimp-enable-undo t)

  (add-hook 'image-mode-hook 'blimp-mode)
#+END_SRC

**** Recolor
#+BEGIN_SRC emacs-lisp
  (defun my/blimp-annotate-middle()
    (interactive)
    (blimp-add-to-command-stack (list "-gravity" "Center" "-fill" "red" "-pointsize" "25" "-annotate" "0,0" (completing-read "enter text " nil)))
    (blimp-execute-command-stack)
    (sleep-for 0.2))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal image-mode-map (kbd "-") 'image-decrease-size)
  (evil-define-key 'normal image-mode-map (kbd "=") 'image-increase-size)
  (evil-define-key 'normal image-mode-map (kbd "_") 'image-transform-fit-to-height)
  (evil-define-key 'normal image-mode-map (kbd "+") 'image-transform-fit-to-width)

  (evil-define-key 'normal image-mode-map (kbd "C-u") 'image-scroll-down)
  (evil-define-key 'normal image-mode-map (kbd "C-w") 'image-scroll-up)

  (evil-define-key 'normal image-mode-map (kbd "n") '(lambda () (interactive) (image-next-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "p") '(lambda () (interactive) (image-previous-line 8)))
  (evil-define-key 'normal image-mode-map (kbd "h") '(lambda () (interactive) (image-backward-hscroll 8)))
  (evil-define-key 'normal image-mode-map (kbd "l") '(lambda () (interactive) (image-forward-hscroll 8)))

  (evil-define-key 'normal image-mode-map (kbd "G") '(lambda () (interactive) (image-next-line 100)))
  (evil-define-key 'normal image-mode-map (kbd "g g") '(lambda () (interactive) (image-previous-line 100)))

  (evil-define-key 'normal image-mode-map (kbd "$") '(lambda () (interactive) (image-forward-hscroll 100)))
  (evil-define-key 'normal image-mode-map (kbd "0") '(lambda () (interactive) (image-backward-hscroll 100)))

  (define-prefix-command 'my/image-mode-map)
  (evil-define-key 'normal image-mode-map (kbd (concat my/leader-map-key " a")) 'my/image-mode-map)

  (define-key my/image-mode-map (kbd "i") 'blimp-interface)
  (define-key my/image-mode-map (kbd "I") 'blimp-interface-execute)

  (define-key my/image-mode-map (kbd "r") 'blimp-clear-command-stack)
  (define-key my/image-mode-map (kbd "e") 'blimp-execute-command-stack)
  (define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)
  (define-key my/image-mode-map (kbd "p") 'blimp-toggle-prefix)

  (define-key my/image-mode-map (kbd "a") 'my/blimp-annotate-middle)
#+END_SRC

* Outline
http://www.modernemacs.com/post/outline-ivy/
#+BEGIN_SRC emacs-lisp
  (use-package outorg)
  (use-package outshine)
  (add-hook 'outline-minor-mode-hook 'outshine-hook-function)

  (add-hook 'prog-mode-hook 'outline-minor-mode)

  (setq outshine-startup-folded-p nil)
#+END_SRC

** Visuals
#+BEGIN_SRC emacs-lisp
  (setq counsel-outline-face-style nil)

  (set-face-attribute 'outshine-level-1 nil :inherit 'outline-1 :height 1.9)
  (set-face-attribute 'outshine-level-2 nil :inherit 'outline-2 :height 1.6)
  (set-face-attribute 'outshine-level-3 nil :inherit 'outline-3 :height 1.4)
  (set-face-attribute 'outshine-level-4 nil :inherit 'outline-4 :height 1.3)
  (set-face-attribute 'outshine-level-5 nil :inherit 'outline-5 :height 1.25)
  (set-face-attribute 'outshine-level-6 nil :inherit 'outline-6 :height 1.2)
  (set-face-attribute 'outshine-level-7 nil :inherit 'outline-7 :height 1.15)
  (set-face-attribute 'outshine-level-8 nil :inherit 'outline-8 :height 1.10)
#+END_SRC

*** Outline bullets
http://www.modernemacs.com/post/outline-ivy/
http://www.modernemacs.com/post/outline-bullets/
#+BEGIN_SRC emacs-lisp
  ;; Just replace "^\\*+ "  with custom regex for org-bullets, add hook, done
#+END_SRC

*** Ellipsis
#+BEGIN_SRC emacs-lisp
  (defvar outline-display-table (make-display-table))
  (set-display-table-slot outline-display-table 'selective-display
                          (vector (make-glyph-code my/fold-ellipsis-char 'escape-glyph)))
  (defun set-outline-display-table ()
    (setf buffer-display-table outline-display-table))

  (add-hook 'outline-mode-hook 'set-outline-display-table)
  (add-hook 'outline-minor-mode-hook 'set-outline-display-table)
#+END_SRC

** Keys
#+BEGIN_SRC emacs-lisp
  (defun my/outline-hide-all-body ()
    (interactive)
    (outline-show-all)
    (outline-hide-body))

  (define-key evil-normal-state-map (kbd "ga") 'my/outline-hide-all-body)
  (define-key evil-normal-state-map (kbd "gA") 'outline-show-all)

  (define-key evil-normal-state-map (kbd "go") 'evil-open-fold)
  (define-key evil-normal-state-map (kbd "gO") 'evil-open-fold-rec)

  (define-key evil-normal-state-map (kbd "gf") 'evil-close-fold)
  (define-key evil-normal-state-map (kbd "gF") '(lambda () (interactive) (hide-sublevels 1)))

  (define-key evil-normal-state-map (kbd "gh") 'outline-previous-heading)
#+END_SRC

* Visuals
** Indicate empty lines
#+BEGIN_SRC emacs-lisp
  (setq-default indicate-empty-lines t)
#+END_SRC

** Center text
#+BEGIN_SRC emacs-lisp
  (use-package olivetti)

  (setq-default olivetti-body-width 150)

  (define-key my/leader-map (kbd "V") 'olivetti-mode)
#+END_SRC

** Fringe size
Used by diff-hl and flycheck
Fringe only on the left side
#+BEGIN_SRC emacs-lisp
  (fringe-mode '(6 . 0))
#+END_SRC

** Beacon
#+BEGIN_SRC emacs-lisp
  ;; (use-package beacon)
;; 
  ;; (beacon-mode 1)
#+END_SRC
  
** Rainbow
Changes background of eg. #FF00FF to represent color
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode)

  (define-key my/help-map (kbd "c") 'rainbow-mode)
#+END_SRC

** Rainbow delimiters
Changes colors of delimiters eg. {()}
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters)

  (define-key my/help-map (kbd "d") 'rainbow-delimiters-mode)
  ;;(add-hook 'prog-mode 'rainbow-delimiters-mode)
#+END_SRC

** Minimap
#+BEGIN_SRC emacs-lisp
  (use-package minimap)

  (define-key my/leader-map (kbd "]") 'my/toggle-window-config-minimap)

  (setq minimap-window-location 'right)
#+END_SRC

*** Toggle minimap by window config
#+BEGIN_SRC emacs-lisp
  (defvar my/minimap-exists nil)

  (defun my/kill-minimap()
    (if my/minimap-exists
        (progn
          (minimap-kill)
          (setf my/minimap-exists nil))))

  (defun my/start-minimap()
    (if (not my/minimap-exists)
        (progn
          (minimap-create)
          (setf my/minimap-exists t))))

  (defvar my/window-configs-with-minimap (list))

  (defun my/has-current-window-config-minimap ()
    (cl-position my/current-window-configuration my/window-configs-with-minimap :test 'string=))

  (defun my/toggle-window-config-minimap()
    (interactive)
    (if (my/has-current-window-config-minimap)
        (setq my/window-configs-with-minimap (delete my/current-window-configuration my/window-configs-with-minimap))
      (push my/current-window-configuration my/window-configs-with-minimap))
    (my/window-config-minimap-refresh))

  (defun my/window-config-minimap-refresh()
    (if (my/has-current-window-config-minimap)
        (my/start-minimap)
      (my/kill-minimap)))
  (setq my/window-configs-with-minimap nil)

  (add-hook 'my/window-config-name-changed-hook 'my/window-config-minimap-refresh t)
#+END_SRC

** Highlight matching delimiters
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0)
#+END_SRC

** Highlight current line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

** Pretty mode (converts text into symbols)
Only enable when using GUI. Transforms ASCII to symbols depending on mode
#+BEGIN_SRC emacs-lisp
  ;; TODO Global pretty mode is buggy when using swiper, generates tons of garbage, normal pretty-mode works
  ;; When the function (global-pretty-mode t) is run, it generates a TON of garbage since it searches the newly created swiper buffer
  ;; Look at turn-on-pretty-if-desired
  ;; (when window-system
  ;; (use-package pretty-mode)
  ;; (global-pretty-mode t))
#+END_SRC

** Highlight thing
Highlight thing under cursor and all other occurrences
#+BEGIN_SRC emacs-lisp
  (use-package highlight-thing)

  ;; Don't highlight the word true or false
  ;;(setq highlight-thing-ignore-list '("False" "True"))

  ;; Don't highlight thing under cursor, only matches
  (setq highlight-thing-exclude-thing-under-point 1)

  (setq highlight-thing-case-sensitive-p 1) 
  (global-highlight-thing-mode)
#+END_SRC

** Disable blinking cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** Disable GUI
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

** Faces
#+BEGIN_SRC emacs-lisp
(if window-system
    (set-face-attribute 'header-line nil
                        :foreground (face-attribute 'default :foreground)
                        :background (face-attribute 'default :background)
                        :family (face-attribute 'default :family)
                        :height (face-attribute 'default :height)))

  (set-face-attribute 'org-mode-line-clock nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-mode-line-clock-overrun nil
                      :foreground (face-attribute 'default :foreground)
                      :background "red"
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-effort nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-regexp nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-tags nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))

  (set-face-attribute 'org-agenda-filter-category nil
                      :foreground (face-attribute 'default :foreground)
                      :background (face-attribute 'default :background)
                      :height (face-attribute 'default :height))
#+END_SRC

** Modeline
Make mode line appear in echo area instead of in the mode line area. This saves space and makes it so that the mode line can't be split

*** Mode line
Set mode line height
#+BEGIN_SRC emacs-lisp
  ;; Disable normal mode line
  ;; (setq mode-line-format nil)
  ;; (setq-default mode-line-format nil)

  (setq mode-line-format "")
  (setq-default mode-line-format "")

  (if window-system
    ;; Set mode line height
    (set-face-attribute 'mode-line nil
                        ;; :foreground (face-attribute 'window-divider :foreground)
                        ;; :background (face-attribute 'window-divider :background)
                        :foreground "white" 
                        :background "white"
                        :height  0.1
                        :family my/mono-font)

    (set-face-attribute 'mode-line-inactive nil
                        :foreground "dark gray"
                        :background "dark gray"
                        :height  0.1
                        :family my/mono-font))
#+END_SRC
*** LV-line (top modeline)
Use lv-line to create a mode line on the top of the screen
#+BEGIN_SRC emacs-lisp
  (defvar my/lv-line-format "")
  (defconst my/lv-line--buffer " *LV-line*")
  (defvar my/lv-line-window nil)
#+END_SRC

**** LV-line update
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line--update ()
    (let* ((buffer (get-buffer my/lv-line--buffer)))
      (if (not buffer)
          (progn
            (message "LV-line buffer not found - creating new one")
            (my/lv-line-create)))
      (with-current-buffer buffer
        (erase-buffer)
        (insert (format-mode-line my/lv-line-format)))))
#+END_SRC

**** Create LV-line at top
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line-set-buffer ()
    (setq indicate-empty-lines nil)
    (set-window-hscroll my/lv-line-window 0)
    (setq window-size-fixed t)
    (setq mode-line-format nil)

    (if window-system
        ;; Change to mono face
        (face-remap-add-relative 'default :family my/mono-font))

    ;; Disable cursor
    (setq cursor-type nil)
    (setq cursor-in-non-selected-windows nil)

    (set-window-dedicated-p my/lv-line-window t)
    (set-window-parameter my/lv-line-window 'no-other-window t))

  (defun my/lv-line-create ()
    (if (not (get-buffer my/lv-line--buffer))
        (generate-new-buffer my/lv-line--buffer))
    (if (not (window-live-p my/lv-line-window))
        (let* ((original-window (selected-window)))
          (setq my/lv-line-window
                (select-window
                 (let ((ignore-window-parameters t))
                   (split-window
                    (frame-root-window) -1 'above)
                   )))
          (switch-to-buffer my/lv-line--buffer)
          (my/lv-line-set-buffer)
          (select-window original-window))))

  ;; (defun my/lv-line-create ()
  ;; "Ensure that LV window is live and return it."
  ;; (if (window-live-p my/lv-line-window)
  ;; my/lv-line-window
  ;; (let ((ori (selected-window)) buf)
  ;; (prog1 (setq my/lv-line-window
  ;; (select-window
  ;; (let ((ignore-window-parameters t))
  ;; (split-window
  ;; (frame-root-window) -1 'above))))
  ;; (my/lv-line-create-buffer)
  ;; (select-window ori)))))
#+END_SRC
**** Update it
#+BEGIN_SRC emacs-lisp
  (defun my/lv-line-start()
    (my/lv-line-create)
    (my/lv-line--update)
    (add-hook 'post-command-hook 'my/lv-line--update t)
    (add-hook 'my/switch-buffer-hook 'my/lv-line--update t)
    (run-with-timer 6 60 'my/lv-line--update))

  (if window-system
      (add-hook 'exwm-init-hook 'my/lv-line-start)
    (my/lv-line-start))
#+END_SRC

*** Keys
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'my/mode-line-map)
  (define-key my/leader-map (kbd "M-m") 'my/mode-line-map)
#+END_SRC

**** Garbage Collection
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-show-GC-stats nil)
  (defun my/mode-line-toggle-show-GC-stats ()
    (interactive)
    (setq my/mode-line-show-GC-stats (not my/mode-line-show-GC-stats)))

  (define-key my/mode-line-map (kbd "G") 'my/mode-line-toggle-show-GC-stats)
#+END_SRC

*** Mode line modules
**** Buffer name
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-name "")
  (defvar my/max-buffer-name-length 10)

  (defun my/update-max-buffer-name-length()
    (interactive)
    (setq my/max-buffer-name-length (floor (/ (frame-width) 10))))

  (defun my/update-buffer-name-string (BUFFER)
    (interactive)
    (setq my/buffer-name
          (if (> (string-width BUFFER) my/max-buffer-name-length)
              (concat (string-trim-right (substring BUFFER 0 my/max-buffer-name-length)) "...")
            BUFFER)))

  (if window-system
      ;; At this point in the code, exwm hasn't had time to maximize the emacs frame
      (add-hook 'exwm-init-hook 'my/update-max-buffer-name-length)
    ;; If on terminal, just run it now since it's always maximized
    (my/update-max-buffer-name-length))

  ;;(add-hook 'buffer-list-update-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)
  (add-hook 'my/switch-buffer-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)

  ;;(add-hook 'window-configuration-change-hook (lambda () (interactive) (my/update-buffer-name-string (buffer-name)) t) t)
#+END_SRC

**** CPU heat
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-cpu-temp t)

  (if (and
       ;; If lm_sensors is not installed
       (my/is-system-package-installed 'sensors)
       ;; If there aren't any cpu heat sensors (eg. virtual machine)
       (= 0 (string-match-p ""
                            (shell-command-to-string "sensors | grep \"Core 0:\""))))
      (setq my/mode-line-enable-cpu-temp nil))

  (defvar my/cpu-temp "")

  (defun my/update-cpu-temp ()
    (interactive)
    ;;(if my/mode-line-enable-cpu-temp))

    ;; FIXME emacs regexes are wierd, use position of temp in print insead
    (string-match "\+.*C\s" (shell-command-to-string "sensors | grep \"Core 0:\""))
    (setq my/cpu-temp (substring (match-string 0 (shell-command-to-string "sensors | grep \"Core 0:\"")) 0 -3)))

  (if my/mode-line-enable-cpu-temp
      (run-with-timer 0 60 'my/update-cpu-temp))
#+END_SRC

**** Disk space
#+BEGIN_SRC emacs-lisp
  (defvar my/disk-space nil)
  (defun my/update-disk-space ()
    (interactive)
    (setq my/disk-space (my/file-size-human-readable (floor (* 1000 (string-to-number (get-free-disk-space user-emacs-directory)))))))
#+END_SRC

**** Network traffic
***** Linux
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-network-traffic nil)

  (if (file-exists-p "/proc/net/dev")
      (setq my/mode-line-enable-network-traffic t))
#+END_SRC

****** RX
Received
#+BEGIN_SRC emacs-lisp
  (defvar my/rx 0)
  (defvar my/rx-delta-formatted "0")

  (defun my/linux-get-network-rx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((rx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (setq rx (+ rx (read (current-buffer)))))) 
        rx)))

  (defun my/linux-update-network-rx-delta ()
    (interactive)
    (setq my/rx-new (my/linux-get-network-rx))
    (setq my/rx-delta-formatted (my/file-size-human-readable (- my/rx-new my/rx)))
    (setq my/rx my/rx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 1 60 'my/linux-update-network-rx-delta))

  (my/linux-update-network-rx-delta)
#+END_SRC

****** TX
Transmitted
#+BEGIN_SRC emacs-lisp
  (setq my/tx 0)
  (defvar my/tx-delta-formatted "0")

  (defun my/linux-get-network-tx ()
    (with-temp-buffer
      (insert-file-contents "/proc/net/dev")
      (goto-char 1)
      (let ((tx 0))
        (while (search-forward-regexp "^[\s\t]*\\(.*\\):" nil t)
          (unless (string= (match-string 1) "lo")
            (forward-word 8)
            (setq tx (+ tx (read (current-buffer))))))
        tx)))

  (defun my/linux-update-network-tx-delta ()
    (interactive)
    (setq my/tx-new (my/linux-get-network-tx))
    (setq my/tx-delta-formatted  (my/file-size-human-readable (- my/tx-new my/tx)))
    (setq my/tx my/tx-new))

  (if my/mode-line-enable-network-traffic
      (run-with-timer 2 60 'my/linux-update-network-tx-delta))

  (my/linux-update-network-tx-delta)
#+END_SRC

**** Display total line numbers
#+BEGIN_SRC emacs-lisp
  (defvar my/buffer-total-lines nil)

  (defun my/update-total-lines ()
    (save-excursion
      (setq my/buffer-total-lines (format-mode-line "%l" (goto-char (point-max))))))

  (add-hook 'my/switch-buffer-hook 'my/update-total-lines)
  (add-hook 'before-save-hook 'my/update-total-lines)
#+END_SRC

**** Mail
#+BEGIN_SRC emacs-lisp
  ;;  (display-time-use-mail-icon 1)
  ;;  (setq display-time-mail-directory t)
#+END_SRC

**** Battery
If there is a battery, display it in the mode line
#+BEGIN_SRC emacs-lisp
  (require 'battery)

  (display-battery-mode 1)
  (setq battery-mode-line-format "%th - %p")
#+END_SRC

**** Date and time
Display time and date in good format (also displays CPU load)
#+BEGIN_SRC emacs-lisp
  (defvar my/date "")
  (defvar my/time "")

  (defun my/update-date ()
    (interactive)
    (setq my/date (format-time-string "%d-%m-%Y")))

  (defun my/update-time ()
    (interactive)
    (setq my/time (format-time-string "%H:%M")))

  (run-with-timer 3 60 'my/update-time)
  (run-with-timer 0 3600 'my/update-date)

  ;; Update date now
  (my/update-time)
  (my/update-date)
#+END_SRC

**** Git branch name
#+BEGIN_SRC emacs-lisp
  (require 'vc-git)

  (defvar my/buffer-git-branch "")

  (defun my/update-buffer-git-branch ()
    (interactive)
    (setq my/buffer-git-branch (car (vc-git-branches))))

  (add-hook 'my/switch-buffer-hook 'my/update-buffer-git-branch)
#+END_SRC

**** Git project name
When projectile-mode is on, project name is updated on every keypress, here it is fixed
#+BEGIN_SRC emacs-lisp
  (defvar my/projectile-project-name "")

  (defun my/update-projectile-project-name()
    (interactive)
    (setq my/projectile-project-name (projectile-project-name)))

  (add-hook 'my/switch-buffer-hook 'my/update-projectile-project-name)
#+END_SRC

**** Load average
#+BEGIN_SRC emacs-lisp
  (defvar my/load-average 0)
  (defvar my/high-load-average 2)

  (defun my/update-load-average ()
    (interactive)
    (setq my/load-average (/ (nth 0 (load-average)) 100.0)))

  (run-with-timer 4 60 'my/update-load-average)

  (my/update-load-average)
#+END_SRC

**** Ram usage
#+BEGIN_SRC emacs-lisp
  (defvar my/mode-line-enable-available-mem nil)

  (if (file-exists-p "/proc/meminfo")
      (setq my/mode-line-enable-available-mem t))

  (defvar my/available-mem-formatted "nil")
  (defvar my/available-mem 0)

  (defun my/linux-update-available-mem ()
    (interactive)
    (with-temp-buffer
      (insert-file-contents "/proc/meminfo")
      (setq my/mem-string (buffer-string))

      (string-match "MemAvailable:.*\s" my/mem-string)
      (setq my/mem-string (match-string 0 my/mem-string))

      ;; Default returns kb, *1000 to get it to bytes
      (setq my/available-mem (* 1000(string-to-number (substring my/mem-string (string-match "[0-9]" my/mem-string) -1))))
      (setq my/available-mem-formatted (my/file-size-human-readable my/available-mem nil t))))

  (if my/mode-line-enable-available-mem
      (run-with-timer 5 60 'my/linux-update-available-mem))

  ;; Update available mem on startup
  (my/linux-update-available-mem)
#+END_SRC

**** Uptime
#+BEGIN_SRC emacs-lisp
  (defvar my/uptime-start-time (float-time))
  (defvar my/uptime-total-time-formated "0M")

  (defun my/get-uptime-formated-time ()
    (let* ((total-time  (- (float-time) my/uptime-start-time)))
      (if (> total-time (* 60 60))
          (concat (format "%0.1f"(/ total-time 3600.0)) "H")
        (concat (int-to-string (/ (floor total-time) 60)) "M"))))

  (defun my/update-uptime-timer ()
    (interactive)
    (setq my/uptime-total-time-formated (my/get-uptime-formated-time)))

  (run-with-timer 0 60 'my/update-uptime-timer)
#+END_SRC

**** Eye timer
#+BEGIN_SRC emacs-lisp
  (defvar my/eye-timer-last-break (float-time))

  (defvar my/eye-timer-que 0)
  (defvar my/eye-timer-que-formated "")
  ;; In seconds
  (defvar my/eye-timer-break-every (* 21 60))

  (defun my/reset-eye-timer ()
    (interactive)
    (setq my/eye-timer-que 0)
    (setq my/eye-timer-que-formated (my/eye-timer-get-formated-time)))

  (defun my/eye-timer-get-formated-time ()
    (setq my/eye-timer-que-formated (number-to-string my/eye-timer-que)))

  (defun my/update-eye-timer ()
    (interactive)
    (if (> (- (float-time) my/eye-timer-last-break) my/eye-timer-break-every)
        (progn
          (setq my/eye-timer-que (+ 1 my/eye-timer-que))
          (setq my/eye-timer-que-formated (my/eye-timer-get-formated-time))
          (setq my/eye-timer-last-break (float-time)))))

  (run-with-timer 0 60 'my/update-eye-timer)
#+END_SRC

**** Keys
#+BEGIN_SRC emacs-lisp
  (define-key my/system-commands-map (kbd "e") 'my/reset-eye-timer)
#+END_SRC

*** Mode line format
#+BEGIN_SRC emacs-lisp
  (defvar my/frame-width (frame-width))

  (defun my/frame-width-update()
    (setq my/frame-width (frame-width)))

  (add-hook 'exwm-workspace-switch-hook 'my/frame-width-update)
  (add-hook 'exwm-init-hook 'my/frame-width-update t)

  (defun my/mode-line-align (left right)
    "Return a string of `window-width' length containing LEFT, and RIGHT aligned respectively."
    (let* ((available-width (- my/frame-width (length left) 2)))
      (format (format "%%s %%%ds" available-width) left right)))

  ;;mode-line-format
  (setq-default my/lv-line-format
                '(:eval
                  (my/mode-line-align
                   (format-mode-line
                    (quote
                     (

                      ;; Print error if any
                      "%e"

                      ;; Print if recursive editing
                      "%["

                      ;; Information bar
                      mode-line-mule-info
                      mode-line-client

                      ;; If buffer is modified
                      mode-line-modified

                      ;; Turns into @ when remote
                      mode-line-remote

                      " "

                      ;; Print current line number
                      ;;"%l"
                      ;;"%p"
                      (:eval (format "%d" (/ (window-start) 0.01 (point-max))))

                      "~"
                      ;;"@" 
                      ;; Print total line number
                      (:eval my/buffer-total-lines)
                      ;;"%I"

                      ;; is narrowed
                      "%n"

                      " | "

                      ;; Print mode
                      "%m > " 
                      ;; Print buffer name

                      ;;(:eval (buffer-name))

                      (:eval my/buffer-name)

                      ;;"%b"

                      ;; Git branch and project name
                      (:eval (if (not (string= my/projectile-project-name "-"))
                                 (progn
                                   (concat
                                    " > " 
                                    my/buffer-git-branch
                                    "@"
                                    "["
                                    my/projectile-project-name
                                    "]"))))


                      ;; If memory is less than 1GB
                      (:eval (if (< my/available-mem 1000000000)
                                 "GC FULL! JUMP SHIP!"))
                      ))
                    )

                   (format-mode-line
                    (quote
                     (
                      (:eval (if my/mode-line-show-GC-stats
                                 (concat
                                  " GC: " (number-to-string (truncate gc-elapsed))
                                  "(" (number-to-string gcs-done) ")"
                                  " |"
                                  )))

                      (:eval (if my/mode-line-enable-network-traffic
                                 (concat
                                  my/rx-delta-formatted " ↑ "
                                  my/tx-delta-formatted " ↓ |")))

                      (:eval (if my/mode-line-enable-available-mem
                                 (concat " MEM: "
                                         my/available-mem-formatted
                                         " | ")))

                      ;;(:eval (concat "Org:" org-mode-line-string))
                      (:eval (if (boundp 'org-mode-line-string)
                                 (concat "Org:" org-mode-line-string " | ")))
                      (:eval (if (not (eq battery-mode-line-string ""))
                                 (concat "BAT: " battery-mode-line-string "%%%   | ")))

                      (:eval (if my/mode-line-enable-cpu-temp
                                 (concat " - " my/cpu-temp)))

                      "C: "
                      (:eval (number-to-string my/load-average))

                      " |"

                      (:eval (concat " Up: " my/uptime-total-time-formated))
                      (:eval (if (not (= my/eye-timer-que 0))
                                 (propertize (concat  " - E: " my/eye-timer-que-formated) 'face '(:foreground "red"))))


                      " | "

                      (:eval my/time)

                      " - "

                      (:eval my/date)

                      ))
                    ))))
#+END_SRC

* Activity report
#+BEGIN_SRC emacs-lisp
  (defvar my/current-activity nil)

  (defun my/format-activity-report (activity)
    (concat "[" my/date " - " my/time "] " "20 min" " - " activity))

  (defun my/report-activity ()
    (my/add-to-or-create-file-with-content
     (concat user-emacs-directory "ActivityReports.org")
     (my/format-activity-report
      (unwind-protect
          (progn
            (setq my/current-activity nil)
            (setq my/current-activity (completing-read "Report activity: " '(
                                                                             ("None")))))
        (if my/current-activity
            my/current-activity
          (my/add-to-or-create-file-with-content (concat user-emacs-directory "ActivityReports.org") (my/format-activity-report "CANCELLED")))
        ;; Activate timer again, using the second arg in `run-with-timer' doesn't work if you cancel prompt
        (run-with-timer 1200 nil 'my/report-activity)))))

  (defun my/report-close-emacs ()
    (my/add-to-or-create-file-with-content (concat user-emacs-directory "ActivityReports.org") (my/format-activity-report "EMACS QUIT")))

  (add-hook 'kill-emacs-hook 'my/report-close-emacs)

  (run-with-timer 1200 nil 'my/report-activity)
#+END_SRC

* Private config
** Function
#+BEGIN_SRC emacs-lisp
(defun my/load-if-exists (f)
  "load the elisp file only if it exists and is readable"
  (if (file-readable-p f)
      (load-file f)))
#+END_SRC

** Load
#+BEGIN_SRC emacs-lisp
;;(my/load-if-exists "~/.emacs.d/spotify.el")
#+END_SRC

* Report start time
#+BEGIN_SRC emacs-lisp
  (run-with-timer 4 nil (lambda () (interactive) (message (concat "Booted in " (emacs-init-time) " seconds"))))
#+END_SRC

